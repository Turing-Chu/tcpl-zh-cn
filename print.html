<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Crystal 编程语言（中文版）</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="_FontAwesome/css/font-awesome.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        

    </head>
    <body class="light">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="README.html"><strong aria-hidden="true">1.</strong> 介绍</a></li><li><a href="installation/README.html"><strong aria-hidden="true">2.</strong> 安装</a></li><li><ol class="section"><li><a href="installation/on_debian_and_ubuntu.html"><strong aria-hidden="true">2.1.</strong> 在 Debian 和 Ubuntu 系统上安装</a></li><li><a href="installation/on_redhat_and_centos.html"><strong aria-hidden="true">2.2.</strong> 在 RedHat 和 CentOS 系统上安装</a></li><li><a href="installation/on_arch_linux.html"><strong aria-hidden="true">2.3.</strong> 在 Arch Linux 系统上安装</a></li><li><a href="installation/on_gentoo_linux.html"><strong aria-hidden="true">2.4.</strong> 在 Gentoo Linux 系统上安装</a></li><li><a href="installation/on_mac_osx_using_homebrew.html"><strong aria-hidden="true">2.5.</strong> 在 Mac OSX 上使用 Homebrew 安装</a></li><li><a href="installation/on_linux_using_linuxbrew.html"><strong aria-hidden="true">2.6.</strong> 在 Linux 上使用 Linuxbrew 安装</a></li><li><a href="installation/on_bash_on_ubuntu_on_windows.html"><strong aria-hidden="true">2.7.</strong> 在 Windows 的子系统 Linux 上安装</a></li><li><a href="installation/from_a_targz.html"><strong aria-hidden="true">2.8.</strong> 从 tar.gz 文件中安装</a></li><li><a href="installation/from_source_repository.html"><strong aria-hidden="true">2.9.</strong> 源码编译</a></li></ol></li><li><a href="using_the_compiler/README.html"><strong aria-hidden="true">3.</strong> 使用编译器</a></li><li><a href="overview/README.html"><strong aria-hidden="true">4.</strong> 概览与示例</a></li><li><ol class="section"><li><a href="overview/hello_world.html"><strong aria-hidden="true">4.1.</strong> Hello World!</a></li><li><a href="overview/http_server.html"><strong aria-hidden="true">4.2.</strong> HTTP 服务器</a></li></ol></li><li><a href="syntax_and_semantics/README.html"><strong aria-hidden="true">5.</strong> 语法和语义</a></li><li><ol class="section"><li><a href="syntax_and_semantics/comments.html"><strong aria-hidden="true">5.1.</strong> 注释</a></li><li><a href="syntax_and_semantics/literals.html"><strong aria-hidden="true">5.2.</strong> 常量</a></li><li><ol class="section"><li><a href="syntax_and_semantics/literals/nil.html"><strong aria-hidden="true">5.2.1.</strong> 空值(Nil)</a></li><li><a href="syntax_and_semantics/literals/bool.html"><strong aria-hidden="true">5.2.2.</strong> Bool值(Bool)</a></li><li><a href="syntax_and_semantics/literals/integers.html"><strong aria-hidden="true">5.2.3.</strong> 整数(Integers)</a></li><li><a href="syntax_and_semantics/literals/floats.html"><strong aria-hidden="true">5.2.4.</strong> 浮点数(Floats)</a></li><li><a href="syntax_and_semantics/literals/char.html"><strong aria-hidden="true">5.2.5.</strong> 字符(Char)</a></li><li><a href="syntax_and_semantics/literals/string.html"><strong aria-hidden="true">5.2.6.</strong> 字符串(String)</a></li><li><a href="syntax_and_semantics/literals/symbol.html"><strong aria-hidden="true">5.2.7.</strong> 符号(Symbol)</a></li><li><a href="syntax_and_semantics/literals/array.html"><strong aria-hidden="true">5.2.8.</strong> 数组(Array)</a></li><li><a href="syntax_and_semantics/literals/hash.html"><strong aria-hidden="true">5.2.9.</strong> 哈希(Hash)</a></li><li><a href="syntax_and_semantics/literals/range.html"><strong aria-hidden="true">5.2.10.</strong> 范围(Range)</a></li><li><a href="syntax_and_semantics/literals/regex.html"><strong aria-hidden="true">5.2.11.</strong> 正则(Regex)</a></li><li><a href="syntax_and_semantics/literals/tuple.html"><strong aria-hidden="true">5.2.12.</strong> 元组(Tuple)</a></li><li><a href="syntax_and_semantics/literals/named_tuple.html"><strong aria-hidden="true">5.2.13.</strong> 具名元组(NamedTuple)</a></li><li><a href="syntax_and_semantics/literals/proc.html"><strong aria-hidden="true">5.2.14.</strong> 过程(Proc)</a></li></ol></li><li><a href="syntax_and_semantics/assignment.html"><strong aria-hidden="true">5.3.</strong> 赋值</a></li><li><ol class="section"><li><a href="syntax_and_semantics/multiple_assignment.html"><strong aria-hidden="true">5.3.1.</strong> Multiple assignment</a></li></ol></li><li><a href="syntax_and_semantics/local_variables.html"><strong aria-hidden="true">5.4.</strong> 局部变量</a></li><li><a href="syntax_and_semantics/control_expressions.html"><strong aria-hidden="true">5.5.</strong> 控制表达式</a></li><li><ol class="section"><li><a href="syntax_and_semantics/truthy_and_falsey_values.html"><strong aria-hidden="true">5.5.1.</strong> 真假值</a></li><li><a href="syntax_and_semantics/if.html"><strong aria-hidden="true">5.5.2.</strong> if</a></li><li><ol class="section"><li><a href="syntax_and_semantics/as_a_suffix.html"><strong aria-hidden="true">5.5.2.1.</strong> 用作后缀</a></li><li><a href="syntax_and_semantics/as_an_expression.html"><strong aria-hidden="true">5.5.2.2.</strong> 用作表达式</a></li><li><a href="syntax_and_semantics/ternary_if.html"><strong aria-hidden="true">5.5.2.3.</strong> 三元 if</a></li><li><a href="syntax_and_semantics/if_var.html"><strong aria-hidden="true">5.5.2.4.</strong> if var</a></li><li><a href="syntax_and_semantics/if_varis_a.html"><strong aria-hidden="true">5.5.2.5.</strong> if var.is_a?(...)</a></li><li><a href="syntax_and_semantics/if_varresponds_to.html"><strong aria-hidden="true">5.5.2.6.</strong> if var.responds_to?(...)</a></li><li><a href="syntax_and_semantics/if_var_nil.html"><strong aria-hidden="true">5.5.2.7.</strong> if var.nil?</a></li><li><a href="syntax_and_semantics/not.html"><strong aria-hidden="true">5.5.2.8.</strong> if !</a></li></ol></li><li><a href="syntax_and_semantics/unless.html"><strong aria-hidden="true">5.5.3.</strong> 无限循环</a></li><li><a href="syntax_and_semantics/case.html"><strong aria-hidden="true">5.5.4.</strong> case 语句</a></li><li><a href="syntax_and_semantics/while.html"><strong aria-hidden="true">5.5.5.</strong> while 语句</a></li><li><ol class="section"><li><a href="syntax_and_semantics/break.html"><strong aria-hidden="true">5.5.5.1.</strong> break 语句</a></li><li><a href="syntax_and_semantics/next.html"><strong aria-hidden="true">5.5.5.2.</strong> next 语句</a></li></ol></li><li><a href="syntax_and_semantics/until.html"><strong aria-hidden="true">5.5.6.</strong> until 语句</a></li><li><a href="syntax_and_semantics/and.html"><strong aria-hidden="true">5.5.7.</strong> &amp;&amp;</a></li><li><a href="syntax_and_semantics/or.html"><strong aria-hidden="true">5.5.8.</strong> ||</a></li></ol></li><li><a href="syntax_and_semantics/requiring_files.html"><strong aria-hidden="true">5.6.</strong> Requiring files</a></li><li><a href="syntax_and_semantics/types_and_methods.html"><strong aria-hidden="true">5.7.</strong> 类型和方法</a></li><li><ol class="section"><li><a href="syntax_and_semantics/everything_is_an_object.html"><strong aria-hidden="true">5.7.1.</strong> 任何事物都是对象</a></li><li><a href="syntax_and_semantics/the_program.html"><strong aria-hidden="true">5.7.2.</strong> The Program</a></li><li><a href="syntax_and_semantics/classes_and_methods.html"><strong aria-hidden="true">5.7.3.</strong> 类与方法</a></li><li><ol class="section"><li><a href="syntax_and_semantics/new,_initialize_and_allocate.html"><strong aria-hidden="true">5.7.3.1.</strong> 新建，初始化，内存分配</a></li><li><a href="syntax_and_semantics/methods_and_instance_variables.html"><strong aria-hidden="true">5.7.3.2.</strong> 方法与实例变量</a></li><li><a href="syntax_and_semantics/type_inference.html"><strong aria-hidden="true">5.7.3.3.</strong> 类型推断</a></li><li><a href="syntax_and_semantics/union_types.html"><strong aria-hidden="true">5.7.3.4.</strong> 联合体类型</a></li><li><a href="syntax_and_semantics/overloading.html"><strong aria-hidden="true">5.7.3.5.</strong> 重载</a></li><li><a href="syntax_and_semantics/default_and_named_arguments.html"><strong aria-hidden="true">5.7.3.6.</strong> 默认值与参数命名</a></li><li><a href="syntax_and_semantics/splats_and_tuples.html"><strong aria-hidden="true">5.7.3.7.</strong> Splats and tuples</a></li><li><a href="syntax_and_semantics/type_restrictions.html"><strong aria-hidden="true">5.7.3.8.</strong> 类型约束</a></li><li><a href="syntax_and_semantics/return_types.html"><strong aria-hidden="true">5.7.3.9.</strong> 返回值类型</a></li><li><a href="syntax_and_semantics/default_values_named_arguments_splats_tuples_and_overloading.html"><strong aria-hidden="true">5.7.3.10.</strong> 方法的参数</a></li><li><a href="syntax_and_semantics/operators.html"><strong aria-hidden="true">5.7.3.11.</strong> 操作符</a></li><li><a href="syntax_and_semantics/visibility.html"><strong aria-hidden="true">5.7.3.12.</strong> 可视化</a></li><li><a href="syntax_and_semantics/inheritance.html"><strong aria-hidden="true">5.7.3.13.</strong> 继承</a></li><li><ol class="section"><li><a href="syntax_and_semantics/virtual_and_abstract_types.html"><strong aria-hidden="true">5.7.3.13.1.</strong> 虚拟类型和抽象类型</a></li></ol></li><li><a href="syntax_and_semantics/class_methods.html"><strong aria-hidden="true">5.7.3.14.</strong> 类方法</a></li><li><a href="syntax_and_semantics/class_variables.html"><strong aria-hidden="true">5.7.3.15.</strong> 类变量</a></li><li><a href="syntax_and_semantics/finalize.html"><strong aria-hidden="true">5.7.3.16.</strong> finalize</a></li></ol></li><li><a href="syntax_and_semantics/modules.html"><strong aria-hidden="true">5.7.4.</strong> 模块</a></li><li><a href="syntax_and_semantics/generics.html"><strong aria-hidden="true">5.7.5.</strong> 泛型</a></li><li><a href="syntax_and_semantics/structs.html"><strong aria-hidden="true">5.7.6.</strong> 结构体</a></li><li><a href="syntax_and_semantics/constants.html"><strong aria-hidden="true">5.7.7.</strong> 常量</a></li><li><a href="syntax_and_semantics/enum.html"><strong aria-hidden="true">5.7.8.</strong> 枚举</a></li><li><a href="syntax_and_semantics/blocks_and_procs.html"><strong aria-hidden="true">5.7.9.</strong> 块与过程</a></li><li><ol class="section"><li><a href="syntax_and_semantics/capturing_blocks.html"><strong aria-hidden="true">5.7.9.1.</strong> Capturing blocks</a></li><li><a href="syntax_and_semantics/proc_literal.html"><strong aria-hidden="true">5.7.9.2.</strong> Proc literal</a></li><li><a href="syntax_and_semantics/block_forwarding.html"><strong aria-hidden="true">5.7.9.3.</strong> Block forwarding</a></li><li><a href="syntax_and_semantics/closures.html"><strong aria-hidden="true">5.7.9.4.</strong> 闭包</a></li></ol></li><li><a href="syntax_and_semantics/alias.html"><strong aria-hidden="true">5.7.10.</strong> 别名</a></li></ol></li><li><a href="syntax_and_semantics/exception_handling.html"><strong aria-hidden="true">5.8.</strong> 异常处理</a></li><li><a href="syntax_and_semantics/type_grammar.html"><strong aria-hidden="true">5.9.</strong> 类型语法</a></li><li><a href="syntax_and_semantics/type_reflection.html"><strong aria-hidden="true">5.10.</strong> 类型反射</a></li><li><ol class="section"><li><a href="syntax_and_semantics/is_a.html"><strong aria-hidden="true">5.10.1.</strong> is_a?</a></li><li><a href="syntax_and_semantics/nil_question.html"><strong aria-hidden="true">5.10.2.</strong> nil?</a></li><li><a href="syntax_and_semantics/responds_to.html"><strong aria-hidden="true">5.10.3.</strong> responds_to?</a></li><li><a href="syntax_and_semantics/as.html"><strong aria-hidden="true">5.10.4.</strong> as</a></li><li><a href="syntax_and_semantics/as_question.html"><strong aria-hidden="true">5.10.5.</strong> as?</a></li><li><a href="syntax_and_semantics/typeof.html"><strong aria-hidden="true">5.10.6.</strong> typeof</a></li></ol></li><li><a href="syntax_and_semantics/macros.html"><strong aria-hidden="true">5.11.</strong> 宏</a></li><li><ol class="section"><li><a href="syntax_and_semantics/macros/macro_methods.html"><strong aria-hidden="true">5.11.1.</strong> 宏方法</a></li><li><a href="syntax_and_semantics/macros/hooks.html"><strong aria-hidden="true">5.11.2.</strong> 钩子</a></li><li><a href="syntax_and_semantics/macros/fresh_variables.html"><strong aria-hidden="true">5.11.3.</strong> Fresh variables</a></li></ol></li><li><a href="syntax_and_semantics/attributes.html"><strong aria-hidden="true">5.12.</strong> 属性</a></li><li><a href="syntax_and_semantics/low_level_primitives.html"><strong aria-hidden="true">5.13.</strong> Low-level primitives</a></li><li><ol class="section"><li><a href="syntax_and_semantics/pointerof.html"><strong aria-hidden="true">5.13.1.</strong> pointerof</a></li><li><a href="syntax_and_semantics/sizeof.html"><strong aria-hidden="true">5.13.2.</strong> sizeof</a></li><li><a href="syntax_and_semantics/instance_sizeof.html"><strong aria-hidden="true">5.13.3.</strong> instance_sizeof</a></li><li><a href="syntax_and_semantics/declare_var.html"><strong aria-hidden="true">5.13.4.</strong> 未初始化变量声明</a></li></ol></li><li><a href="syntax_and_semantics/compile_time_flags.html"><strong aria-hidden="true">5.14.</strong> Compile-time flags</a></li><li><ol class="section"><li><a href="syntax_and_semantics/cross-compilation.html"><strong aria-hidden="true">5.14.1.</strong> 交叉编译</a></li></ol></li><li><a href="syntax_and_semantics/c_bindings/README.html"><strong aria-hidden="true">5.15.</strong> C代码绑定</a></li><li><ol class="section"><li><a href="syntax_and_semantics/c_bindings/lib.html"><strong aria-hidden="true">5.15.1.</strong> 库</a></li><li><a href="syntax_and_semantics/c_bindings/fun.html"><strong aria-hidden="true">5.15.2.</strong> 函数</a></li><li><ol class="section"><li><a href="syntax_and_semantics/c_bindings/out.html"><strong aria-hidden="true">5.15.2.1.</strong> out</a></li><li><a href="syntax_and_semantics/c_bindings/to_unsafe.html"><strong aria-hidden="true">5.15.2.2.</strong> to_unsafe</a></li></ol></li><li><a href="syntax_and_semantics/c_bindings/struct.html"><strong aria-hidden="true">5.15.3.</strong> 结构体</a></li><li><a href="syntax_and_semantics/c_bindings/union.html"><strong aria-hidden="true">5.15.4.</strong> 联合体</a></li><li><a href="syntax_and_semantics/c_bindings/enum.html"><strong aria-hidden="true">5.15.5.</strong> 枚举</a></li><li><a href="syntax_and_semantics/c_bindings/variables.html"><strong aria-hidden="true">5.15.6.</strong> 变量</a></li><li><a href="syntax_and_semantics/c_bindings/constants.html"><strong aria-hidden="true">5.15.7.</strong> 常量</a></li><li><a href="syntax_and_semantics/c_bindings/type.html"><strong aria-hidden="true">5.15.8.</strong> 类型</a></li><li><a href="syntax_and_semantics/c_bindings/alias.html"><strong aria-hidden="true">5.15.9.</strong> 别名</a></li><li><a href="syntax_and_semantics/c_bindings/callbacks.html"><strong aria-hidden="true">5.15.10.</strong> 回调</a></li></ol></li><li><a href="syntax_and_semantics/unsafe.html"><strong aria-hidden="true">5.16.</strong> 不安全代码</a></li></ol></li><li><a href="conventions/README.html"><strong aria-hidden="true">6.</strong> 惯例</a></li><li><ol class="section"><li><a href="conventions/coding_style.html"><strong aria-hidden="true">6.1.</strong> 代码风格</a></li><li><a href="conventions/documenting_code.html"><strong aria-hidden="true">6.2.</strong> 文档化代码</a></li></ol></li><li><a href="database/README.html"><strong aria-hidden="true">7.</strong> 数据库</a></li><li><ol class="section"><li><a href="database/connection_pool.html"><strong aria-hidden="true">7.1.</strong> 连接池</a></li></ol></li><li><a href="guides/README.html"><strong aria-hidden="true">8.</strong> 指引</a></li><li><ol class="section"><li><a href="guides/performance.html"><strong aria-hidden="true">8.1.</strong> 性能</a></li><li><a href="guides/concurrency.html"><strong aria-hidden="true">8.2.</strong> 并发</a></li><li><a href="guides/testing.html"><strong aria-hidden="true">8.3.</strong> 测试</a></li><li><a href="guides/writing_shards.html"><strong aria-hidden="true">8.4.</strong> 编写 Shards</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Crystal 编程语言（中文版）</h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="print.html#crystal-编程语言" id="crystal-编程语言"><h1>Crystal 编程语言</h1></a>
<p><a href="https://travis-ci.org/Turing-Chu/tcpl-zh-cn.svg?branch=master"><img src="https://travis-ci.org/Turing-Chu/tcpl-zh-cn.svg?branch=master" alt="Build Status" /></a></p>
<p>本书为 Crystal 编程语言中文版的参考书。</p>
<p>Crystal 是一门以如下所列为目的的编程语言。</p>
<ul>
<li>同 Ruby 相似的语法，但并不以与 Ruby 兼容为目的。</li>
<li>静态类型检查，但并不指定变量或方法参数的类型。</li>
<li>可以在 Crystal 中编写同 C 语言绑定的代码以调用 C 语言代码。</li>
<li>拥有编译时代码评估和迭代以避免样板代码。</li>
<li>本地化代码的高效编译。</li>
</ul>
<a class="header" href="print.html#a向语言参考作贡献" id="a向语言参考作贡献"><h2>向语言参考作贡献</h2></a>
<p>本书初步开始翻译，欢迎提 Issue 或 PR ：<a href="https://github.com/Turing-Chu/tcpl-zh-cn.git">https://github.com/Turing-Chu/tcpl-zh-cn.git</a></p>
<p>本书每个文件皆包含<a href="https://github.com/crystal-lang/crystal-book.git">原书</a>文件地址和文件最后一次修改的 commit hash。如发现不一致，欢迎 提 Issue 或 PR。</p>
<p>本书以 Rust 语言的 mdbook 进行构建和管理，期待 Crystal 语言自身类似 gitbook 或 mdbook 的工具。</p>
<a class="header" href="print.html#a安装" id="a安装"><h1>安装</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/installation/README.md">installation/README.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/249a86b68c6b80c3a87b98bae9f97705e7195a0d">commit 249a86b68c6b80c3a87b98bae9f97705e7195a0d</a></p>
</blockquote>
<p>当你使用下面的方法安装编译器的时候，最好阅读<a href="../using_the_compiler/README.md">使用编译器</a>来了解怎样高效地使用编译器。</p>
<ul>
<li><a href="on_debian_and_ubuntu.html">Debian 与 Ubuntu</a></li>
<li><a href="on_redhat_and_centos.html">RedHat 与 CentOS</a></li>
<li><a href="on_arch_linux.html">Arch Linux</a></li>
<li><a href="on_gentoo_linux.html">Gentoo Linux</a></li>
<li><a href="on_mac_osx_using_homebrew.html">在 Mac OSX 上使用 Homebrew</a></li>
<li><a href="on_linux_using_linuxbrew.html">在 Linux 上使用 Linuxbrew</a></li>
<li><a href="on_bash_on_ubuntu_on_windows.html">Windows 上 Ubuntu 子系统的 Bash</a></li>
<li><a href="from_a_targz.html">从 tar.gz 中安装</a></li>
<li><a href="from_source_repository.html">源码编译</a></li>
</ul>
<a class="header" href="print.html#debian-和-ubuntu" id="debian-和-ubuntu"><h1>Debian 和 Ubuntu</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/installation/on_debian_and_ubuntu.md">installation/on_debian_and_ubuntu.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/7932bad6385c21a3cc293f6323434fae28c564a1">commit 7932bad6385c21a3cc293f6323434fae28c564a1</a></p>
</blockquote>
<p>在 Debian 衍生的分支系统上，可以使用官方 Crystal 仓库来安装。</p>
<a class="header" href="print.html#a设置仓库" id="a设置仓库"><h2>设置仓库</h2></a>
<p>首先必须把仓库加到 APT 配置里面去。这很容易设置，只需在命令行中执行：</p>
<pre><code>curl https://dist.crystal-lang.org/apt/setup.sh | sudo bash
</code></pre>
<p>这行脚本会加上签名密钥和仓库配置。如果希望手动配置，则需要以 <em>root</em> 执行下面的命令：</p>
<pre><code>apt-key adv --keyserver keys.gnupg.net --recv-keys 09617FD37CC06B54
echo &quot;deb https://dist.crystal-lang.org/apt crystal main&quot; &gt; /etc/apt/sources.list.d/crystal.list
apt-get update
</code></pre>
<a class="header" href="print.html#a安装-1" id="a安装-1"><h2>安装</h2></a>
<p>一旦配置好仓库，就可以准备安装 Crystal 了：</p>
<pre><code>sudo apt-get install crystal
</code></pre>
<p>当运行或构建 Crystal 程序时，你<a href="https://github.com/crystal-lang/crystal/issues/4342">可能需要</a>安装 <code>build-essential</code> 包。可以使用下面命令来安装：</p>
<pre><code>sudo apt-get install build-essential
</code></pre>
<a class="header" href="print.html#a升级" id="a升级"><h2>升级</h2></a>
<p>当 Crystal 新版本发布时，可以使用下面命令升级系统：</p>
<pre><code>sudo apt-get update
sudo apt-get install crystal
</code></pre>
<a class="header" href="print.html#redhat-和-centos" id="redhat-和-centos"><h1>RedHat 和 CentOS</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/installation/on_redhat_and_centos.md">installation/on_redhat_and_centos.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/5ef4aa4a2a86e3b08e52ac9f6af8488972b4067b">commit 5ef4aa4a2a86e3b08e52ac9f6af8488972b4067b</a>:</p>
</blockquote>
<p>在 RedHat 衍生的分支系统上，可以使用官方 Crystal 仓库。</p>
<a class="header" href="print.html#a设置仓库-1" id="a设置仓库-1"><h2>设置仓库</h2></a>
<p>首先必须把仓库加到 YUM 配置里面去。这很容易设置，只需在命令行中执行：</p>
<pre><code>curl https://dist.crystal-lang.org/rpm/setup.sh | sudo bash
</code></pre>
<p>这行脚本会加上签名密钥和仓库配置。如果希望手动配置：</p>
<pre><code>rpm --import https://dist.crystal-lang.org/rpm/RPM-GPG-KEY

cat &gt; /etc/yum.repos.d/crystal.repo &lt;&lt;END
[crystal]
name = Crystal
baseurl = https://dist.crystal-lang.org/rpm/
END
</code></pre>
<a class="header" href="print.html#a安装-2" id="a安装-2"><h2>安装</h2></a>
<p>一旦配置好仓库，就可以准备安装 Crystal 了：</p>
<pre><code>sudo yum install crystal
</code></pre>
<a class="header" href="print.html#a升级-1" id="a升级-1"><h2>升级</h2></a>
<p>当 Crystal 新版本发布时，可以使用下面命令升级系统：</p>
<pre><code>sudo yum update crystal
</code></pre>
<a class="header" href="print.html#arch-linux" id="arch-linux"><h1>Arch Linux</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/installation/on_arch_linux.md">installation/on_arch_linux.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/b325eaf8c4ddce0bab9acfe0aac91b331081d1e1">commit b325eaf8c4ddce0bab9acfe0aac91b331081d1e1</a></p>
</blockquote>
<p>在 Arch Linux 的公共仓库中，包含了 Crystal 编译器。</p>
<a class="header" href="print.html#a安装-3" id="a安装-3"><h2>安装</h2></a>
<pre><code>sudo pacman -S crystal
</code></pre>
<a class="header" href="print.html#gentoo-linux" id="gentoo-linux"><h1>Gentoo Linux</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/installation/on_gentoo_linux.md">installation/on_gentoo_linux.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/dd80919fe40cc3cab8597155fadb002593fdf329">commit dd80919fe40cc3cab8597155fadb002593fdf329</a></p>
</blockquote>
<p>Gentoo Linux 的主干分支上覆盖了 Crystal 编译器。</p>
<a class="header" href="print.html#a配置" id="a配置"><h2>配置</h2></a>
<p>或许需要先看下可用的配置：</p>
<pre><code># equery u dev-lang/crystal
[ Legend : U - final flag setting for installation]
[        : I - package is installed with flag     ]
[ Colors : set, unset                             ]
 * Found these USE flags for dev-lang/crystal-0.18.7:
 U I
 - - doc      : Add extra documentation (API, Javadoc, etc). It is recommended to enable per package instead of globally
 - - examples : Install examples, usually source code
 + + xml      : Use the dev-libs/libxml2 library to enable Crystal xml module
 + - yaml     : Use the dev-libs/libyaml library to enable Crystal yaml module
</code></pre>
<a class="header" href="print.html#a安装-4" id="a安装-4"><h2>安装</h2></a>
<pre><code>su -
emerge -a dev-lang/crystal
</code></pre>
<a class="header" href="print.html#a在-mac-osx-上使用-homebrew" id="a在-mac-osx-上使用-homebrew"><h1>在 Mac OSX 上使用 Homebrew</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/installation/on_mac_osx_using_homebrew.md">installation/on_mac_osx_using_homebrew</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/3a168049d61f3ae7c51f8dfbf9d6f582b610dfa5">commit 3a168049d61f3ae7c51f8dfbf9d6f582b610dfa5</a></p>
</blockquote>
<p>在 Mac 上可以很容易地使用 <a href="http://brew.sh/">Homebrew</a> 来安装 Crystal 。</p>
<pre><code>brew update
brew install crystal-lang
</code></pre>
<p>如果打算为 Crystal 语言做贡献，也可以安装 LLVM 。因此，以下面代码代替最后一行：</p>
<pre><code>brew install crystal-lang --with-llvm
</code></pre>
<a class="header" href="print.html#a在-osx-1011-el-capitan-上的异常处理" id="a在-osx-1011-el-capitan-上的异常处理"><h2>在 OSX 10.11 (El Capitan) 上的异常处理</h2></a>
<p>如果得到一个类似这样的错误:</p>
<pre><code>ld: library not found for -levent
</code></pre>
<p>则需要重新安装命令行工具并选择默认的有效工具链：</p>
<pre><code>$ xcode-select --install
$ xcode-select --switch /Library/Developer/CommandLineTools
</code></pre>
<a class="header" href="print.html#a在-linux-上使用-linuxbrew" id="a在-linux-上使用-linuxbrew"><h1>在 Linux 上使用 Linuxbrew</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/installation/on_linux_using_linuxbrew.md">installation/on_linux_using_linuxbrew.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/2d737490a87dd2276929b73abdacb3ff33001e3c">commit 2d737490a87dd2276929b73abdacb3ff33001e3c</a></p>
</blockquote>
<p>在 Linux 的分支系统上，可以很容易地使用 <a href="http://linuxbrew.sh/">Linuxbrew</a> 来安装 Crystal 。</p>
<pre><code>brew update
brew install crystal-lang
</code></pre>
<p>如果打算为 Crystal 语言做贡献，也可以安装 LLVM。因此使用下面这行命令代替最后一行：</p>
<pre><code>brew install crystal-lang --with-llvm
</code></pre>
<a class="header" href="print.html#a在-windows-子系统-ubuntu-的-bash-上" id="a在-windows-子系统-ubuntu-的-bash-上"><h1>在 Windows 子系统 Ubuntu 的 Bash 上</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/installation/on_bash_on_ubuntu_on_windows.md">installation/on_bash_on_ubuntu_on_windows.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/9015d4fde569f9ab80de819cd79a1d6f19594649">commit 9015d4fde569f9ab80de819cd79a1d6f19594649</a></p>
</blockquote>
<p>Crystal _尚未_支持 Windows，如果正在使用 Windows 10 则可以（尝试）通过 <a href="https://msdn.microsoft.com/en-us/commandline/wsl/about">Bash on Ubuntu on Windows</a> -- 运行在 Windows 上的 Bash 测试环境来使用Crystal。本部分的安装说明与 <a href="on_debian_and_ubuntu.md">Debian/Ubuntu</a> 的类似，但并没那么多毛边需要注意。</p>
<p>记住：<strong>这只是一个测试环境</strong>。</p>
<a class="header" href="print.html#a设置仓库-2" id="a设置仓库-2"><h2>设置仓库</h2></a>
<p>首先必须把仓库加到 APT 配置里面去。这很容易设置，只需在命令行中执行：</p>
<pre><code>curl -sSL https://dist.crystal-lang.org/apt/setup.sh | sudo bash
</code></pre>
<p>这行脚本会加上签名密钥和仓库配置。如果希望手动配置，则可以执行下面的命令：</p>
<pre><code>sudo apt-key adv --keyserver keys.gnupg.net --recv-keys 09617FD37CC06B54
echo &quot;deb https://dist.crystal-lang.org/apt crystal main&quot; | sudo tee /etc/apt/sources.list.d/crystal.list
sudo apt-get update
</code></pre>
<a class="header" href="print.html#a依赖" id="a依赖"><h2>依赖</h2></a>
<p>Crystal 需要 C 编译器 （ <code>cc</code> ）和连接器 （ <code>ld</code> ）来编译 Crystal程序，所以也需要安装 <code>cc</code> 和 <code>ld</code> ：</p>
<pre><code>sudo apt-get install clang binutils
</code></pre>
<a class="header" href="print.html#a安装-5" id="a安装-5"><h2>安装</h2></a>
<p>一旦配置好仓库，就可以准备安装 Crystal 了：</p>
<pre><code>sudo apt-get install crystal
</code></pre>
<a class="header" href="print.html#a升级-2" id="a升级-2"><h2>升级</h2></a>
<p>当 Crystal 新版本发布时，可以使用下面命令升级系统：</p>
<pre><code>sudo apt-get update
sudo apt-get install crystal
</code></pre>
<a class="header" href="print.html#a从-targz-中安装" id="a从-targz-中安装"><h1>从 tar.gz 中安装</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/installation/from_a_targz.md">installation/from_a_targz.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/d14f351a8c523e9d9d11efd29ed1a0552c04d7db">commit d14f351a8c523e9d9d11efd29ed1a0552c04d7db</a></p>
</blockquote>
<p>如果因为某个原因或不愿意使用上面的安装方式，也可以下载 Crystal 的单独的 .tar.gz 文件。</p>
<p>最新文件可以在 GitHub 上的发布页面找到：<a href="https://github.com/crystal-lang/crystal/releases">https://github.com/crystal-lang/crystal/releases</a></p>
<p>下载对应平台的文件并解压。在压缩包里会有一个可执行文件 <code>bin/crystal</code>。</p>
<p>为了便于使用，也可以创建一个符号链接：</p>
<p><code>ln -s [full path to bin/crystal] /usr/local/bin/crystal</code></p>
<p>然后就可以键入 <code>crystal</code> 来使用编译器了。</p>
<a class="header" href="print.html#a从源码编译" id="a从源码编译"><h1>从源码编译</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/installation/from_source_repository.md">installation/from_source_repository.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/249a86b68c6b80c3a87b98bae9f97705e7195a0d">commit 249a86b68c6b80c3a87b98bae9f97705e7195a0d</a></p>
</blockquote>
<p>如果你希望贡献，那么你可以源码编译 Crystal。</p>
<ol>
<li><a href="https://crystal-lang.org/docs/installation">安装最新发布版 Crystal </a>。需要 Crystal 来编译 Crystal :) 。</li>
<li>确保当前路径下 LLVM 版本是可用的。目前，Crystal 支持 LLVM 3.8、3.9、4.0 和 5.0 。如果可能，请使用最新版。如果使用 Mac 以及 Homebrew 方式，当加上 <code>--with-llvm</code> 参数时会自动为你配置。</li>
<li>确保已经安装了<a href="https://github.com/crystal-lang/crystal/wiki/All-required-libraries">所有依赖库</a>。可以看下 <a href="https://github.com/crystal-lang/crystal/blob/master/CONTRIBUTING.md">贡献指引</a> 。</li>
<li>克隆仓库：</li>
</ol>
<pre><code>git clone https://github.com/crystal-lang/crystal
</code></pre>
<ol start="5">
<li>运行 <code>make</code> 来构建你自己版本的编译器。</li>
<li>运行 <code>make spec</code> 以确保所有的 specs(specifications) 都通过，之后一切便都正确安装了。</li>
<li>使用 <code>bin/crystal</code> 来运行 crystal 文件。</li>
</ol>
<p>如果想获取更多关于 <code>bin/crystal</code> 的信息，请查阅<a href="https://crystal-lang.org/docs/using_the_compiler">编译器使用</a>文档。</p>
<p>注意：实际的二进制文件会被构建到 <code>.build/crystal</code> ，但是 <code>bin/crystal</code> 则是应该用以执行 crysta 的封装脚本。</p>
<a class="header" href="print.html#a编译器的使用" id="a编译器的使用"><h1>编译器的使用</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/using_the_compiler/README.md">using_the_compiler/README.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/6133ed0106b43ed5801dfbb4939f5a0ab27332ad">commit 6133ed0106b43ed5801dfbb4939f5a0ab27332ad</a></p>
</blockquote>
<p>当<a href="../installation/README.md">安装</a>好编译器之后，在你的环境<!-- 原文单词 disposal-->中便生成了一个二进制文件 <code>crystal</code> 。</p>
<p>在接下来的部分中， <code>$</code> 符号表示命令行。</p>
<a class="header" href="print.html#a单次编译和运行" id="a单次编译和运行"><h2>单次编译和运行</h2></a>
<p>可以调用 带有单个文件名的 <code>crystal</code> 来一次性编译和运行一个程序：</p>
<pre><code>$ crystal some_program.cr
</code></pre>
<p>crystal 文件皆以 <code>.cr</code> 扩展名结尾。</p>
<p>或者也可以使用 <code>run</code> 命令：</p>
<pre><code>$ crystal run some_program.cr
</code></pre>
<a class="header" href="print.html#a创建动态链接的可执行文件" id="a创建动态链接的可执行文件"><h2>创建动态链接的可执行文件</h2></a>
<p>可以使用 <code>build</code> 命令创建一个可执行文件。</p>
<pre><code>$ crystal build some_program.cr
</code></pre>
<p>这会生成一个 <code>some_program</code> 文件然后你可以执行：</p>
<pre><code>$ ./some_program
</code></pre>
<p><strong>注意：</strong> 默认生成的可执行文件<strong>并没有全部优化</strong>。可以使用 <code>--release</code> 参数来优化：</p>
<pre><code>$ crystal build some_program.cr --release
</code></pre>
<p>当可执行文件准备用于生产或基于性能考虑时，确保总是使用 <code>--release</code>。</p>
<p>这是因为没有全部优化的性能仍然相当好，并且编译时间也很快，因此 <code>crystal</code> 命令几乎相当于一个解释程序。</p>
<p>为了降低二进制文件的大小，可以加上 <code>--no-debug</code> 参数并使用 <code>strip</code> 命令。如果文件大小是个问题或者无需调试程序的话，使用这个选项会删除掉 Debug 符号。</p>
<a class="header" href="print.html#a创建一个静态连接的可执行文件" id="a创建一个静态连接的可执行文件"><h2>创建一个静态连接的可执行文件</h2></a>
<p>把你的程序构建成一个静态链接的可执行文件：</p>
<pre><code>$ crystal build some_program.cr --release --static
</code></pre>
<p><strong>注意：</strong> 构建静态链接的可执行文件目前仅在 Alpine Linux 系统上支持。</p>
<p>关于静态链接的更多信息可以在<a href="https://github.com/crystal-lang/crystal/wiki/Static-Linking">wiki</a> 找到。</p>
<a class="header" href="print.html#a生成一个项目或库" id="a生成一个项目或库"><h2>生成一个项目或库</h2></a>
<p>使用 <code>init</code> 命令来创建一个 标准目录结构的 Crystal 项目：</p>
<pre><code>$ crystal init lib my_cool_lib
      create  my_cool_lib/.gitignore
      create  my_cool_lib/.editorconfig
      create  my_cool_lib/LICENSE
      create  my_cool_lib/README.md
      create  my_cool_lib/.travis.yml
      create  my_cool_lib/shard.yml
      create  my_cool_lib/src/my_cool_lib.cr
      create  my_cool_lib/src/my_cool_lib/version.cr
      create  my_cool_lib/spec/spec_helper.cr
      create  my_cool_lib/spec/my_cool_lib_spec.cr
Initialized empty Git repository in ~/my_cool_lib/.git/
</code></pre>
<a class="header" href="print.html#a其他命令和选项" id="a其他命令和选项"><h2>其他命令和选项</h2></a>
<p>调用不带参数的 <code>crystal</code> 命令来查看所有的命令集。</p>
<pre><code>$ crystal
Usage: crystal [command] [switches] [program file] [--] [arguments]

Command:
    init                     generate a new project
    build                    build an executable
    deps                     install project dependencies
    docs                     generate documentation
    env                      print Crystal environment information
    eval                     eval code from args or standard input
    play                     starts crystal playground server
    run (default)            build and run program
    spec                     build and run specs (in spec directory)
    tool                     run a tool
    help, --help, -h         show this help
    version, --version, -v   show version
</code></pre>
<p>通过命令后跟 <code>--help</code> 选项来查看一个命令可用的选项：</p>
<pre><code>$ crystal build --help
Usage: crystal build [options] [programfile] [--] [arguments]

Options:
    --cross-compile                  cross-compile
    -d, --debug                      Add full symbolic debug info
    --no-debug                       Skip any symbolic debug info
    -D FLAG, --define FLAG           Define a compile-time flag
    --emit [asm|llvm-bc|llvm-ir|obj] Comma separated list of types of output for the compiler to emit
    -f text|json, --format text|json Output format text (default) or json
    --error-trace                    Show full error trace
    -h, --help                       Show this message
    --ll                             Dump ll to Crystal's cache directory
    --link-flags FLAGS               Additional flags to pass to the linker
    --mcpu CPU                       Target specific cpu type
    --mattr CPU                      Target specific features
    --no-color                       Disable colored output
    --no-codegen                     Don't do code generation
    -o                               Output filename
    --prelude                        Use given file as prelude
    --release                        Compile in release mode
    -s, --stats                      Enable statistics output
    -p, --progress                   Enable progress output
    -t, --time                       Enable execution time output
    --single-module                  Generate a single LLVM module
    --threads                        Maximum number of threads to use
    --target TRIPLE                  Target triple
    --verbose                        Display executed commands
    --static                         Link statically
    --stdin-filename                 Source file name to be read from STDIN
</code></pre>
<a class="header" href="print.html#a概览" id="a概览"><h1>概览</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/overview/README.md">overview/READM.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/c55247a364ee0c01fd8b1e3d78f2e1352faaa1ea">commit c55247a364ee0c01fd8b1e3d78f2e1352faaa1ea</a></p>
</blockquote>
<p>你可以从上到下阅读本章，但建议跳过这部分，因为一些相关概念无法单独解释。</p>
<p>在代码的例子中，注释 <code>#=&gt;</code> 用于显示表达式的值。例如：</p>
<pre><code class="language-crystal">a = 1 + 2
a #=&gt; 3
</code></pre>
<p>注释里使用 <code>:</code> 用于显示变量的类型。</p>
<pre><code class="language-crystal">s = &quot;hello&quot;
# s : String
</code></pre>
<p>让我们来从两个熟悉的例子开始学习这门语言。</p>
<a class="header" href="print.html#hello-world" id="hello-world"><h1>Hello World!</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/overview/hello_world.md">overview/hello_world.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0c157b7eaad13f191ddb73f148171f3579287279">commit 0c157b7eaad13f191ddb73f148171f3579287279</a></p>
</blockquote>
<p>经典的 “hello world” 程序在 Crystal 中看起来像这样：</p>
<pre><code class="language-crystal">puts &quot;Hello world!&quot;
</code></pre>
<p>从这里可以看出主要的过程是简单的，该程序无需定义一个 “main” 函数或其他类似的。</p>
<a class="header" href="print.html#http-服务器" id="http-服务器"><h1>HTTP 服务器</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/overview/http_server.md">overview/http_server.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/abc9abd90f69054c6bd0f20e4eaba3acbca7baf0">commit abc9abd90f69054c6bd0f20e4eaba3acbca7baf0</a></p>
</blockquote>
<p>一个更有意思的例子是 HTTP 服务器：</p>
<pre><code class="language-crystal">require &quot;http/server&quot;

server = HTTP::Server.new(8080) do |context|
  context.response.content_type = &quot;text/plain&quot;
  context.response.print &quot;Hello world! The time is #{Time.now}&quot;
end

puts &quot;Listening on http://127.0.0.1:8080&quot;
server.listen
</code></pre>
<p>当你阅读正个语言参考书的时候，上面的代码便可以理解了，但我们已经学习了一些东西。</p>
<ul>
<li>可以<a href="../syntax_and_semantics/requiring_files.html">导入</a>定义在其他文件中的代码：</li>
</ul>
<pre><code>```crystal
require &quot;http/server&quot;
```
</code></pre>
<ul>
<li>
<p>可以定义<a href="../syntax_and_semantics/local_variables.html">局部变量</a>而无需指定其类型：</p>
<pre><code class="language-crystal">server = HTTP::Server.new ...
</code></pre>
</li>
<li>
<p>通过在对象上调用<a href="../syntax_and_semantics/classes_and_methods.html">方法</a>或发送消息来编写代码。</p>
<pre><code class="language-crystal">HTTP::Server.new(8080) ...
...
Time.now
...
puts &quot;Listening on http://127.0.0.1:8080&quot;
...
server.listen
</code></pre>
</li>
<li>
<p>可以使用代码块或简化<a href="../syntax_and_semantics/blocks_and_procs.html">代码块</a>，其在重用代码或在实用的世界中得到一些特性时非常方便：</p>
<pre><code class="language-crystal">HTTP::Server.new(8080) do |context|
  ...
end
</code></pre>
</li>
<li>
<p>可以使用嵌入式内容比较容易地创建字符串，即所谓字符串插值。语言本身也自带了其他的语法以创建数组、哈希、范围、元组等等：</p>
<pre><code class="language-crystal">&quot;Hello world! The time is #{Time.now}&quot;
</code></pre>
</li>
</ul>
<a class="header" href="print.html#a语法和语义" id="a语法和语义"><h1>语法和语义</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/README.md">syntax_and_semantics/README.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/ed88f78fb944c2ec04d852cddd1cd656a26a82f6">commit ed88f78fb944c2ec04d852cddd1cd656a26a82f6</a></p>
</blockquote>
<p>程序源代码必须以 UTF-8 编码。</p>
<ul>
<li><a href="syntax_and_semantics/comments.html">注释</a></li>
<li><a href="syntax_and_semantics/literals.html">常量</a></li>
<li><a href="syntax_and_semantics/assignment.html">赋值</a></li>
<li><a href="syntax_and_semantics/local_variables.html">局部变量</a></li>
<li><a href="syntax_and_semantics/control_expressions.html">控制表达式</a></li>
<li><a href="syntax_and_semantics/requiring_files.html">导入文件</a></li>
<li><a href="syntax_and_semantics/types_and_methods.html">类型和方法</a></li>
<li><a href="syntax_and_semantics/exception_handling.html">异常处理</a></li>
<li><a href="syntax_and_semantics/type_grammar.html">类型语法</a></li>
<li><a href="syntax_and_semantics/type_reflection.html">类型反射</a></li>
<li><a href="syntax_and_semantics/macros.html">宏</a></li>
<li><a href="syntax_and_semantics/attributes.html">属性</a></li>
<li><a href="syntax_and_semantics/low_level_primitives.html">基本类型</a></li>
<li><a href="syntax_and_semantics/compile_time_flags.html">编译时标志</a></li>
<li><a href="syntax_and_semantics/c_bindings/">C 绑定</a></li>
<li><a href="syntax_and_semantics/unsafe.html">不安全代码</a></li>
</ul>
<a class="header" href="print.html#a注释" id="a注释"><h1>注释</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/comments.md">syntax_and_semantics/comments.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/8f956d166e100f7abc6bce9a1fbc8925ed7ed3ee">commit 8f956d166e100f7abc6bce9a1fbc8925ed7ed3ee</a></p>
</blockquote>
<p>注释以 <code>#</code> 字符开头，现在仅支持单行注释。</p>
<pre><code class="language-crystal"># This is a comment
</code></pre>
<a class="header" href="print.html#a常量" id="a常量"><h1>常量</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals.md">syntax_and_semantics/literals.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/979398f1828ee2dfb9023cbc3f860ac3569e2239">commit 979398f1828ee2dfb9023cbc3f860ac3569e2239</a></p>
</blockquote>
<p>Crystal 提供一些常量以创建部分基本类型的值。</p>
<table><thead><tr><th> 常量                                        </th><th> 示例                                    </th></tr></thead><tbody>
<tr><td> <a href="./literals/nil.html">Nil</a>                </td><td> <code>nil</code>                                 </td></tr>
<tr><td> <a href="./literals/bool.html">Bool</a>              </td><td> <code>true</code>, <code>false</code>                       </td></tr>
<tr><td> <a href="./literals/integers.html">Integers</a>      </td><td> <code>18</code>, <code>-12</code>, <code>19_i64</code>, <code>14_u32</code>,<code>64_u8</code> </td></tr>
<tr><td> <a href="./literals/floats.html">Floats</a>          </td><td> <code>1.0</code>, <code>1.0_f32</code>, <code>1e10</code>, <code>-0.5</code>      </td></tr>
<tr><td> <a href="./literals/char.html">Char</a>              </td><td> <code>'a'</code>, <code>'\n'</code>, <code>'あ'</code>                  </td></tr>
<tr><td> <a href="./literals/string.html">String</a>          </td><td> <code>&quot;foo\tbar&quot;</code>, <code>%(&quot;あ&quot;)</code>, <code>%q(foo #{foo})</code> </td></tr>
<tr><td> <a href="./literals/symbol.html">Symbol</a>          </td><td> <code>:symbol</code>, <code>:&quot;foo bar&quot;</code>               </td></tr>
<tr><td> <a href="./literals/array.html">Array</a>            </td><td> <code>[1, 2, 3]</code>, <code>[1, 2, 3] of Int32</code>, <code>%w(one two three)</code> </td></tr>
<tr><td> <a href="./literals/array.html#array-like-type-literal">Array-like</a>                  </td><td> <code>Set{1, 2, 3}</code>                        </td></tr>
<tr><td> <a href="./literals/hash.html">Hash</a>              </td><td> <code>{&quot;foo&quot; =&gt; 2}</code>, <code>{} of String =&gt; Int32</code> </td></tr>
<tr><td> <a href="./literals/hash.html#hash-like-type-literal">Hash-like</a>                    </td><td> <code>MyType{&quot;foo&quot; =&gt; &quot;bar&quot;}</code>              </td></tr>
<tr><td> <a href="./literals/range.html">Range</a>            </td><td> <code>1..9</code>, <code>1...10</code>, <code>0..var</code>            </td></tr>
<tr><td> <a href="./literals/regex.html">Regex</a>            </td><td> <code>/(foo)?bar/</code>, <code>/foo #{foo}/imx</code>, <code>%r(foo/)</code> </td></tr>
<tr><td> <a href="./literals/tuple.html">Tuple</a>            </td><td> <code>{1, &quot;hello&quot;, 'x'}</code>                   </td></tr>
<tr><td> <a href="./literals/named_tuple.html">NamedTuple</a> </td><td> <code>{name: &quot;Crystal&quot;, year: 2011}</code>, <code>{&quot;this is a key&quot;: 1}</code> </td></tr>
<tr><td> <a href="./literals/proc.html">Proc</a>              </td><td> <code>-&gt;(x : Int32, y : Int32) { x + y }</code>  </td></tr>
</tbody></table>
<a class="header" href="print.html#a空值nil" id="a空值nil"><h1>空值(Nil)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/nil.md">literals/nil.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/a9ed7ca3146241e2747bdf533ebfd8da5e6d8621">commit a9ed7ca3146241e2747bdf533ebfd8da5e6d8621</a></p>
</blockquote>
<p><a href="http://crystal-lang.org/api/Nil.html">空值(Nil)</a> 类型用于表示一个值的缺乏（ absence ），类似于其他语言中的 <code>null</code> 。它只有一个值：</p>
<pre><code class="language-crystal">nil
</code></pre>
<a class="header" href="print.html#a布尔bool" id="a布尔bool"><h1>布尔(Bool)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/bool.md">syntax_and_semantics/literals/bool.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/78d18cf29258956326c0989ff395b888b3a09d81">commit 78d18cf29258956326c0989ff395b888b3a09d81</a></p>
</blockquote>
<p><a href="http://crystal-lang.org/api/Bool.html">布尔(Bool)</a> 类型只有两个可能的值：<code>true</code> 和 <code>false</code> 。他们由下面的常量构成：</p>
<pre><code class="language-crystal">true  # A Bool that is true
false # A Bool that is false
</code></pre>
<a class="header" href="print.html#a整数integers" id="a整数integers"><h1>整数(Integers)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/integers.md">syntax_and_semantics/literals/integers.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/3543c1d2a27a2ceefdaade083be6dd32c78cc356">commit 3543c1d2a27a2ceefdaade083be6dd32c78cc356</a></p>
</blockquote>
<p>有四种有符号整数类型和四种无符号整数类型：</p>
<table><thead><tr><th>Type </th><th align="right"> Length  </th><th align="right"> Minimum Value </th><th align="right"> Maximum Value</th></tr></thead><tbody>
<tr><td><a href="http://crystal-lang.org/api/Int8.html">Int8</a>  </td><td align="right"> 8       </td><td align="right"> -128 </td><td align="right"> 127</td></tr>
<tr><td><a href="http://crystal-lang.org/api/Int16.html">Int16</a>  </td><td align="right"> 16 </td><td align="right"> −32,768 </td><td align="right"> 32,767</td></tr>
<tr><td><a href="http://crystal-lang.org/api/Int32.html">Int32</a> </td><td align="right"> 32  </td><td align="right"> −2,147,483,648 </td><td align="right"> 2,147,483,647</td></tr>
<tr><td><a href="http://crystal-lang.org/api/Int64.html">Int64</a>   </td><td align="right">  64 </td><td align="right"> −2<sup>63</sup> </td><td align="right"> 2<sup>63</sup> - 1</td></tr>
<tr><td><a href="http://crystal-lang.org/api/UInt8.html">UInt8</a> </td><td align="right"> 8 </td><td align="right">  0 </td><td align="right"> 255</td></tr>
<tr><td><a href="http://crystal-lang.org/api/UInt16.html">UInt16</a> </td><td align="right"> 16 </td><td align="right"> 0 </td><td align="right"> 65,535</td></tr>
<tr><td><a href="http://crystal-lang.org/api/UInt32.html">UInt32</a> </td><td align="right"> 32 </td><td align="right">  0 </td><td align="right"> 4,294,967,295</td></tr>
<tr><td><a href="http://crystal-lang.org/api/UInt64.html">UInt64</a> </td><td align="right"> 64 </td><td align="right"> 0 </td><td align="right"> 2<sup>64</sup> - 1</td></tr>
</tbody></table>
<p>一个整数常量由一个可选的 <code>+</code> 号或 <code>-</code> 号、一个数字序列或下划线和一个可选的后缀组成。若无后缀显示，则常量类型则是 <code>Int32</code> 、<code>Int64</code> 或 <code>UInt64</code> 中的最小值。其数字符合：</p>
<pre><code class="language-crystal">1      # Int32

1_i8   # Int8
1_i16  # Int16
1_i32  # Int32
1_i64  # Int64

1_u8   # UInt8
1_u16  # UInt16
1_u32  # UInt32
1_u64  # UInt64

+10    # Int32
-20    # Int32

2147483648          # Int64
9223372036854775808 # UInt64
</code></pre>
<p>后缀之前的下划线 <code>_</code> 是可选的。</p>
<p>下划线可以让一些数更可读：</p>
<pre><code class="language-crystal">1_000_000 # better than 1000000
</code></pre>
<p>二进制数以 <code>0b</code> 开头：</p>
<pre><code class="language-crystal">0b1101 # == 13
</code></pre>
<p>八进制数以 <code>0o</code> 开头：</p>
<pre><code class="language-crystal">0o123 # == 83
</code></pre>
<p>十六进制数以 <code>0x</code> 开头：</p>
<pre><code class="language-crystal">0xFE012D # == 16646445
0xfe012d # == 16646445
</code></pre>
<a class="header" href="print.html#a浮点数floats" id="a浮点数floats"><h1>浮点数(Floats)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/floats.md">syntax_and_semantics/literals/floats.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/78d18cf29258956326c0989ff395b888b3a09d81">commit 78d18cf29258956326c0989ff395b888b3a09d81</a></p>
</blockquote>
<p>浮点数有两种类型，<a href="http://crystal-lang.org/api/Float32.html">32位浮点数(Float32)</a> 和 <a href="http://crystal-lang.org/api/Float64.html">64位浮点数(Float64)</a>，但都相当于由IEEE定义的 <a href="http://en.wikipedia.org/wiki/Single_precision_floating-point_format">binary32</a> 和 <a href="http://en.wikipedia.org/wiki/Double_precision_floating-point_format">binary64</a> 。</p>
<p>一个浮点数常量由一个可选的 <code>+</code> 号或 <code>-</code> 号，一个数字序列或下划线，一个点号，数字或下划线，一个可选的指数后缀，一个可选的类型后缀组成。如果无后缀可以显示，该常量类型为 <code>Float64</code> 。</p>
<pre><code class="language-crystal">1.0      # Float64
1.0_f32  # Float32
1_f32    # Float32

1e10     # Float64
1.5e10   # Float64
1.5e-7   # Float64

+1.3     # Float64
-0.5     # Float64
</code></pre>
<p>后缀之前的下划线 <code>_</code> 是可选的。</p>
<p>下划线使一些数字更可读：</p>
<pre><code class="language-crystal">1_000_000.111_111 # a lot more readable than 1000000.111111, yet functionally the same
</code></pre>
<a class="header" href="print.html#a字符char" id="a字符char"><h1>字符(Char)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/char.md">syntax_and_semantics/literals/char.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/33885563f889c30d6dc8f6ed37af937ee48ef6de">commit 33885563f889c30d6dc8f6ed37af937ee48ef6de</a></p>
</blockquote>
<p>一个<a href="http://crystal-lang.org/api/Char.html">字符(Char)</a> 表示一个 32 位的 <a href="http://en.wikipedia.org/wiki/Unicode">Unicode</a> <a href="http://en.wikipedia.org/wiki/Code_point">码点(code point)</a> 。</p>
<p>通常用单引号括起来的 UTF-8 字符常量来创建字符。</p>
<pre><code class="language-crystal">'a'
'z'
'0'
'_'
'あ'
</code></pre>
<p>反斜杠(<code>\</code>) 表示一个特殊字符，它既可以表示转义序列，又可以表示一个 unicode 码点的数值。</p>
<p>可用的转义序列：</p>
<pre><code class="language-crystal">'\'' # single quote
'\\' # backslash
'\b' # backspace
'\e' # escape
'\f' # form feed
'\n' # newline
'\r' # carriage return
'\t' # tab
'\v' # vertical tab
'\uNNNN' # hexadecimal unicode character
'\u{NNNN...}' # hexadecimal unicode character
</code></pre>
<p>反斜杠后跟一个 <code>u</code> 表示一个 unicode 码点。其既可以后跟四位精确的十六进制字符以表示 unicode 字节（ <code>\u0000</code> 到 <code>\uFFFF</code> ）或跟由大括号包围一到六位十六进制字符来表示一个数。</p>
<pre><code class="language-crystal">'\u0041' # =&gt; 'A'
'\u{41}' # =&gt; 'A'
'\u{1F52E}' # =&gt; '&amp;#x1F52E;'
</code></pre>
<a class="header" href="print.html#a字符串string" id="a字符串string"><h1>字符串(String)</h1></a>
<p><a href="http://crystal-lang.org/api/String.html">字符串</a> 表示一个 UTF-8 字符的不可变序列。</p>
<p>字符串通常以双引号（ <code>&quot;</code> ）括起来的 UTF-8 字符串常量来创建。</p>
<pre><code class="language-crystal">&quot;hello world&quot;
</code></pre>
<a class="header" href="print.html#a转义" id="a转义"><h2>转义</h2></a>
<p>字符串中的反斜杠代表特殊字符，或是一个转义字符，或是一个 unicode 码点的数值表示。</p>
<p>可用的转义序列</p>
<pre><code class="language-crystal">&quot;\&quot;&quot; # double quote
&quot;\\&quot; # backslash
&quot;\b&quot; # backspace
&quot;\e&quot; # escape
&quot;\f&quot; # form feed
&quot;\n&quot; # newline
&quot;\r&quot; # carriage return
&quot;\t&quot; # tab
&quot;\v&quot; # vertical tab
&quot;\NNN&quot; # octal ASCII character
&quot;\xNN&quot; # hexadecimal ASCII character
&quot;\uNNNN&quot; # hexadecimal unicode character
&quot;\u{NNNN...}&quot; # hexadecimal unicode character
</code></pre>
<p>反斜杠后的任何其他字符都被解释为该字符自身。</p>
<p>反斜杠后跟至多三个数字表示八进制数的一个码点。</p>
<pre><code class="language-crystal">&quot;\101&quot; # =&gt; &quot;A&quot;
&quot;\123&quot; # =&gt; &quot;S&quot;
&quot;\12&quot;  # =&gt; &quot;\n&quot;
&quot;\1&quot;   # string with one character with code point 1
</code></pre>
<p>反斜杠后跟一个 <code>u</code> 表示一个 unicode 码点。其既可以明确地跟4位十六进制字符来表示 unicode 字节（ <code>\u0000</code> 到 <code>\uFFFF</code>）或由大括号包括的一到六位十六进制数的字符（ <code>\u{0} 到</code>\u{10FFF}`）表示的数。</p>
<pre><code class="language-crystal">&quot;\u0041&quot;    # =&gt; &quot;A&quot;
&quot;\u{41}&quot;    # =&gt; &quot;A&quot;
&quot;\u{1F52E}&quot; # =&gt; &quot;&amp;#x1F52E;&quot;
</code></pre>
<p>一个大括号可以包括多个由空格分开的多个 unicode 字符。</p>
<pre><code class="language-crystal">&quot;\u{48 45 4C 4C 4F}&quot; # =&gt; &quot;HELLO&quot;
</code></pre>
<a class="header" href="print.html#a插值" id="a插值"><h2>插值</h2></a>
<p>一个带有插值的字符串常量允许嵌入表达式到字符串中，其在运行时展开。</p>
<pre><code class="language-crystal">a = 1
b = 2
&quot;sum: #{a} + #{b} = #{a + b}&quot; # =&gt; &quot;sum: 1 + 2 = 3&quot;
</code></pre>
<p>String interpolation is also possible with <a href="https://crystal-lang.org/api/master/String.html#%25(other)-instance-method">String#%</a>.</p>
<p>Any expression may be placed inside the interpolated section, but it’s best to keep the expression small for readability.</p>
<p>Interpolation can be disabled by escaping the <code>#</code> character with a backslash or by using a non-interpolating string literal like <code>%q()</code>.</p>
<pre><code class="language-crystal">&quot;\#{a + b}&quot;  # =&gt; &quot;#{a + b}&quot;
%q(#{a + b}) # =&gt; &quot;#{a + b}&quot;
</code></pre>
<p>Interpolation is implemented using a <a href="http://crystal-lang.org/api/String/Builder.html">String::Builder</a> and invoking <code>Object#to_s(IO)</code> on each expression enclosed by <code>#{...}</code>. The expression <code>&quot;sum: #{a} + #{b} = #{a + b}&quot;</code> is equivalent to:</p>
<pre><code class="language-crystal">String.build do |io|
  io &lt;&lt; &quot;sum: &quot;
  io &lt;&lt; a
  io &lt;&lt; &quot; + &quot;
  io &lt;&lt; b
  io &lt;&lt; &quot; = &quot;
  io &lt;&lt; a + b
end
</code></pre>
<a class="header" href="print.html#percent-string-literals" id="percent-string-literals"><h1>Percent string literals</h1></a>
<p>Besides double-quotes strings, Crystal also supports string literals indicated by a percent sign (<code>%</code>) and a pair of delimiters. Valid delimiters are parenthesis <code>()</code>, square brackets <code>[]</code>, curly braces <code>{}</code>, angles <code>&lt;&gt;</code> and pipes <code>||</code>. Except for the pipes, all delimiters can be nested meaning a start delimiter inside the string escapes the next end delimiter.</p>
<p>These are handy to write strings that include double quotes which would have to be escaped in double-quoted strings.</p>
<pre><code class="language-crystal">%(hello (&quot;world&quot;)) # =&gt; &quot;hello (\&quot;world\&quot;)&quot;
%[hello [&quot;world&quot;]] # =&gt; &quot;hello [\&quot;world\&quot;]&quot;
%{hello {&quot;world&quot;}} # =&gt; &quot;hello {\&quot;world\&quot;}&quot;
%&lt;hello &lt;&quot;world&quot;&gt;&gt; # =&gt; &quot;hello &lt;\&quot;world\&quot;&gt;&quot;
%|hello &quot;world&quot;|   # =&gt; &quot;hello \&quot;world\&quot;&quot;
</code></pre>
<p>A literal denoted by <code>%q</code> does not apply interpolation nor escapes while <code>%Q</code> has the same meaning as <code>%</code>.</p>
<pre><code class="language-crystal">name = &quot;world&quot;
%q(hello \n #{name}) # =&gt; &quot;hello \\n \#{name}&quot;
%Q(hello \n #{name}) # =&gt; &quot;hello \n world&quot;
</code></pre>
<a class="header" href="print.html#multiline-strings" id="multiline-strings"><h2>Multiline strings</h2></a>
<p>Any string literal can span multiple lines:</p>
<pre><code class="language-crystal">&quot;hello
      world&quot; # =&gt; &quot;hello\n      world&quot;
</code></pre>
<p>Note that in the above example trailing and leading spaces, as well as newlines,
end up in the resulting string. To avoid this a string can be split into multiple lines
by joining multiple literals with a backslash:</p>
<pre><code class="language-crystal">&quot;hello &quot; \
&quot;world, &quot; \
&quot;no newlines&quot; # same as &quot;hello world, no newlines&quot;
</code></pre>
<p>Alternatively, a backslash followed by a newline can be inserted inside the string literal:</p>
<pre><code class="language-crystal">&quot;hello \
     world, \
     no newlines&quot; # same as &quot;hello world, no newlines&quot;
</code></pre>
<p>In this case, leading whitespace is not included in the resulting string.</p>
<a class="header" href="print.html#heredoc" id="heredoc"><h2>Heredoc</h2></a>
<p>A <em>here document</em> or <em>heredoc</em> can be useful for writing strings spanning over multiple lines.
A heredoc is denoted by <code>&lt;&lt;-</code> followed by an heredoc identifier which is an alphanumeric sequence starting with a letter (and may include underscores). The heredoc starts in the following line and ends with the next line that starts with the heredoc identifier (ignoring leading whitespace) and is either followed by a newline or a non-alphanumeric character.</p>
<pre><code class="language-crystal">&lt;&lt;-XML
&lt;parent&gt;
  &lt;child /&gt;
&lt;/parent&gt;
XML
</code></pre>
<p>Leading whitespace is removed from the heredoc contents according to the number of whitespace in the last line before the heredoc identifier.</p>
<pre><code class="language-crystal">&lt;&lt;-STRING
  Hello
    world
  STRING # =&gt; &quot;Hello\n  world&quot;

&lt;&lt;-STRING
    Hello
      world
  STRING # =&gt; &quot;  Hello\n    world&quot;
</code></pre>
<p>It is possible to directly call methods on heredoc string literals, or use them inside parentheses:</p>
<pre><code class="language-crystal">&lt;&lt;-SOME
hello
SOME.upcase # =&gt; &quot;HELLO&quot;

def upcase(string)
  string.upcase
end

upcase(&lt;&lt;-SOME
  hello
  SOME) # =&gt; &quot;HELLO&quot;
</code></pre>
<p>A heredoc generally allows interpolation and escapes.</p>
<p>To denote a heredoc without interpolation or escapes, the opening heredoc identifier is enclosed in single quotes:</p>
<pre><code class="language-crystal">&lt;&lt;-'HERE'
  hello \n #{world}
  HERE # =&gt; &quot;hello \n #{world}&quot;
</code></pre>
<a class="header" href="print.html#symbol" id="symbol"><h1>Symbol</h1></a>
<p>A <a href="http://crystal-lang.org/api/Symbol.html">Symbol</a> represents a unique name inside the entire source code.</p>
<p>Symbols are interpreted at compile time and cannot be created dynamically. The only way to create a Symbol is by using a symbol literal, denoted by a colon (<code>:</code>) followed by an identifier. The identifier may optionally be enclosed in double quotes (<code>&quot;</code>).</p>
<pre><code class="language-crystal">:unquoted_symbol
:&quot;quoted symbol&quot;
:&quot;a&quot; # identical to :a
</code></pre>
<p>A double-quoted identifier can contain any unicode character including white spaces and accepts the same escape sequences as a <a href="./string.html">string literal</a>, yet no interpolation.</p>
<p>For an unquoted identifier the same naming rules apply as for methods. It can contain alphanumeric characters, underscore (<code>_</code>) or characters with a code point greater than <code>159</code>(<code>0x9F</code>). It must not start with a number and may end with an exclamation mark (<code>!</code>) or question mark (<code>?</code>).</p>
<pre><code class="language-crystal">:question?
:exclamation!
</code></pre>
<p>All <a href="../operators.html">Crystal operators</a> can be used as symbol names unquoted:</p>
<pre><code class="language-crystal">:+
:-
:*
:/
:%
:&amp;
:|
:^
:**
:&gt;&gt;
:&lt;&lt;
:==
:!=
:&lt;
:&lt;=
:&gt;
:&gt;=
:&lt;=&gt;
:===
:[]
:[]?
:[]=
:!
:~
:!~
:=~
</code></pre>
<p>Internally, symbols are implemented as constants with a numeric value of type <code>Int32</code>.</p>
<a class="header" href="print.html#percent-symbol-array-literal" id="percent-symbol-array-literal"><h2>Percent symbol array literal</h2></a>
<p>Besides the single symbol literal, there is also a percent literal to create an <a href="https://crystal-lang.org/api/Array.html">Array</a> of symbols. It is indicated by <code>%i</code> and a pair of delimiters. Valid delimiters are parenthesis <code>()</code>, square brackets <code>[]</code>, curly braces <code>{}</code>, angles <code>&lt;&gt;</code> and pipes <code>||</code>. Except for the pipes, all delimiters can be nested meaning a start delimiter inside the string escapes the next end delimiter.</p>
<pre><code class="language-crystal">%i(foo bar baz) # =&gt; [:foo, :bar, :baz]
%i(foo\nbar baz) # =&gt; [:&quot;foo\nbar&quot;, :baz]
%i(foo(bar) baz) # =&gt; [:&quot;foo(bar)&quot;, :baz]
</code></pre>
<p>Identifiers may contain any unicode characters. Individual symbols are separated by a single space character (<code></code>) which must be escaped to use it as a part of an identifier.</p>
<pre><code class="language-crystal">%i(foo\ bar baz) # =&gt; [:&quot;foo bar&quot;, :baz]
</code></pre>
<a class="header" href="print.html#a数组array" id="a数组array"><h1>数组(Array)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/array.md">syntax_and_semantics/literals/array.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/5fbec9153525316d71c74de4e6d039d803466c1a">commit 5fbec9153525316d71c74de4e6d039d803466c1a</a></p>
</blockquote>
<p><a href="http://crystal-lang.org/api/Array.html">数组(Array)</a> 是一个以整数为索引的泛型有序集合，其元素为一个指定类型 <code>T</code> 。</p>
<p>数组通常用一个以方括号（ <code>[]</code> ）表示的数组常量创建，其不同元素以逗号（ <code>,</code> ）分开。</p>
<pre><code class="language-crystal">[1, 2, 3]
</code></pre>
<a class="header" href="print.html#a泛型类型参数" id="a泛型类型参数"><h2>泛型类型参数</h2></a>
<p>数组的泛型类型参数 <code>T</code> 是指内部常量元素的类型。当数组的所有元素类型都相同时，<code>T</code> 为该类型。否则 <code>T</code> 则是所有元素类型的并集。</p>
<pre><code class="language-crystal">[1, 2, 3]          # =&gt; Array(Int32)
[1, &quot;hello&quot;, 'x']  # =&gt; Array(Int32 | String | Char)
</code></pre>
<p>可以直接使用闭括号后跟 <code>of</code> 和类型来指定一个明确的类型，每一部分都用空格隔开。这样便覆盖了类型推断，例如，可以创建一个拥有一些初始类型的数组，但之后能够接收其他的类型。</p>
<pre><code class="language-crystal">array_of_numbers = [1, 2, 3] of Number  # =&gt; Array(Number)
array_of_numbers + [0.5]                # =&gt; [1, 2, 3, 0.5]

array_of_int_or_string = [1, 3, 4] of Int32 | String  # =&gt; Array(Int32 | String)
array_of_int_or_string + [&quot;foo&quot;]                      # =&gt; [1, 2, 3, &quot;foo&quot;]
</code></pre>
<p>空数组常量需要一个指定的类型：</p>
<pre><code class="language-crystal">[] of Int32  # =&gt; Array(Int32).new
</code></pre>
<a class="header" href="print.html#a部分数组常量percent-array-literals" id="a部分数组常量percent-array-literals"><h2>部分数组常量(percent array literals)</h2></a>
<p>[字符串数组](./string.html#Percent String Array Literal) 以及[符号数组](./symbol.html#Percent Symbol Array Literal) 可以使用部分数组常量来创建</p>
<pre><code class="language-crystal">%w(one two three)  # =&gt; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;]
%i(one two three)  # =&gt; [:one, :two, :three]
</code></pre>
<a class="header" href="print.html#a类数组类型常量" id="a类数组类型常量"><h2>类数组类型常量</h2></a>
<p>Crystal 支持 另一中数组和类数组类型的常量。其包含类型名，后跟由大括号 <code>{}</code> 包括的元素列表，同时各个元素以 (<code>,</code>) 分开。</p>
<pre><code class="language-crystal">Array{1, 2, 3}
</code></pre>
<p>该常量可以用于任何类型，只要其有一个空参构造函数以及对 <code>&lt;&lt;</code> 的反应。</p>
<pre><code class="language-crystal">IO::Memory{1, 2, 3}
Set{1, 2, 3}
</code></pre>
<p>对于一个像 <code>IO::Memory</code> 这样的非泛型类型来说，这等于：</p>
<pre><code class="language-crystal">array_like = IO::Memory.new
array_like &lt;&lt; 1
array_like &lt;&lt; 2
array_like &lt;&lt; 3
</code></pre>
<p>对于一个像 <code>Set</code> 这样的泛型来说，泛型 <code>T</code> 的类型可以像数组一样从元素的类型上推断出来。上面的代码等价于：</p>
<pre><code class="language-crystal">array_like = Set(typeof(1, 2, 3)).new
array_like &lt;&lt; 1
array_like &lt;&lt; 2
array_like &lt;&lt; 3
</code></pre>
<p>可以用部分类型名来明确地指定类型参数。</p>
<pre><code class="language-crystal">Set(Number) {1, 2, 3}
</code></pre>
<a class="header" href="print.html#a哈希hash" id="a哈希hash"><h1>哈希(Hash)</h1></a>
<p><a href="http://crystal-lang.org/api/Hash.html">哈希(Hash)</a> 是一个将 <code>K</code> 型值映射到 <code>V</code> 型值的键值对（ key-value pairs ）的泛型集合。</p>
<p>Hashes are typically created with a hash literal denoted by curly braces (<code>{ }</code>) enclosing a list of pairs using <code>=&gt;</code> as delimiter between key and value and separated by commas <code>,</code>.</p>
<pre><code class="language-crystal">{&quot;one&quot; =&gt; 1, &quot;two&quot; =&gt; 2}
</code></pre>
<a class="header" href="print.html#generic-type-argument" id="generic-type-argument"><h1>Generic Type Argument</h1></a>
<p>The generic type arguments for keys <code>K</code> and values <code>V</code> are inferred from the types of the keys or values inside the literal, respectively. When all have the same type, <code>K</code>/<code>V</code> equals to that. Otherwise it will be a union of all key types or value types respectively.</p>
<pre><code class="language-crystal">{1 =&gt; 2, 3 =&gt; 4}     # Hash(Int32, Int32)
{1 =&gt; 2, 'a' =&gt; 3}   # Hash(Int32 | Char, Int32)
</code></pre>
<p>Explicit types can be specified by immediately following the closing bracket with <code>of</code> (separated by whitespace), a key type (<code>K</code>) followed by <code>=&gt;</code> as delimiter and a value type (<code>V</code>). This overwrites the inferred types and can be used for example to create a hash that holds only some types initially but can accept other types as well.</p>
<p>Empty hash literals always need type specifications:</p>
<pre><code class="language-crystal">{} of Int32 =&gt; Int32 # =&gt; Hash(Int32, Int32).new
</code></pre>
<a class="header" href="print.html#hash-like-type-literal" id="hash-like-type-literal"><h2>Hash-like Type Literal</h2></a>
<p>Crystal supports an additional literal for hashes and hash-like types. It consists of the name of the type followed by a list of  comma separated key-value pairs enclosed in curly braces (<code>{}</code>).</p>
<pre><code class="language-crystal">Hash{&quot;one&quot; =&gt; 1, &quot;two&quot; =&gt; 2}
</code></pre>
<p>This literal can be used with any type as long as it has an argless constructor and responds to <code>[]=</code>.</p>
<pre><code class="language-crystal">HTTP::Headers{&quot;foo&quot; =&gt; &quot;bar&quot;}
</code></pre>
<p>For a non-generic type like <code>HTTP::Headers</code>, this is equivalent to:</p>
<pre><code class="language-crystal">headers = HTTP::Headers.new
headers[&quot;foo&quot;] = &quot;bar&quot;
</code></pre>
<p>For a generic type, the generic types are inferred from the types of the keys and values in the same way as with the hash literal.</p>
<pre><code class="language-crystal">MyHash{&quot;foo&quot; =&gt; 1, &quot;bar&quot; =&gt; &quot;baz&quot;}
</code></pre>
<p>If <code>MyHash</code> is generic, the above is equivalent to this:</p>
<pre><code class="language-crystal">my_hash = MyHash(typeof(&quot;foo&quot;, &quot;bar&quot;), typeof(1, &quot;baz&quot;)).new
my_hash[&quot;foo&quot;] = 1
my_hash[&quot;bar&quot;] = baz
</code></pre>
<p>The type arguments can be explicitly specified as part of the type name:</p>
<pre><code class="language-crystal">MyHash(String, String | Int32) {&quot;foo&quot; =&gt; &quot;bar&quot;}
</code></pre>
<a class="header" href="print.html#a范围range" id="a范围range"><h1>范围(Range)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/range.md">syntax_and_semantics/literals/range.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0c157b7eaad13f191ddb73f148171f3579287279">commit 0c157b7eaad13f191ddb73f148171f3579287279</a></p>
</blockquote>
<p><a href="http://crystal-lang.org/api/Range.html">范围(Range)</a>通常由范围字面量构成：</p>
<pre><code class="language-crystal">x..y  # an inclusive range, in mathematics: [x, y]
x...y # an exclusive range, in mathematics: [x, y)
</code></pre>
<p>方便记住一边包含而另一边不包含的方法是：想下这个额外的点，貌似它把 <em>y</em> 放的更远，因而出了范围的边界。</p>
<a class="header" href="print.html#a正则regex" id="a正则regex"><h1>正则(Regex)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/regex.md">syntax_and_semantics/literals/regex.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0c157b7eaad13f191ddb73f148171f3579287279">commit 0c157b7eaad13f191ddb73f148171f3579287279</a></p>
</blockquote>
<p>正则(Regular) 表达式由 <a href="http://crystal-lang.org/api/Regex.html">Regex</a> 类来表示，其通常用一个字面量来创建：</p>
<pre><code class="language-crystal">foo_or_bar = /foo|bar/
heeello    = /h(e+)llo/
integer    = /\d+/
</code></pre>
<p>正则表达式字面量由 <code>/</code> 来限定，且使用 <a href="http://pcre.org/pcre.txt">PCRE</a> 语法。</p>
<p>正则之后可跟这些修饰词：</p>
<ul>
<li>i: ignore case (PCRE_CASELESS)</li>
<li>m: multiline (PCRE_MULTILINE)</li>
<li>x: extended (PCRE_EXTENDED)</li>
</ul>
<p>例如</p>
<pre><code class="language-crystal">r = /foo/imx
</code></pre>
<p>斜杠必须转义：</p>
<pre><code class="language-crystal">slash = /\//
</code></pre>
<p>也有另一种语法：</p>
<pre><code class="language-crystal">r = %r(regex with slash: /)
</code></pre>
<a class="header" href="print.html#a元组tuple" id="a元组tuple"><h1>元组(Tuple)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/tuple.md">syntax_and_semantics/literals/tuple.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/78d18cf29258956326c0989ff395b888b3a09d81">commit 78d18cf29258956326c0989ff395b888b3a09d81</a></p>
</blockquote>
<p><a href="http://crystal-lang.org/api/Tuple.html">元组(Tuple)</a> 通常以元组常量来创建：</p>
<pre><code class="language-crystal">tuple = {1, &quot;hello&quot;, 'x'} # Tuple(Int32, String, Char)
tuple[0]                  #=&gt; 1       (Int32)
tuple[1]                  #=&gt; &quot;hello&quot; (String)
tuple[2]                  #=&gt; 'x'     (Char)
</code></pre>
<p>可以使用 <a href="http://crystal-lang.org/api/Tuple.html#new%28%2Aargs%29-class-method">Tuple.new</a> 来创建一个空元组。</p>
<p>可以这样描述一个元组</p>
<pre><code class="language-crystal"># The type denoting a tuple of Int32, String and Char
Tuple(Int32, String, Char)
</code></pre>
<p>在类型约束中，泛型参数以及其他需要一个参数的地方，可以像<a href="../type_grammar.html">类型语法</a>中描述的那样使用简化语法：</p>
<pre><code class="language-crystal"># An array of tuples of Int32, String and Char
Array({Int32, String, Char})
</code></pre>
<a class="header" href="print.html#a具名元组namedtuple" id="a具名元组namedtuple"><h1>具名元组(NamedTuple)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/named_tuple.md">syntax_and_semantics/literals/named_tuple.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/78d18cf29258956326c0989ff395b888b3a09d81">commit 78d18cf29258956326c0989ff395b888b3a09d81</a></p>
</blockquote>
<p><a href="http://crystal-lang.org/api/NamedTuple.html">具名元组(NamedTuple)</a> 通常用一个具有名字的元组字面量来创建：:</p>
<pre><code class="language-crystal">tuple = {name: &quot;Crystal&quot;, year: 2011} # NamedTuple(name: String, year: Int32)
tuple[:name] # =&gt; &quot;Crystal&quot; (String)
tuple[:year] # =&gt; 2011      (Int32)
</code></pre>
<p>可以这样来表示一个具名元组的类型：</p>
<pre><code class="language-crystal"># The type denoting a named tuple of x: Int32, y: String
NamedTuple(x: Int32, y: String)
</code></pre>
<p>类型约束中，在泛型类型参数以及其他需要类型的地方，可以像在<a href="../type_grammar.html">类型语法</a>中解释的那样使用简化语法：</p>
<pre><code class="language-crystal"># An array of named tuples of x: Int32, y: String
Array({x: Int32, y: String})
</code></pre>
<p>具名元组的 key 也可以是一个字符串：</p>
<pre><code class="language-crystal">{&quot;this is a key&quot;: 1}
</code></pre>
<a class="header" href="print.html#a过程proc" id="a过程proc"><h1>过程(Proc)</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/literals/proc.md">syntax_and_semantics/literals/proc.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/c0a0c628f4f2c7c9c57c4034834ddc45bbd7d7e4">commit c0a0c628f4f2c7c9c57c4034834ddc45bbd7d7e4</a></p>
</blockquote>
<p><a href="http://crystal-lang.org/api/Proc.html">过程(Proc)</a> 表示一个可携带内容（闭包数据）函数指针。其通常用一个过程常量来创建：</p>
<pre><code class="language-crystal"># A proc without arguments
-&gt;{ 1 } # Proc(Int32)

# A proc with one argument
-&gt;(x : Int32) { x.to_s } # Proc(Int32, String)

# A proc with two arguments:
-&gt;(x : Int32, y : Int32) { x + y } # Proc(Int32, Int32, Int32)
</code></pre>
<p>参数类型是必不可少的，除非将一个过程常量发送给 C 绑定中一个库 <code>fun</code> 。</p>
<p>返回值类型可以从过程体中推断。</p>
<p>同时也提供特定的 <code>new</code> 方法：</p>
<pre><code class="language-crystal">Proc(Int32, String).new { |x| x.to_s } # Proc(Int32, String)
</code></pre>
<p>这种格式可以让你指定返回值类型以反过来检测过程体。</p>
<a class="header" href="print.html#a过程类型" id="a过程类型"><h2>过程类型</h2></a>
<p>可以和这样表示一个过程类型：</p>
<pre><code class="language-crystal"># A Proc accepting a single Int32 argument and returning a String
Proc(Int32, String)

# A proc accepting no arguments and returning Void
Proc(Void)

# A proc accepting two arguments (one Int32 and one String) and returning a Char
Proc(Int32, String, Char)
</code></pre>
<p>在类型限制中，泛型类型参数以及其他需要参数的地方，可以像在<a href="../type_grammar.html">类型(type)</a>中解释的那样使用简化语法：</p>
<pre><code class="language-crystal"># An array of Proc(Int32, String, Char)
Array(Int32, String -&gt; Char)
</code></pre>
<a class="header" href="print.html#a调用" id="a调用"><h2>调用</h2></a>
<p>为调用过程，可以在过程之上调用 <code>call</code> 方法。参数个数与类型必须和过程的参数个数和类型相匹配：</p>
<pre><code class="language-crystal">proc = -&gt;(x : Int32, y : Int32) { x + y }
proc.call(1, 2) #=&gt; 3
</code></pre>
<a class="header" href="print.html#a从方法中创建过程" id="a从方法中创建过程"><h2>从方法中创建过程</h2></a>
<p>可以从一个已存在的方法中创建过程：</p>
<pre><code class="language-crystal">def one
  1
end

proc = -&gt;one
proc.call #=&gt; 1
</code></pre>
<p>如果该方法有参数，则需要指定其类型：</p>
<pre><code class="language-crystal">def plus_one(x)
  x + 1
end

proc = -&gt;plus_one(Int32)
proc.call(41) #=&gt; 42
</code></pre>
<p>过程也可以指定一个接收者：</p>
<pre><code class="language-crystal">str = &quot;hello&quot;
proc = -&gt;str.count(Char)
proc.call('e') #=&gt; 1
proc.call('l') #=&gt; 2
</code></pre>
<a class="header" href="print.html#a赋值" id="a赋值"><h1>赋值</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/assignment.md">syntax_and_semantics/assignment.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/bc665fe1a4c144c464fdd5002ce3848e882ffdee">commit bc665fe1a4c144c464fdd5002ce3848e882ffdee</a></p>
</blockquote>
<p>赋值以等号字符（ <code>=</code> ）来执行。</p>
<pre><code class="language-crystal"># Assigns to a local variable
local = 1

# Assigns to an instance variable
@instance = 2

# Assigns to a class variable
@@class = 3
</code></pre>
<p>随后会解释上面每一种变量类型。</p>
<p>一些包含 <code>=</code> 符号的可用语法糖：</p>
<pre><code class="language-crystal">local += 1  # same as: local = local + 1

# The above is valid with these operators:
# +, -, *, /, %, |, &amp;, ^, **, &lt;&lt;, &gt;&gt;

local ||= 1 # same as: local || (local = 1)
local &amp;&amp;= 1 # same as: local &amp;&amp; (local = 1)
</code></pre>
<p>以 <code>=</code> 结尾的函数调用语法糖：</p>
<pre><code class="language-crystal"># A setter
person.name=(&quot;John&quot;)

# The above can be written as:
person.name = &quot;John&quot;

# An indexed assignment
objects.[]=(2, 3)

# The above can be written as:
objects[2] = 3

# Not assignment-related, but also syntax sugar:
objects.[](2, 3)

# The above can be written as:
objects[2, 3]
</code></pre>
<p><code>=</code> 操作符也可用于 setter 和 indexer 之上。注意 <code>||</code> 和 <code>&amp;&amp;</code> 使用 <code>[]?</code> 方法来检测键的存在性。</p>
<pre><code class="language-crystal">person.age += 1        # same as: person.age = person.age + 1

person.name ||= &quot;John&quot; # same as: person.name || (person.name = &quot;John&quot;)
person.name &amp;&amp;= &quot;John&quot; # same as: person.name &amp;&amp; (person.name = &quot;John&quot;)

objects[1] += 2        # same as: objects[1] = objects[1] + 2

objects[1] ||= 2       # same as: objects[1]? || (objects[1] = 2)
objects[1] &amp;&amp;= 2       # same as: objects[1]? &amp;&amp; (objects[1] = 2)
</code></pre>
<a class="header" href="print.html#multiple-assignment" id="multiple-assignment"><h1>Multiple assignment</h1></a>
<p>You can declare/assign multiple variables at the same time by separating expressions with a comma (<code>,</code>):</p>
<pre><code class="language-crystal">name, age = &quot;Crystal&quot;, 1

# The above is the same as this:
temp1 = &quot;Crystal&quot;
temp2 = 1
name  = temp1
age   = temp2
</code></pre>
<p>Note that because expressions are assigned to temporary variables it is possible to exchange variables’ contents in a single line:</p>
<pre><code class="language-crystal">a = 1
b = 2
a, b = b, a
a #=&gt; 2
b #=&gt; 1
</code></pre>
<p>If the right-hand side contains just one expression, it is considered an indexed type and the following syntax sugar applies:</p>
<pre><code class="language-crystal">name, age, source = &quot;Crystal,1,github&quot;.split(&quot;,&quot;)

# The above is the same as this:
temp = &quot;Crystal,1,github&quot;.split(&quot;,&quot;)
name   = temp[0]
age    = temp[1]
source = temp[2]
</code></pre>
<p>Multiple assignment is also available to methods that end with <code>=</code>:</p>
<pre><code class="language-crystal">person.name, person.age = &quot;John&quot;, 32

# Same as:
temp1 = &quot;John&quot;
temp2 = 32
person.name = temp1
person.age = temp2
</code></pre>
<p>And it is also available to indexers (<code>[]=</code>):</p>
<pre><code class="language-crystal">objects[1], objects[2] = 3, 4

# Same as:
temp1 = 3
temp2 = 4
objects[1] = temp1
objects[2] = temp2
</code></pre>
<a class="header" href="print.html#a局部变量" id="a局部变量"><h1>局部变量</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/local_variables.md">syntax_and_semantics/local_variables.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/1142db80f9452eacce300afd64a846c91ca5cd2f">commit 1142db80f9452eacce300afd64a846c91ca5cd2f</a></p>
</blockquote>
<p>局部变量以小写字符开始。其以初次赋值变量来声明。</p>
<pre><code class="language-crystal">name = &quot;Crystal&quot;
age = 1
</code></pre>
<p>其类型从他们的用法中推断，而不是其初始化变量。通常，局部变量只保留程序员所期望根据其在程序中的位置和用法的类型有关的值。</p>
<p>例如，以一个不同的表达式重新赋值让其变成表达式的类型：</p>
<pre><code class="language-crystal">flower = &quot;Tulip&quot;
# At this point 'flower' is a String

flower = 1
# At this point 'flower' is an Int32
</code></pre>
<p>可在变量名前面使用下划线，但这些名字是编译器所保留的，因此，并不建议这样使用（而且这样做让程序更加难读）。</p>
<a class="header" href="print.html#a控制表达式" id="a控制表达式"><h1>控制表达式</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/control_expressions.md">syntax_and_semantics/control_expressions.md</a>
<a href="https://github.com/crystal-lang/crystal-book/commit/ed6c72b7a419f85d42a6bc35d555d2d563997261">commit ed6c72b7a419f85d42a6bc35d555d2d563997261</a></p>
</blockquote>
<p>在讨论控制表达式之前，我们需要了解什么是<em>真值</em>和<em>假值</em>。</p>
<a class="header" href="print.html#a真值和假值" id="a真值和假值"><h1>真值和假值</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/truthy_and_falsey_values.md">syntax_and_semantics/truthy_and_falsey_values.md</a>
<a href="https://github.com/crystal-lang/crystal-book/commit/eaf677bbbfb97952961d0b77d48c69f0ef741e7c">commit eaf677bbbfb97952961d0b77d48c69f0ef741e7c</a></p>
</blockquote>
<p>对于一个 <code>if</code> 、<code>unless</code> 、 <code>while</code> 或 <code>until</code> 的标记符号来说，<em>真</em>值被认为是一个真的值。<em>假</em>值在这些地方被认为是假的值。</p>
<p>唯一的假值是 <code>nil</code> ，<code>false</code> 和空指针（指针的内存地址为0）。其他的值都是真值。</p>
<a class="header" href="print.html#if" id="if"><h1>if</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/if.md">syntax_and_semantics/if.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/d9e62d44ba404aa389ffc81b32a547207a0ab68e">commit d9e62d44ba404aa389ffc81b32a547207a0ab68e</a></p>
</blockquote>
<p><code>if</code> 计算给定 if 分支如果其条件为<code>真</code>。否则，计算 <code>else</code> 分支。</p>
<pre><code class="language-crystal">a = 1
if a &gt; 0
  a = 10
end
a #=&gt; 10

b = 1
if b &gt; 2
  b = 10
else
  b = 20
end
b #=&gt; 20
</code></pre>
<p>可以用 <code>elsif</code> 来写一个 if-else-if 链：</p>
<pre><code class="language-crystal">if some_condition
  do_something
elsif some_other_condition
  do_something_else
else
  do_that
end
</code></pre>
<p>在 <code>if</code> 之后，变量的类型依赖于在两个分支中使用的表达式的类型。</p>
<pre><code class="language-crystal">a = 1
if some_condition
  a = &quot;hello&quot;
else
  a = true
end
# a : String | Bool

b = 1
if some_condition
  b = &quot;hello&quot;
end
# b : Int32 | String

if some_condition
  c = 1
else
  c = &quot;hello&quot;
end
# c : Int32 | String

if some_condition
  d = 1
end
# d : Int32 | Nil
</code></pre>
<p>注意如果在其中一个分支内声明变量而没有在另一个分支内声明，那么在 <code>if</code> 结尾该变量也会包含 <code>Nil</code> 类型。</p>
<p>在一个 <code>if</code> 分支的内部，变量的类型从在该分支之内的赋值之中获取，如果没有重新赋值的话，则是在该分支之前的赋值之中获取。</p>
<pre><code class="language-crystal">a = 1
if some_condition
  a = &quot;hello&quot;
  # a : String
  a.size
end
# a : String | Int32
</code></pre>
<p>也就是说，变量的类型是最后一个赋值给变量的表达式的类型。</p>
<p>如果直到 <code>if</code> 的结尾其中一个分支从不会到达，像在一个 <code>return</code> 、<code>next</code> 、<code>break</code> 或 <code>raise</code> 的例子中，则在 <code>if</code> 结尾并不再考虑该变量类型：</p>
<pre><code class="language-crystal">if some_condition
  e = 1
else
  e = &quot;hello&quot;
  # e : String
  return
end
# e : Int32
</code></pre>
<a class="header" href="print.html#a用作后缀" id="a用作后缀"><h1>用作后缀</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/as_a_suffix.md">syntax_and_semantics/as_a_suffix.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0c157b7eaad13f191ddb73f148171f3579287279">commit 0c157b7eaad13f191ddb73f148171f3579287279</a></p>
</blockquote>
<p><code>if</code> 可以写在一个表达式的后缀之上：</p>
<pre><code class="language-crystal">a = 2 if some_condition

# The above is the same as:
if some_condition
  a = 2
end
</code></pre>
<p>这有时候让代码读起来更自然。</p>
<a class="header" href="print.html#a用作表达式" id="a用作表达式"><h1>用作表达式</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/as_an_expression.md">syntax_and_semantics/as_an_expression.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0c157b7eaad13f191ddb73f148171f3579287279">commit 0c157b7eaad13f191ddb73f148171f3579287279</a></p>
</blockquote>
<p>一个 <code>if</code> 的值是其每个分支最后一个表达式的值。</p>
<pre><code class="language-crystal">a = if 2 &gt; 1
      3
    else
      4
    end
a #=&gt; 3
</code></pre>
<p>如果一个 <code>if</code> 分支是空的，或者缺失，则认为其有一个 <code>nil</code> 值。</p>
<pre><code class="language-crystal">if 1 &gt; 2
  3
end

# The above is the same as:
if 1 &gt; 2
  3
else
  nil
end

# Another example:
if 1 &gt; 2
else
  3
end

# The above is the same as:
if 1 &gt; 2
  nil
else
  3
end
</code></pre>
<a class="header" href="print.html#a三元-if" id="a三元-if"><h1>三元 if</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/ternary_if.md">syntax_and_semantics/ternary_if.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0c157b7eaad13f191ddb73f148171f3579287279">commit 0c157b7eaad13f191ddb73f148171f3579287279</a></p>
</blockquote>
<p>三元 <code>if</code> 可以以更简短的方式写 <code>if</code> 语句：</p>
<pre><code class="language-crystal">a = 1 &gt; 2 ? 3 : 4

# The above is the same as:
a = if 1 &gt; 2
      3
    else
      4
    end
</code></pre>
<a class="header" href="print.html#if-var" id="if-var"><h1>if var</h1></a>
<p>If a variable is the condition of an <code>if</code>, inside the <code>then</code> branch the variable will be considered as not having the <code>Nil</code> type:</p>
<pre><code class="language-crystal">a = some_condition ? nil : 3
# a is Int32 or Nil

if a
  # Since the only way to get here is if a is truthy,
  # a can't be nil. So here a is Int32.
  a.abs
end
</code></pre>
<p>This also applies when a variable is assigned in an <code>if</code>'s condition:</p>
<pre><code class="language-crystal">if a = some_expression
  # here a is not nil
end
</code></pre>
<p>This logic also applies if there are ands (<code>&amp;&amp;</code>) in the condition:</p>
<pre><code class="language-crystal">if a &amp;&amp; b
  # here both a and b are guaranteed not to be Nil
end
</code></pre>
<p>Here, the right-hand side of the <code>&amp;&amp;</code> expression is also guaranteed to have <code>a</code> as not <code>Nil</code>.</p>
<p>Of course, reassigning a variable inside the <code>then</code> branch makes that variable have a new type based on the expression assigned.</p>
<a class="header" href="print.html#limitations" id="limitations"><h2>Limitations</h2></a>
<p>The above logic <strong>doesn’t</strong> work with instance variables, class variables and variables bound in a closure. The value of these kinds of variables could potentially be affected by another fiber after the condition was checked, rendering it <code>nil</code>.</p>
<pre><code class="language-crystal">if @a
  # here `@a` can be nil
end

if @@a
  # here `@@a` can be nil
end

a = nil
closure = -&gt;(){ foo = &quot;foo&quot; }

if a
  # here `a` can be nil
end
</code></pre>
<p>This can be circumvented by assigning the value to a new local variable:</p>
<pre><code class="language-crystal">if a = @a
  # here `a` can't be nil
end
</code></pre>
<p>Another option is to use <a href="https://crystal-lang.org/api/Object.html#try%28%26block%29-instance-method"><code>Object#try</code></a> found in the standard library which only executes the block if the value is not <code>nil</code>:</p>
<pre><code class="language-crystal">@a.try do |a|
  # here `a` can't be nil
end
</code></pre>
<a class="header" href="print.html#method-calls" id="method-calls"><h2>Method calls</h2></a>
<p>That logic also doesn't work with proc and method calls, including getters and properties, because nilable (or, more generally, union-typed) procs and methods aren't guaranteed to return the same more-specific type on two successive calls.</p>
<pre><code class="language-crystal">if method # first call to a method that can return Int32 or Nil
          # here we know that the first call did not return Nil
  method  # second call can still return Int32 or Nil
end
</code></pre>
<p>The techniques described above for instance variables will also work for proc and method calls.</p>
<a class="header" href="print.html#if-varis_a" id="if-varis_a"><h1>if var.is_a?(...)</h1></a>
<p>If an <code>if</code>'s condition is an <code>is_a?</code> test, the type of a variable is guaranteed to be restricted by that type in the <code>then</code> branch.</p>
<pre><code class="language-crystal">if a.is_a?(String)
  # here a is a String
end

if b.is_a?(Number)
  # here b is a Number
end
</code></pre>
<p>Additionally, in the <code>else</code> branch the type of the variable is guaranteed to not be restricted by that type:</p>
<pre><code class="language-crystal">a = some_condition ? 1 : &quot;hello&quot;
# a : Int32 | String

if a.is_a?(Number)
  # a : Int32
else
  # a : String
end
</code></pre>
<p>Note that you can use any type as an <code>is_a?</code> test, like abstract classes and modules.</p>
<p>The above also works if there are ands (<code>&amp;&amp;</code>) in the condition:</p>
<pre><code class="language-crystal">if a.is_a?(String) &amp;&amp; b.is_a?(Number)
  # here a is a String and b is a Number
end
</code></pre>
<p>The above <strong>doesn’t</strong> work with instance variables or class variables. To work with these, first assign them to a variable:</p>
<pre><code class="language-crystal">if @a.is_a?(String)
  # here @a is not guaranteed to be a String
end

a = @a
if a.is_a?(String)
  # here a is guaranteed to be a String
end

# A bit shorter:
if (a = @a).is_a?(String)
  # here a is guaranteed to be a String
end
</code></pre>
<a class="header" href="print.html#if-varresponds_to" id="if-varresponds_to"><h1>if var.responds_to?(...)</h1></a>
<p>If an <code>if</code>'s condition is a <code>responds_to?</code> test, in the <code>then</code> branch the type of a variable is guaranteed to be restricted to the types that respond to that method:</p>
<pre><code class="language-crystal">if a.responds_to?(:abs)
  # here a's type will be reduced to those responding to the 'abs' method
end
</code></pre>
<p>Additionally, in the <code>else</code> branch the type of the variable is guaranteed to be restricted to the types that don’t respond to that method:</p>
<pre><code class="language-crystal">a = some_condition ? 1 : &quot;hello&quot;
# a : Int32 | String

if a.responds_to?(:abs)
  # here a will be Int32, since Int32#abs exists but String#abs doesn't
else
  # here a will be String
end
</code></pre>
<p>The above <strong>doesn’t</strong> work with instance variables or class variables. To work with these, first assign them to a variable:</p>
<pre><code class="language-crystal">if @a.responds_to?(:abs)
  # here @a is not guaranteed to respond to `abs`
end

a = @a
if a.responds_to?(:abs)
  # here a is guaranteed to respond to `abs`
end

# A bit shorter:
if (a = @a).responds_to?(:abs)
  # here a is guaranteed to respond to `abs`
end
</code></pre>
<a class="header" href="print.html#if-varnil" id="if-varnil"><h1>if var.nil?</h1></a>
<p>If an <code>if</code>'s condition is <code>var.nil?</code> then the type of <code>var</code> in the <code>then</code> branch is known by the compiler to be <code>Nil</code>, and to be known as non-<code>Nil</code> in the <code>else</code> branch:</p>
<pre><code class="language-crystal">a = some_condition ? nil : 3
if a.nil?
  # here a is Nil
else
  # here a is Int32
end
</code></pre>
<a class="header" href="print.html#if-" id="if-"><h1>if !</h1></a>
<p>The <code>!</code> operator returns a <code>Bool</code> that results from negating the <a href="truthy_and_falsey_values.html">truthyness</a> of a value.</p>
<p>When used in an <code>if</code> in conjunction with a variable, <code>is_a?</code>, <code>responds_to?</code> or <code>nil?</code> the compiler will restrict the types accordingly:</p>
<pre><code class="language-crystal">a = some_condition ? nil : 3
if !a
  # here a is Nil because a is falsey in this branch
else
  # here a is Int32, because a is truthy in this branch
end
</code></pre>
<pre><code class="language-crystal">b = some_condition ? 1 : &quot;x&quot;
if !b.is_a?(Int32)
  # here b is String because it's not an Int32
end
</code></pre>
<a class="header" href="print.html#unless" id="unless"><h1>unless</h1></a>
<p>An <code>unless</code> evaluates the then branch if its condition is <em>falsey</em>, and evaluates the <code>else branch</code>, if there’s any, otherwise. That is, it behaves in the opposite way of an <code>if</code>:</p>
<pre><code class="language-crystal">unless some_condition
  then_expression
else
  else_expression
end

# The above is the same as:
if some_condition
  else_expression
else
  then_expression
end

# Can also be written as a suffix
close_door unless door_closed?
</code></pre>
<a class="header" href="print.html#case" id="case"><h1>case</h1></a>
<p>A <code>case</code> is a control expression which functions a bit like pattern matching. It allows writing a chain of if-else-if with a small change in semantic and some more powerful constructs.</p>
<p>In its basic form, it allows matching a value against other values:</p>
<pre><code class="language-crystal">case exp
when value1, value2
  do_something
when value3
  do_something_else
else
  do_another_thing
end

# The above is the same as:
tmp = exp
if value1 === tmp || value2 === tmp
  do_something
elsif value3 === tmp
  do_something_else
else
  do_another_thing
end
</code></pre>
<p>For comparing an expression against a <code>case</code>'s value the <em>case equality operator</em> <code>===</code> is used. It is defined as a method on <a href="https://crystal-lang.org/api/Object.html#%3D%3D%3D%28other%29-instance-method"><code>Object</code></a> and can be overridden by subclasses to provide meaningful semantics in case statements. For example, <a href="https://crystal-lang.org/api/Class.html#%3D%3D%3D%28other%29-instance-method"><code>Class</code></a> defines case equality as when an object is an instance of that class, <a href="https://crystal-lang.org/api/Regex.html#%3D%3D%3D%28other%3AString%29-instance-method"><code>Regex</code></a> as when the value matches the regular expression and <a href="https://crystal-lang.org/api/Range.html#%3D%3D%3D%28value%29-instance-method"><code>Range</code></a> as when the value is included in that range.</p>
<p>If a <code>when</code>'s expression is a type, <code>is_a?</code> is used. Additionally, if the case expression is a variable or a variable assignment the type of the variable is restricted:</p>
<pre><code class="language-crystal">case var
when String
  # var : String
  do_something
when Int32
  # var : Int32
  do_something_else
else
  # here var is neither a String nor an Int32
  do_another_thing
end

# The above is the same as:
if var.is_a?(String)
  do_something
elsif var.is_a?(Int32)
  do_something_else
else
  do_another_thing
end
</code></pre>
<p>You can invoke a method on the <code>case</code>'s expression in a <code>when</code> by using the implicit-object syntax:</p>
<pre><code class="language-crystal">case num
when .even?
  do_something
when .odd?
  do_something_else
end

# The above is the same as:
tmp = num
if tmp.even?
  do_something
elsif tmp.odd?
  do_something_else
end
</code></pre>
<p>You may use <code>then</code> after the <code>when</code> condition to place the body on a single line.</p>
<pre><code class="language-crystal">case exp
when value1, value2 then do_something
when value3         then do_something_else
else                     do_another_thing
end
</code></pre>
<p>Finally, you can omit the <code>case</code>'s value:</p>
<pre><code class="language-crystal">case
when cond1, cond2
  do_something
when cond3
  do_something_else
end

# The above is the same as:
if cond1 || cond2
  do_something
elsif cond3
  do_something_else
end
</code></pre>
<p>This sometimes leads to code that is more natural to read.</p>
<a class="header" href="print.html#tuple-literal" id="tuple-literal"><h2>Tuple literal</h2></a>
<p>When a case expression is a tuple literal there are a few semantic differences if a when condition is also a tuple literal.</p>
<a class="header" href="print.html#tuple-size-must-match" id="tuple-size-must-match"><h3>Tuple size must match</h3></a>
<pre><code class="language-crystal">case {value1, value2}
when {0, 0} # OK, 2 elements
  # ...
when {1, 2, 3} # Compiler error, because it will never match
  # ...
end
</code></pre>
<a class="header" href="print.html#underscore-allowed" id="underscore-allowed"><h3>Underscore allowed</h3></a>
<pre><code class="language-crystal">case {value1, value2}
when {0, _}
  # Matches if 0 === value1, no test done against value2
when {_, 0}
  # Matches if 0 === value2, no test done against value1
end
</code></pre>
<a class="header" href="print.html#implicit-object-allowed" id="implicit-object-allowed"><h3>Implicit-object allowed</h3></a>
<pre><code class="language-crystal">case {value1, value2}
when {.even?, .odd?}
  # Matches if value1.even? &amp;&amp; value2.odd?
end
</code></pre>
<a class="header" href="print.html#comparing-against-a-type-will-perform-an-is_a-check" id="comparing-against-a-type-will-perform-an-is_a-check"><h3>Comparing against a type will perform an is_a? check</h3></a>
<pre><code class="language-crystal">case {value1, value2}
when {String, Int32}
  # Matches if value1.is_a?(String) &amp;&amp; value2.is_a?(Int32)
  # The type of value1 is known to be a String by the compiler,
  # and the type of value2 is known to be an Int32
end
</code></pre>
<a class="header" href="print.html#while-循环" id="while-循环"><h1>while 循环</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/while.md">syntax_and_semantics/while.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/08bd7620ca36c5fcf8b1f1aa14ba9c8bdb8e57b5">commit 08bd7620ca36c5fcf8b1f1aa14ba9c8bdb8e57b5</a></p>
</blockquote>
<p><code>while</code> 循环只要判断条件为<em>真(truth)</em>，它便一直执行。</p>
<pre><code class="language-crystal">while some_condition
  do_this
end
</code></pre>
<p>首先测试判断条件，如果为<em>真</em>，那么就执行循环体。既是，循环体有可能一直未被执行。</p>
<p><code>while</code> 循环的类型都是 <code>Nil</code> 。</p>
<p>与 <code>if</code> 类似，如果 <code>while</code> 循环的条件是个变量，要保证该变量在循环体中是非<code>空</code>值。如果条件是一个 <code>var.is_a?(Type)</code> 测试， 要保证在循环体中 <code>var</code> 类型为 <code>Type</code> 。如果判断条件 是一个 <code>var.responds_to?(:method)</code> ，要保证 <code>var</code> 是该函数的返回类型。</p>
<p><code>while</code> 之后的变量类型依赖于 <code>while</code> 之前的类型，并且该类型只在离开 <code>while</code> 循环体之前存在。</p>
<pre><code class="language-crystal">a = 1
while some_condition
  # a : Int32 | String
  a = &quot;hello&quot;
  # a : String
  a.size
end
# a : Int32 | String
</code></pre>
<a class="header" href="print.html#a在循环的最后判断条件" id="a在循环的最后判断条件"><h2>在循环的最后判断条件</h2></a>
<p>如果需要先执行循环体然后再判断退出条件，则可以这样：</p>
<pre><code class="language-crystal">while true
  do_something
  break if some_condition
end
</code></pre>
<p>或者使用 <code>loop</code>，其可以在标准库中找到。</p>
<pre><code class="language-crystal">loop do
  do_something
  break if some_condition
end
</code></pre>
<a class="header" href="print.html#break" id="break"><h1>break</h1></a>
<p>You can use <code>break</code> to break out of a <code>while</code> loop:</p>
<pre><code class="language-crystal">a = 2
while (a += 1) &lt; 20
  if a == 10
    break # goes to 'puts a'
  end
end
puts a #=&gt; 10
</code></pre>
<p><code>break</code> can also take a parameter which will then be the value that gets returned:</p>
<pre><code class="language-crystal">def foo
  loop do
    break &quot;bar&quot;
  end
end
puts foo #=&gt; &quot;bar&quot;
</code></pre>
<a class="header" href="print.html#next" id="next"><h1>next</h1></a>
<p>You can use <code>next</code> to try to execute the next iteration of a <code>while</code> loop. After executing <code>next</code>, the <code>while</code>'s condition is checked and, if <em>truthy</em>, the body will be executed.</p>
<pre><code class="language-crystal">a = 1
while a &lt; 5
  a += 1
  if a == 3
    next
  end
  puts a
end
# The above prints the numbers 2, 4 and 5
</code></pre>
<a class="header" href="print.html#until" id="until"><h1>until</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/until.md">syntax_and_semantics/until.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0c157b7eaad13f191ddb73f148171f3579287279">commit 0c157b7eaad13f191ddb73f148171f3579287279</a></p>
</blockquote>
<p><code>until</code> 执行代码块直到其条件为<em>真</em>。<code>until</code> 只是一个 <code>while</code> 循环条件否定的语法糖：</p>
<pre><code class="language-crystal">until some_condition
  do_this
end

# The above is the same as:
while !some_condition
  do_this
end
</code></pre>
<p><code>break</code> 和 <code>next</code> 在 <code>until</code> 里面也可以使用。</p>
<a class="header" href="print.html#a逻辑与操作符" id="a逻辑与操作符"><h1>逻辑与操作符 &amp;&amp;</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/and.md">syntax_and_semantics/and.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0bb5ad4d2622a98ee4fd93cc2216edf0d6a1485b">commit 0bb5ad4d2622a98ee4fd93cc2216edf0d6a1485b</a></p>
</blockquote>
<p><code>&amp;&amp;</code> 计算其左边的值。如果为<em>真</em>，则计算右边的值并持有改值。否则便持有左边的值。其类型为两边类型的并集。</p>
<p>可以认为 <code>&amp;&amp;</code> 是  <code>if</code> 的语法糖：</p>
<pre><code class="language-crystal">some_exp1 &amp;&amp; some_exp2

# The above is the same as:
tmp = some_exp1
if tmp
  some_exp2
else
  tmp
end
</code></pre>
<a class="header" href="print.html#a---logical-or-operator" id="a---logical-or-operator"><h1>|| - Logical OR Operator</h1></a>
<p>An <code>||</code> (or) evaluates its left hand side. If it's <em>falsey</em>, it evaluates its right hand side and has that value. Otherwise it has the value of the left hand side. Its type is the union of the types of both sides.</p>
<p>You can think an <code>||</code> as syntax sugar of an <code>if</code>:</p>
<pre><code class="language-crystal">some_exp1 || some_exp2

# The above is the same as:
tmp = some_exp1
if tmp
  tmp
else
  some_exp2
end
</code></pre>
<a class="header" href="print.html#requiring-files" id="requiring-files"><h1>Requiring files</h1></a>
<p>Writing a program in a single file is OK for little snippets and small benchmark code. Big programs are better maintained and understood when split across different files.</p>
<p>To make the compiler process other files you use <code>require &quot;...&quot;</code>. It accepts a single argument, a string literal, and it can come in many flavors.</p>
<p>Once a file is required, the compiler remembers its absolute path and later <code>require</code>s of that same file will be ignored.</p>
<a class="header" href="print.html#require-filename" id="require-filename"><h2>require &quot;filename&quot;</h2></a>
<p>This looks up &quot;filename&quot; in the require path.</p>
<p>By default the require path is the location of the standard library that comes with the compiler, and the &quot;lib&quot; directory relative to the current working directory (given by <code>pwd</code> in a Unix shell). These are the only places that are looked up.</p>
<p>The lookup goes like this:</p>
<ul>
<li>If a file named &quot;filename.cr&quot; is found in the require path, it is required.</li>
<li>If a directory named &quot;filename&quot; is found and it contains a file named &quot;filename.cr&quot; directly underneath it, it is required.</li>
<li>Otherwise a compile-time error is issued.</li>
</ul>
<p>The second rule is very convenient because of the typical directory structure of a project:</p>
<pre><code>- project
  - lib
    - foo
      foo.cr
    - bar
      bar.cr
  - src
    - project.cr
  - spec
    - project_spec.cr
</code></pre>
<p>For example, if you put <code>require &quot;foo&quot;</code> in <code>project.cr</code> and run <code>crystal src/project.cr</code> in the project's root directory, it will find <code>foo</code> in <code>lib/foo/foo.cr</code>.</p>
<p>If you run the compiler from somewhere else, say the <code>src</code> folder, <code>lib</code> will not be in the path and <code>require &quot;foo&quot;</code> can't be resolved.</p>
<a class="header" href="print.html#require-filename-1" id="require-filename-1"><h2>require &quot;./filename&quot;</h2></a>
<p>This looks up &quot;filename&quot; relative to the file containing the require expression.</p>
<p>The lookup goes like this:</p>
<ul>
<li>If a file named &quot;filename.cr&quot; is found relative to the current file, it is required.</li>
<li>If a directory named &quot;filename&quot; is found and it contains a file named &quot;filename.cr&quot; directly underneath it, it is required.</li>
<li>Otherwise a compile-time error is issued.</li>
</ul>
<p>This relative is mostly used inside a project to refer to other files inside it. It is also used to refer to code from <a href="../guides/testing.md">specs</a>:</p>
<pre><code class="language-crystal"># in spec/project_spec.cr
require &quot;../src/project&quot;
</code></pre>
<a class="header" href="print.html#other-forms" id="other-forms"><h2>Other forms</h2></a>
<p>In both cases you can use nested names and they will be looked up in nested directories:</p>
<ul>
<li><code>require &quot;foo/bar/baz&quot;</code> will lookup &quot;foo/bar/baz.cr&quot; or &quot;foo/bar/baz/baz.cr&quot; in the require path.</li>
<li><code>require &quot;./foo/bar/baz&quot;</code> will lookup &quot;foo/bar/baz.cr&quot; or &quot;foo/bar/baz/baz.cr&quot; relative to the current file.</li>
</ul>
<p>You can also use &quot;../&quot; to access parent directories relative to the current file, so <code>require &quot;../../foo/bar&quot;</code> works as well.</p>
<p>In all of these cases you can use the special <code>*</code> and <code>**</code> suffixes:</p>
<ul>
<li><code>require &quot;foo/*&quot;</code> will require all &quot;.cr&quot; files below the &quot;foo&quot; directory, but not below directories inside &quot;foo&quot;.</li>
<li><code>require &quot;foo/**&quot;</code> will require all &quot;.cr&quot; files below the &quot;foo&quot; directory, and below directories inside &quot;foo&quot;, recursively.</li>
</ul>
<a class="header" href="print.html#types-and-methods" id="types-and-methods"><h1>Types and methods</h1></a>
<p>The next sections will assume you know what <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">object oriented programming</a> is, as well as the concepts of <a href="http://en.wikipedia.org/wiki/Class_%28computer_programming%29">classes</a> and <a href="http://en.wikipedia.org/wiki/Method_%28computer_programming%29">methods</a>.</p>
<a class="header" href="print.html#everything-is-an-object" id="everything-is-an-object"><h1>Everything is an object</h1></a>
<p>In Crystal everything is an object. The definition of an object boils down to these points:</p>
<ul>
<li>It has a type</li>
<li>It can respond to some methods</li>
</ul>
<p>This is everything you can know about an object: its type and whether it responds to some method.</p>
<p>An object's internal state, if any, can only be queried by invoking methods.</p>
<a class="header" href="print.html#the-program" id="the-program"><h1>The Program</h1></a>
<p>The program is a global object in which you can define types, methods and file-local variables.</p>
<pre><code class="language-crystal"># Defines a method in the program
def add(x, y)
  x + y
end

# Invokes the add method in the program
add(1, 2) #=&gt; 3
</code></pre>
<p>A method's value is the value of its last expression; there's no need for explicit <code>return</code> expressions. However, explicit <code>return</code> expressions are possible:</p>
<pre><code class="language-crystal">def even?(num)
  if num % 2 == 0
    return true
  end

  return false
end
</code></pre>
<p>When invoking a method without a receiver, like <code>add(1, 2)</code>, it will be searched for in the program if not found in the current type or any of its ancestors.</p>
<pre><code class="language-crystal">def add(x, y)
  x + y
end

class Foo
  def bar
    # invokes the program's add method
    add(1, 2)

    # invokes Foo's baz method
    baz(1, 2)
  end

  def baz(x, y)
    x * y
  end
end
</code></pre>
<p>If you want to invoke the program's method, even though the current type defines a method with the same name, prefix the call with <code>::</code>:</p>
<pre><code class="language-crystal">def baz(x, y)
  x + y
end

class Foo
  def bar
    baz(4, 2) #=&gt; 2
    ::baz(4, 2) #=&gt; 6
  end

  def baz(x, y)
    x - y
  end
end
</code></pre>
<p>Variables declared in a program are not visible inside methods:</p>
<pre><code class="language-crystal">x = 1

def add(y)
  x + y # error: undefined local variable or method 'x'
end

add(2)
</code></pre>
<p>Parentheses in method invocations are optional:</p>
<pre><code class="language-crystal">add 1, 2 # same as add(1, 2)
</code></pre>
<a class="header" href="print.html#main-code" id="main-code"><h2>Main code</h2></a>
<p>Main code, the code that is run when you compile and run a program, can be written directly in a source file without the need to put it in a special &quot;main&quot; method:</p>
<pre><code class="language-crystal"># This is a program that prints &quot;Hello Crystal!&quot;
puts &quot;Hello Crystal!&quot;
</code></pre>
<p>Main code can also be inside type declarations:</p>
<pre><code class="language-crystal"># This is a program that prints &quot;Hello&quot;
class Hello
  # 'self' here is the Hello class
  puts self
end
</code></pre>
<a class="header" href="print.html#classes-and-methods" id="classes-and-methods"><h1>Classes and methods</h1></a>
<p>A class is a blueprint from which individual objects are created. As an example, consider a <code>Person</code> class. You declare a class like this:</p>
<pre><code class="language-crystal">class Person
end
</code></pre>
<p>Class names, and indeed all type names, begin with a capital letter in Crystal.</p>
<a class="header" href="print.html#new-initialize-and-allocate" id="new-initialize-and-allocate"><h1>new, initialize and allocate</h1></a>
<p>You create an instance of a class by invoking <code>new</code> on that class:</p>
<pre><code>person = Person.new
</code></pre>
<p>Here, <code>person</code> is an instance of <code>Person</code>.</p>
<p>We can't do much with <code>person</code>, so let's add some concepts to it. A <code>Person</code> has a name and an age. In the &quot;Everything is an object&quot; section we said that an object has a type and responds to some methods, which is the only way to interact with objects, so we'll need both <code>name</code> and <code>age</code> methods. We will store this information in instance variables, which are always prefixed with an <em>at</em> (<code>@</code>) character. We also want a Person to come into existence with a name of our choice and an age of zero. We code the &quot;come into existence&quot; part with a special <code>initialize</code> method, which is normally called a <em>constructor</em>:</p>
<pre><code class="language-crystal">class Person
  def initialize(name : String)
    @name = name
    @age = 0
  end

  def name
    @name
  end

  def age
    @age
  end
end
</code></pre>
<p>Now we can create people like this:</p>
<pre><code class="language-crystal">john = Person.new &quot;John&quot;
peter = Person.new &quot;Peter&quot;

john.name #=&gt; &quot;John&quot;
john.age #=&gt; 0

peter.name #=&gt; &quot;Peter&quot;
</code></pre>
<p>(If you wonder why we needed to specify that <code>name</code> is a <code>String</code> but we didn't need to do it for <code>age</code>, check the <a href="type_inference.html">global type inference algorithm</a>)</p>
<p>Note that we create a <code>Person</code> with <code>new</code> but we defined the initialization in an <code>initialize</code> method, not in a <code>new</code> method. Why is this so?</p>
<p>The answer is that when we defined an <code>initialize</code> method Crystal defined a <code>new</code> method for us, like this:</p>
<pre><code class="language-crystal">class Person
  def self.new(name : String)
    instance = Person.allocate
    instance.initialize(name)
    instance
  end
end
</code></pre>
<p>First, note the <code>self.new</code> notation. This is a <a href="class_methods.md">class method</a> that belongs to the <strong>class</strong> <code>Person</code>, not to particular instances of that class. This is why we can do <code>Person.new</code>.</p>
<p>Second, <code>allocate</code> is a low-level class method that creates an uninitialized object of the given type. It basically allocates the necessary memory for the object, then <code>initialize</code> is invoked on it and finally the instance is returned. You generally never invoke <code>allocate</code>, as it is <a href="unsafe.html">unsafe</a>, but that's the reason why <code>new</code> and <code>initialize</code> are related.</p>
<a class="header" href="print.html#methods-and-instance-variables" id="methods-and-instance-variables"><h1>Methods and instance variables</h1></a>
<p>We can simplify our constructor by using a shorter syntax for assigning a method argument to an instance variable:</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
    @age = 0
  end
  
  def age
    @age
  end
end
</code></pre>
<p>Right now, we can't do much with a person aside from create it with a name. Its age will always be zero. So lets add a method that makes a person become older:</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
    @age = 0
  end
  
  def age
    @age
  end
  
  def become_older
    @age += 1
  end
end

john = Person.new &quot;John&quot;
peter = Person.new &quot;Peter&quot;

john.age #=&gt; 0

john.become_older
john.age #=&gt; 1

peter.age #=&gt; 0
</code></pre>
<p>Method names begin with a lowercase letter and, as a convention, only use lowercase letters, underscores and numbers.</p>
<a class="header" href="print.html#getters-and-setters" id="getters-and-setters"><h2>Getters and setters</h2></a>
<p>The Crystal <a href="https://crystal-lang.org/api">Standard Library</a> provides macros which simplify the definition of getter and setter methods:</p>
<pre><code class="language-crystal">class Person
  property age
  getter name : String

  def initialize(@name)
    @age = 0
  end
end

john = Person.new &quot;John&quot;
john.age = 32
john.age #=&gt; 32
</code></pre>
<p>For more information on getter and setter macros, see the standard library documentation for <a href="https://crystal-lang.org/api/latest/Object.html#getter%28%2Anames%29-macro">Object#getter</a>, <a href="https://crystal-lang.org/api/latest/Object.html#setter%28%2Anames%29-macro">Object#setter</a>, and <a href="https://crystal-lang.org/api/latest/Object.html#property%28%2Anames%29-macro">Object#property</a>.</p>
<p>As a side note, we can define <code>become_older</code> inside the original <code>Person</code> definition, or in a separate definition: Crystal combines all definitions into a single class. The following works just fine:</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
    @age = 0
  end
end

class Person
  def become_older
    @age += 1
  end
end
</code></pre>
<a class="header" href="print.html#redefining-methods-and-previous_def" id="redefining-methods-and-previous_def"><h2>Redefining methods, and previous_def</h2></a>
<p>If you redefine a method, the last definition will take precedence.</p>
<pre><code class="language-crystal">class Person
  def become_older
    @age += 1
  end
end

class Person
  def become_older
    @age += 2
  end
end

person = Person.new &quot;John&quot;
person.become_older
person.age #=&gt; 2
</code></pre>
<p>You can invoke the previously redefined method with <code>previous_def</code>:</p>
<pre><code class="language-crystal">class Person
  def become_older
    @age += 1
  end
end

class Person
  def become_older
    previous_def
    @age += 2
  end
end

person = Person.new &quot;John&quot;
person.become_older
person.age #=&gt; 3
</code></pre>
<p>Without arguments or parentheses, <code>previous_def</code> receives the same arguments as the method's arguments. Otherwise, it receives the arguments you pass to it.</p>
<a class="header" href="print.html#catch-all-initialization" id="catch-all-initialization"><h2>Catch-all initialization</h2></a>
<p>Instance variables can also be initialized outside <code>initialize</code> methods:</p>
<pre><code class="language-crystal">class Person
  @age = 0

  def initialize(@name : String)
  end
end
</code></pre>
<p>This will initialize <code>@age</code> to zero in every constructor. This is useful to avoid duplication, but also to avoid the <code>Nil</code> type when reopening a class and adding instance variables to it.</p>
<a class="header" href="print.html#type-inference" id="type-inference"><h1>Type inference</h1></a>
<p>Crystal's philosophy is to require as few type annotations as possible. However, some type annotations are required.</p>
<p>Consider a class definition like this:</p>
<pre><code class="language-crystal">class Person
  def initialize(@name)
    @age = 0
  end
end
</code></pre>
<p>We can quickly see that <code>@age</code> is an integer, but we don't know what's the type of <code>@name</code>. The compiler could infer its type from all uses of the <code>Person</code> class. However, doing so has a few issues:</p>
<ul>
<li>The type is not obvious for a human reading the code: she would also have to check all uses of <code>Person</code> to find this out.</li>
<li>Some compiler optimizations, like having to analyze a method just once, and incremental compilation, are nearly impossible to do.</li>
</ul>
<p>As a code base grows, these issues gain more relevance: understanding a project becomes harder, and compile times become unbearable.</p>
<p>For this reason, Crystal needs to know, in an obvious way (as obvious as to a human), the types of instance and <a href="class_variables.html">class</a> variables.</p>
<p>There are several ways to let Crystal know this.</p>
<a class="header" href="print.html#with-type-annotations" id="with-type-annotations"><h2>With type annotations</h2></a>
<p>The easiest, but probably most tedious, way is to use explicit type annotations.</p>
<pre><code class="language-crystal">class Person
  @name : String
  @age : Int32

  def initialize(@name)
    @age = 0
  end
end
</code></pre>
<a class="header" href="print.html#without-type-annotations" id="without-type-annotations"><h2>Without type annotations</h2></a>
<p>If you omit an explicit type annotation the compiler will try to infer the type of instance and class variables using a bunch of syntactic rules.</p>
<p>For a given instance/class variable, when a rule can be applied and a type can be guessed, the type is added to a set. When no more rules can be applied, the inferred type will be the <a href="union_types.html">union</a> of those types. Additionally, if the compiler infers that an instance variable isn't always initialized, it will also include the <a href="literals/nil.html">Nil</a> type.</p>
<p>The rules are many, but usually the first three are most used. There's no need to remember them all. If the compiler gives an error saying that the type of an instance variable can't be inferred you can always add an explicit type annotation.</p>
<p>The following rules only mention instance variables, but they apply to class variables as well. They are:</p>
<a class="header" href="print.html#a1-assigning-a-literal-value" id="a1-assigning-a-literal-value"><h3>1. Assigning a literal value</h3></a>
<p>When a literal is assigned to an instance variable, the literal's type is added to the set. All <a href="literals.html">literals</a> have an associated type.</p>
<p>In the following example, <code>@name</code> is inferred to be <code>String</code> and <code>@age</code> to be <code>Int32</code>.</p>
<pre><code class="language-crystal">class Person
  def initialize
    @name = &quot;John Doe&quot;
    @age = 0
  end
end
</code></pre>
<p>This rule, and every following rule, will also be applied in methods other than <code>initialize</code>. For example:</p>
<pre><code class="language-crystal">class SomeObject
  def lucky_number
    @lucky_number = 42
  end
end
</code></pre>
<p>In the above case, <code>@lucky_number</code> will be inferred to be <code>Int32 | Nil</code>: <code>Int32</code> because 42 was assigned to it, and <code>Nil</code> because it wasn't assigned in all of the class' initialize methods.</p>
<a class="header" href="print.html#a2-assigning-the-result-of-invoking-the-class-method-new" id="a2-assigning-the-result-of-invoking-the-class-method-new"><h3>2. Assigning the result of invoking the class method <code>new</code></h3></a>
<p>When an expression like <code>Type.new(...)</code> is assigned to an instance variable, the type <code>Type</code> is added to the set.</p>
<p>In the following example, <code>@address</code> is inferred to be <code>Address</code>.</p>
<pre><code class="language-crystal">class Person
  def initialize
    @address = Address.new(&quot;somewhere&quot;)
  end
end
</code></pre>
<p>This also is applied to generic types. Here <code>@values</code> is inferred to be <code>Array(Int32)</code>.</p>
<pre><code class="language-crystal">class Something
  def initialize
    @values = Array(Int32).new
  end
end
</code></pre>
<p><strong>Note</strong>: a <code>new</code> method might be redefined by a type. In that case the inferred type will be the one returned by <code>new</code>, if it can be inferred using some of the next rules.</p>
<a class="header" href="print.html#a3-assigning-a-variable-that-is-a-method-argument-with-a-type-restriction" id="a3-assigning-a-variable-that-is-a-method-argument-with-a-type-restriction"><h3>3. Assigning a variable that is a method argument with a type restriction</h3></a>
<p>In the following example <code>@name</code> is inferred to be <code>String</code> because the method argument <code>name</code> has a type restriction of type <code>String</code>, and that argument is assigned to <code>@name</code>.</p>
<pre><code class="language-crystal">class Person
  def initialize(name : String)
    @name = name
  end
end
</code></pre>
<p>Note that the name of the method argument is not important; this works as well:</p>
<pre><code class="language-crystal">class Person
  def initialize(obj : String)
    @name = obj
  end
end
</code></pre>
<p>Using the shorter syntax to assign an instance variable from a method argument has the same effect:</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
  end
end
</code></pre>
<p>Also note that the compiler doesn't check whether a method argument is reassigned a different value:</p>
<pre><code class="language-crystal">class Person
  def initialize(name : String)
    name = 1
    @name = name
  end
end
</code></pre>
<p>In the above case, the compiler will still infer <code>@name</code> to be <code>String</code>, and later will give a compile time error, when fully typing that method, saying that <code>Int32</code> can't be assigned to a variable of type <code>String</code>. Use an explicit type annotation if <code>@name</code> isn't supposed to be a <code>String</code>.</p>
<a class="header" href="print.html#a4-assigning-the-result-of-a-class-method-that-has-a-return-type-annotation" id="a4-assigning-the-result-of-a-class-method-that-has-a-return-type-annotation"><h3>4. Assigning the result of a class method that has a return type annotation</h3></a>
<p>In the following example, <code>@address</code> is inferred to be <code>Address</code>, because the class method <code>Address.unknown</code> has a return type annotation of <code>Address</code>.</p>
<pre><code class="language-crystal">class Person
  def initialize
    @address = Address.unknown
  end
end

class Address
  def self.unknown : Address
    new(&quot;unknown&quot;)
  end

  def initialize(@name : String)
  end
end
</code></pre>
<p>In fact, the above code doesn't need the return type annotation in <code>self.unknown</code>. The reason is that the compiler will also look at a class method's body and if it can apply one of the previous rules (it's a <code>new</code> method, or it's a literal, etc.) it will infer the type from that expression. So, the above can be simply written like this:</p>
<pre><code class="language-crystal">class Person
  def initialize
    @address = Address.unknown
  end
end

class Address
  # No need for a return type annotation here
  def self.unknown
    new(&quot;unknown&quot;)
  end

  def initialize(@name : String)
  end
end
</code></pre>
<p>This extra rule is very convenient because it's very common to have &quot;constructor-like&quot; class methods in addition to <code>new</code>.</p>
<a class="header" href="print.html#a5-assigning-a-variable-that-is-a-method-argument-with-a-default-value" id="a5-assigning-a-variable-that-is-a-method-argument-with-a-default-value"><h3>5. Assigning a variable that is a method argument with a default value</h3></a>
<p>In the following example, because the default value of <code>name</code> is a string literal, and it's later assigned to <code>@name</code>, <code>String</code> will be added to the set of inferred types.</p>
<pre><code class="language-crystal">class Person
  def initialize(name = &quot;John Doe&quot;)
    @name = name
  end
end
</code></pre>
<p>This of course also works with the short syntax:</p>
<pre><code class="language-crystal">class Person
  def initialize(@name = &quot;John Doe&quot;)
  end
end
</code></pre>
<p>The default value can also be a <code>Type.new(...)</code> method or a class method with a return type annotation.</p>
<a class="header" href="print.html#a6-assigning-the-result-of-invoking-a-lib-function" id="a6-assigning-the-result-of-invoking-a-lib-function"><h3>6. Assigning the result of invoking a <code>lib</code> function</h3></a>
<p>Because a <a href="c_bindings/fun.html">lib function</a> must have explicit types, the compiler can use the return type when assigning it to an instance variable.</p>
<p>In the following example <code>@age</code> is inferred to be <code>Int32</code>.</p>
<pre><code class="language-crystal">class Person
  def initialize
    @age = LibPerson.compute_default_age
  end
end

lib LibPerson
  fun compute_default_age : Int32
end
</code></pre>
<a class="header" href="print.html#a7-using-an-out-lib-expression" id="a7-using-an-out-lib-expression"><h3>7. Using an <code>out</code> lib expression</h3></a>
<p>Because a <a href="c_bindings/fun.html">lib function</a> must have explicit types, the compiler can use the <code>out</code> argument's type, which should be a pointer type, and use the dereferenced type as a guess.</p>
<p>In the following example <code>@age</code> is inferred to be <code>Int32</code>.</p>
<pre><code class="language-crystal">class Person
  def initialize
    LibPerson.compute_default_age(out @age)
  end
end

lib LibPerson
  fun compute_default_age(age_ptr : Int32*)
end
</code></pre>
<a class="header" href="print.html#other-rules" id="other-rules"><h3>Other rules</h3></a>
<p>The compiler will try to be as smart as possible to require less explicit type annotations. For example, if assigning an <code>if</code> expression, type will be inferred from the <code>then</code> and <code>else</code> branches:</p>
<pre><code class="language-crystal">class Person
  def initialize
    @age = some_condition ? 1 : 2
  end
end
</code></pre>
<p>Because the <code>if</code> above (well, technically a ternary operator, but it's similar to an <code>if</code>) has integer literals, <code>@age</code> is successfully inferred to be <code>Int32</code> without requiring a redundant type annotation.</p>
<p>Another case is <code>||</code> and <code>||=</code>:</p>
<pre><code class="language-crystal">class SomeObject
  def lucky_number
    @lucky_number ||= 42
  end
end
</code></pre>
<p>In the above example <code>@lucky_number</code> will be inferred to be <code>Int32 | Nil</code>. This is very useful for lazily initialized variables.</p>
<p>Constants will also be followed, as it's pretty simple for the compiler (and a human) to do so.</p>
<pre><code class="language-crystal">class SomeObject
  DEFAULT_LUCKY_NUMBER = 42

  def initialize(@lucky_number = DEFAULT_LUCKY_NUMBER)
  end
end
</code></pre>
<p>Here rule 5 (argument's default value) is used, and because the constant resolves to an integer literal, <code>@lucky_number</code> is inferred to be <code>Int32</code>.</p>
<a class="header" href="print.html#union-types" id="union-types"><h1>Union types</h1></a>
<p>The type of a variable or expression can consist of multiple types. This is called a union type. For example, when assigning to a same variable inside different <a href="if.html">if</a> branches:</p>
<pre><code class="language-crystal">if 1 + 2 == 3
  a = 1
else
  a = &quot;hello&quot;
end

a # : Int32 | String
</code></pre>
<p>At the end of the if, <code>a</code> will have the <code>Int32 | String</code> type, read &quot;the union of Int32 and String&quot;. This union type is created automatically by the compiler. At runtime, <code>a</code> will of course be of one type only. This can be seen by invoking the <code>class</code> method:</p>
<pre><code class="language-crystal"># The runtime type
a.class # =&gt; Int32
</code></pre>
<p>The compile-time type can be seen by using <a href="typeof.html">typeof</a>:</p>
<pre><code class="language-crystal"># The compile-time type
typeof(a) # =&gt; Int32 | String
</code></pre>
<p>A union can consist of an arbitrary large number of types. When invoking a method on an expression whose type is a union type, all types in the union must respond to the method, otherwise a compile-time error is given. The type of the method call is the union type of the return types of those methods.</p>
<pre><code class="language-crystal"># to_s is defined for Int32 and String, it returns String
a.to_s # =&gt; String

a + 1 # Error, because String#+(Int32) isn't defined
</code></pre>
<p>If necessary a variable can be defined as a union type at compile time</p>
<pre><code># set the compile-time type
a = 0.as(Int32|Nil|String)
typeof(a) # =&gt; Int32 | Nil | String
</code></pre>
<a class="header" href="print.html#union-types-rules" id="union-types-rules"><h2>Union types rules</h2></a>
<p>In the general case, when two types <code>T1</code> and <code>T2</code> are combined, the result is a union <code>T1 | T2</code>. However, there are a few cases where the resulting type is a different type.</p>
<a class="header" href="print.html#union-of-classes-and-structs-under-the-same-hierarchy" id="union-of-classes-and-structs-under-the-same-hierarchy"><h3>Union of classes and structs under the same hierarchy</h3></a>
<p>If <code>T1</code> and <code>T2</code> are under the same hierarchy, and their nearest common ancestor <code>Parent</code> is not <code>Reference</code>, <code>Struct</code>, <code>Int</code>, <code>Float</code> nor <code>Value</code>, the resulting type is <code>Parent+</code>. This is called a virtual type, which basically means the compiler will now see the type as being <code>Parent</code> or any of its subtypes.</p>
<p>For example:</p>
<pre><code class="language-crystal">class Foo
end

class Bar &lt; Foo
end

class Baz &lt; Foo
end

bar = Bar.new
baz = Baz.new

# Here foo's type will be Bar | Baz,
# but because both Bar and Baz inherit from Foo,
# the resulting type is Foo+
foo = rand &lt; 0.5 ? bar : baz
typeof(foo) # =&gt; Foo+
</code></pre>
<a class="header" href="print.html#union-of-tuples-of-the-same-size" id="union-of-tuples-of-the-same-size"><h3>Union of tuples of the same size</h3></a>
<p>The union of two tuples of the same size results in a tuple type that has the union of the types in each position.</p>
<p>For example:</p>
<pre><code class="language-crystal">t1 = {1, &quot;hi&quot;}   # Tuple(Int32, String)
t2 = {true, nil} # Tuple(Bool, Nil)

t3 = rand &lt; 0.5 ? t1 : t2
typeof(t3) # Tuple(Int32 | Bool, String | Nil)
</code></pre>
<a class="header" href="print.html#union-of-named-tuples-with-the-same-keys" id="union-of-named-tuples-with-the-same-keys"><h3>Union of named tuples with the same keys</h3></a>
<p>The union of two named tuples with the same keys (regardless of their order) results in a named tuple type that has the union of the types in each key. The order of the keys will be the ones from the tuple on the left hand side.</p>
<p>For example:</p>
<pre><code class="language-crystal">t1 = {x: 1, y: &quot;hi&quot;}   # Tuple(x: Int32, y: String)
t2 = {y: true, x: nil} # Tuple(y: Bool, x: Nil)

t3 = rand &lt; 0.5 ? t1 : t2
typeof(t3) # NamedTuple(x: Int32 | Nil, y: String | Bool)
</code></pre>
<a class="header" href="print.html#overloading" id="overloading"><h1>Overloading</h1></a>
<p>We can define a <code>become_older</code> method that accepts a number indicating the years to grow:</p>
<pre><code class="language-crystal">class Person
  getter :age
    
  def initialize(@name : String, @age : Int = 0)
  end

  def become_older
    @age += 1
  end

  def become_older(years)
    @age += years
  end
end

john = Person.new &quot;John&quot;
john.age #=&gt; 0

john.become_older
john.age #=&gt; 1

john.become_older 5
john.age #=&gt; 6
</code></pre>
<p>That is, you can have different methods with the same name and different number of arguments and they will be considered as separate methods. This is called <em>method overloading</em>.</p>
<p>Methods overload by several criteria:</p>
<ul>
<li>The number of arguments</li>
<li>The type restrictions applied to arguments</li>
<li>The names of required named arguments</li>
<li>Whether the method accepts a <a href="blocks_and_procs.html">block</a> or not</li>
</ul>
<p>For example, we can define four different <code>become_older</code> methods:</p>
<pre><code class="language-crystal">class Person
  @age = 0

  # Increases age by one
  def become_older
    @age += 1
  end

  # Increases age by the given number of years
  def become_older(years : Int32)
    @age += years
  end

  # Increases age by the given number of years, as a String
  def become_older(years : String)
    @age += years.to_i
  end

  # Yields the current age of this person and increases
  # its age by the value returned by the block
  def become_older
    @age += yield @age
  end
end

person = Person.new &quot;John&quot;

person.become_older
person.age #=&gt; 1

person.become_older 5
person.age #=&gt; 6

person.become_older &quot;12&quot;
person.age #=&gt; 18

person.become_older do |current_age|
  current_age &lt; 20 ? 10 : 30
end
person.age #=&gt; 28
</code></pre>
<p>Note that in the case of the method that yields, the compiler figured this out because there's a <code>yield</code> expression. To make this more explicit, you can add a dummy <code>&amp;block</code> argument at the end:</p>
<pre><code class="language-crystal">class Person
  @age = 0

  def become_older(&amp;block)
    @age += yield @age
  end
end
</code></pre>
<p>In generated documentation the dummy <code>&amp;block</code> method will always appear, regardless of you writing it or not.</p>
<p>Given the same number of arguments, the compiler will try to sort them by leaving the less restrictive ones to the end:</p>
<pre><code class="language-crystal">class Person
  @age = 0

  # First, this method is defined
  def become_older(age)
    @age += age
  end

  # Since &quot;String&quot; is more restrictive than no restriction
  # at all, the compiler puts this method before the previous
  # one when considering which overload matches.
  def become_older(age : String)
    @age += age.to_i
  end
end

person = Person.new &quot;John&quot;

# Invokes the first definition
person.become_older 20

# Invokes the second definition
person.become_older &quot;12&quot;
</code></pre>
<p>However, the compiler cannot always figure out the order because there isn't always a total ordering, so it's always better to put less restrictive methods at the end.</p>
<a class="header" href="print.html#default-values" id="default-values"><h1>Default values</h1></a>
<p>A method can specify default values for the last arguments:</p>
<pre><code class="language-crystal">class Person
  def become_older(by = 1)
    @age += by
  end
end

john = Person.new &quot;John&quot;
john.age #=&gt; 0

john.become_older
john.age #=&gt; 1

john.become_older 2
john.age #=&gt; 3
</code></pre>
<a class="header" href="print.html#named-arguments" id="named-arguments"><h1>Named arguments</h1></a>
<p>All arguments can also be specified, in addition to their position, by their name. For example:</p>
<pre><code class="language-crystal">john.become_older by: 5
</code></pre>
<p>When there are many arguments, the order of the names in the invocation don't matter, as long as all required arguments are covered:</p>
<pre><code class="language-crystal">def some_method(x, y = 1, z = 2, w = 3)
  # do something...
end

some_method 10                   # x: 10, y: 1, z: 2, w: 3
some_method 10, z: 10            # x: 10, y: 1, z: 10, w: 3
some_method 10, w: 1, y: 2, z: 3 # x: 10, y: 2, z: 3, w: 1
some_method y: 10, x: 20         # x: 20, y: 10, z: 2, w: 3

some_method y: 10                # Error, missing argument: x
</code></pre>
<p>When a method specifies a splat (explained in the next section), named arguments can't be used. The reason is that understanding how arguments are matched becomes very difficult; positional arguments are easier to reason about in this case.</p>
<a class="header" href="print.html#splats-and-tuples" id="splats-and-tuples"><h1>Splats and tuples</h1></a>
<p>A method can receive a variable number of arguments by using a <em>splat</em> (<code>*</code>), which can appear only once and in any position:</p>
<pre><code class="language-crystal">def sum(*elements)
  total = 0
  elements.each do |value|
    total += value
  end
  total
end

sum 1, 2, 3    #=&gt; 6
sum 1, 2, 3, 4.5 #=&gt; 10.5
</code></pre>
<p>The passed arguments become a <a href="http://crystal-lang.org/api/Tuple.html">Tuple</a> in the method's body:</p>
<pre><code class="language-crystal"># elements is Tuple(Int32, Int32, Int32)
sum 1, 2, 3

# elements is Tuple(Int32, Int32, Int32, Float64)
sum 1, 2, 3, 4.5
</code></pre>
<p>Arguments past the splat argument can only be passed as named arguments:</p>
<pre><code class="language-crystal">def sum(*elements, initial = 0)
  total = initial
  elements.each do |value|
    total += value
  end
  total
end

sum 1, 2, 3 # =&gt; 6
sum 1, 2, 3, initial: 10 # =&gt; 16
</code></pre>
<p>Arguments past the splat method without a default value are required named arguments:</p>
<pre><code class="language-crystal">def sum(*elements, initial)
  total = initial
  elements.each do |value|
    total += value
  end
  total
end

sum 1, 2, 3 # Error, missing argument: initial
sum 1, 2, 3, initial: 10 # =&gt; 16
</code></pre>
<p>Two methods with different required named arguments overload between each other:</p>
<pre><code class="language-crystal">def foo(*elements, x)
  1
end

def foo(*elements, y)
  2
end

foo x: &quot;something&quot; # =&gt; 1
foo y: &quot;something&quot; # =&gt; 2
</code></pre>
<p>The splat argument can also be left unnamed, with the meaning &quot;after this, named arguments follow&quot;:</p>
<pre><code class="language-crystal">def foo(x, y, *, z)
end

foo 1, 2, 3    # Error, wrong number of arguments (given 3, expected 2)
foo 1, 2       # Error, missing argument: z
foo 1, 2, z: 3 # OK
</code></pre>
<a class="header" href="print.html#splatting-a-tuple" id="splatting-a-tuple"><h2>Splatting a tuple</h2></a>
<p>A <code>Tuple</code> can be splat into a method call by using <code>*</code>:</p>
<pre><code class="language-crystal">def foo(x, y)
  x + y
end

tuple = {1, 2}
foo *tuple # =&gt; 3
</code></pre>
<a class="header" href="print.html#double-splats-and-named-tuples" id="double-splats-and-named-tuples"><h2>Double splats and named tuples</h2></a>
<p>A double splat (<code>**</code>) captures named arguments that were not matched by other arguments. The type of the argument is a <code>NamedTuple</code>:</p>
<pre><code class="language-crystal">def foo(x, **other)
  # Return the captured named arguments as a NamedTuple
  other
end

foo 1, y: 2, z: 3    # =&gt; {y: 2, z: 3}
foo y: 2, x: 1, z: 3 # =&gt; {y: 2, z: 3}
</code></pre>
<a class="header" href="print.html#double-splatting-a-named-tuple" id="double-splatting-a-named-tuple"><h2>Double splatting a named tuple</h2></a>
<p>A <code>NamedTuple</code> can be splat into a method call by using <code>**</code>:</p>
<pre><code class="language-crystal">def foo(x, y)
  x - y
end

tuple = {y: 3, x: 10}
foo **tuple # =&gt; 7
</code></pre>
<a class="header" href="print.html#type-restrictions" id="type-restrictions"><h1>Type restrictions</h1></a>
<p>Type restrictions are type annotations put to method arguments to restrict the types accepted by that method.</p>
<pre><code class="language-crystal">def add(x : Number, y : Number)
  x + y
end

# Ok
add 1, 2 # Ok

# Error: no overload matches 'add' with types Bool, Bool
add true, false
</code></pre>
<p>Note that if we had defined <code>add</code> without type restrictions, we would also have gotten a compile time error:</p>
<pre><code class="language-crystal">def add(x, y)
  x + y
end

add true, false
</code></pre>
<p>The above code gives this compile error:</p>
<pre><code>Error in foo.cr:6: instantiating 'add(Bool, Bool)'

add true, false
^~~

in foo.cr:2: undefined method '+' for Bool

  x + y
    ^
</code></pre>
<p>This is because when you invoke <code>add</code>, it is instantiated with the types of the arguments: every method invocation with a different type combination results in a different method instantiation.</p>
<p>The only difference is that the first error message is a little more clear, but both definitions are safe in that you will get a compile time error anyway. So, in general, it's preferable not to specify type restrictions and almost only use them to define different method overloads. This results in more generic, reusable code. For example, if we define a class that has a <code>+</code> method but isn't a <code>Number</code>, we can use the <code>add</code> method that doesn't have type restrictions, but we can't use the <code>add</code> method that has restrictions.</p>
<pre><code class="language-crystal"># A class that has a + method but isn't a Number
class Six
  def +(other)
    6 + other
  end
end

# add method without type restrictions
def add(x, y)
  x + y
end

# OK
add Six.new, 10

# add method with type restrictions
def restricted_add(x : Number, y : Number)
  x + y
end

# Error: no overload matches 'restricted_add' with types Six, Int32
restricted_add Six.new, 10
</code></pre>
<p>Refer to the <a href="type_grammar.html">type grammar</a> for the notation used in type restrictions.</p>
<p>Note that type restrictions do not apply to the variables inside the actual methods.</p>
<pre><code class="language-crystal">def handle_path(path : String)
  path = Path.new(path) # *path* is now of the type Path
  # Do something with *path*
end
</code></pre>
<a class="header" href="print.html#self-restriction" id="self-restriction"><h2>self restriction</h2></a>
<p>A special type restriction is <code>self</code>:</p>
<pre><code class="language-crystal">class Person
  def ==(other : self)
    other.name == name
  end

  def ==(other)
    false
  end
end

john = Person.new &quot;John&quot;
another_john = Person.new &quot;John&quot;
peter = Person.new &quot;Peter&quot;

john == another_john #=&gt; true
john == peter #=&gt; false (names differ)
john == 1 #=&gt; false (because 1 is not a Person)
</code></pre>
<p>In the previous example <code>self</code> is the same as writing <code>Person</code>. But, in general, <code>self</code> is the same as writing the type that will finally own that method, which, when modules are involved, becomes more useful.</p>
<p>As a side note, since <code>Person</code> inherits <code>Reference</code> the second definition of <code>==</code> is not needed, since it's already defined in <code>Reference</code>.</p>
<p>Note that <code>self</code> always represents a match against an instance type, even in class methods:</p>
<pre><code class="language-crystal">class Person
  def self.compare(p1 : self, p2 : self)
    p1.name == p2.name
  end
end

john = Person.new &quot;John&quot;
peter = Person.new &quot;Peter&quot;

Person.compare(john, peter) # OK
</code></pre>
<p>You can use <code>self.class</code> to restrict to the Person type. The next section talks about the <code>.class</code> suffix in type restrictions.</p>
<a class="header" href="print.html#classes-as-restrictions" id="classes-as-restrictions"><h2>Classes as restrictions</h2></a>
<p>Using, for example, <code>Int32</code> as a type restriction makes the method only accept instances of <code>Int32</code>:</p>
<pre><code class="language-crystal">def foo(x : Int32)
end

foo 1       # OK
foo &quot;hello&quot; # Error
</code></pre>
<p>If you want a method to only accept the type Int32 (not instances of it), you use <code>.class</code>:</p>
<pre><code class="language-crystal">def foo(x : Int32.class)
end

foo Int32  # OK
foo String # Error
</code></pre>
<p>The above is useful for providing overloads based on types, not instances:</p>
<pre><code class="language-crystal">def foo(x : Int32.class)
  puts &quot;Got Int32&quot;
end

def foo(x : String.class)
  puts &quot;Got String&quot;
end

foo Int32  # prints &quot;Got Int32&quot;
foo String # prints &quot;Got String&quot;
</code></pre>
<a class="header" href="print.html#type-restrictions-in-splats" id="type-restrictions-in-splats"><h2>Type restrictions in splats</h2></a>
<p>You can specify type restrictions in splats:</p>
<pre><code class="language-crystal">def foo(*args : Int32)
end

def foo(*args : String)
end

foo 1, 2, 3       # OK, invokes first overload
foo &quot;a&quot;, &quot;b&quot;, &quot;c&quot; # OK, invokes second overload
foo 1, 2, &quot;hello&quot; # Error
foo()             # Error
</code></pre>
<p>When specifying a type, all elements in a tuple must match that type. Additionally, the empty-tuple doesn't match any of the above cases. If you want to support the empty-tuple case, add another overload:</p>
<pre><code class="language-crystal">def foo
  # This is the empty-tuple case
end
</code></pre>
<p>A simple way to match against one or more elements of any type is to use <code>Object</code> as a restriction:</p>
<pre><code class="language-crystal">def foo(*args : Object)
end

foo() # Error
foo(1) # OK
foo(1, &quot;x&quot;) # OK
</code></pre>
<a class="header" href="print.html#free-variables" id="free-variables"><h2>Free variables</h2></a>
<p>You can make a type restriction take the type of an argument, or part of the type of an argument, using <code>forall</code>:</p>
<pre><code class="language-crystal">def foo(x : T) forall T
  T
end

foo(1)       #=&gt; Int32
foo(&quot;hello&quot;) #=&gt; String
</code></pre>
<p>That is, <code>T</code> becomes the type that was effectively used to instantiate the method.</p>
<p>A free variable can be used to extract the type parameter of a generic type within a type restriction:</p>
<pre><code class="language-crystal">def foo(x : Array(T)) forall T
  T
end

foo([1, 2])   #=&gt; Int32
foo([1, &quot;a&quot;]) #=&gt; (Int32 | String)
</code></pre>
<p>To create a method that accepts a type name, rather than an instance of a type, append <code>.class</code> to a free variable in the type restriction:</p>
<pre><code class="language-crystal">def foo(x : T.class) forall T
  Array(T)
end

foo(Int32)  #=&gt; Array(Int32)
foo(String) #=&gt; Array(String)
</code></pre>
<p>Multiple free variables can be specified too, for matching types of multiple arguments:</p>
<pre><code class="language-crystal">def push(element : T, array : Array(T)) forall T
  array &lt;&lt; element
end

push(4, [1, 2, 3]) # OK
push(&quot;oops&quot;, [1, 2, 3]) # Error
</code></pre>
<a class="header" href="print.html#return-types" id="return-types"><h1>Return types</h1></a>
<p>A method's return type is always inferred by the compiler. However, you might want to specify it for two reasons:</p>
<ol>
<li>To make sure that the method returns the type that you want</li>
<li>To make it appear in documentation comments</li>
</ol>
<p>For example:</p>
<pre><code class="language-crystal">def some_method : String
  &quot;hello&quot;
end
</code></pre>
<p>The return type follows the <a href="type_grammar.html">type grammar</a>.</p>
<a class="header" href="print.html#nil-return-type" id="nil-return-type"><h2>Nil return type</h2></a>
<p>Marking a method as returning <code>Nil</code> will make it return <code>nil</code> regardless of what it actually returns:</p>
<pre><code class="language-crystal">def some_method : Nil
  1 + 2
end

some_method # =&gt; nil
</code></pre>
<p>This is useful for two reasons:</p>
<ol>
<li>Making sure a method returns <code>nil</code> without needing to add an extra <code>nil</code> at the end, or at every return point</li>
<li>Documenting that the method's return value is of no interest</li>
</ol>
<p>These methods usually imply a side effect.</p>
<p>Using <code>Void</code> is the same, but <code>Nil</code> is more idiomatic: <code>Void</code> is preferred in C bindings.</p>
<a class="header" href="print.html#noreturn-return-type" id="noreturn-return-type"><h2>NoReturn return type</h2></a>
<p>Some expressions won't return to the current scope and therefore have no return type. This is expressed as the special return type <code>NoReturn</code>.</p>
<p>Typical examples for non-returning methods and keywords are <code>return</code>, <code>exit</code>, <code>raise</code>, <code>next</code>, and <code>break</code>.</p>
<p>This is for example useful for deconstructing union types:</p>
<pre><code>string = STDIN.gets
typeof(string)                        # =&gt; String?
typeof(raise &quot;Empty input&quot;)           # =&gt; NoReturn
typeof(string || raise &quot;Empty input&quot;) # =&gt; String
</code></pre>
<p>The compiler recognizes that in case <code>string</code> is <code>Nil</code>, the right hand side of the expression <code>string || raise</code> will be evaluated. Since <code>typeof(raise &quot;Empty input&quot;)</code> is <code>NoReturn</code> the execution would not return to the current scope in that case. That leaves only <code>String</code> as resulting type of the expression.</p>
<p>Every expression whose code paths all result in <code>NoReturn</code> will be <code>NoReturn</code> as well. <code>NoReturn</code> does not show up in a union type because it would essentially be included in every expression's type. It is only used when an expression will never return to the current scope.</p>
<p><code>NoReturn</code> can be explicitly set as return type of a method or function definition but will usually be inferred by the compiler.</p>
<a class="header" href="print.html#method-arguments" id="method-arguments"><h1>Method arguments</h1></a>
<p>This is the formal specification of method and call arguments.</p>
<a class="header" href="print.html#components-of-a-method-definition" id="components-of-a-method-definition"><h2>Components of a method definition</h2></a>
<p>A method definition consists of:</p>
<ul>
<li>required and optional positional arguments</li>
<li>an optional splat argument, whose name can be empty</li>
<li>required and optional named arguments</li>
<li>an optional double splat argument</li>
</ul>
<p>For example:</p>
<pre><code class="language-crystal">def foo(
  # These are positional arguments:
  x, y, z = 1,
  # This is the splat argument:
  *args,
  # These are the named arguments:
  a, b, c = 2,
  # This is the double splat argument:
  **options
  )
end
</code></pre>
<p>Each one of them is optional, so a method can do without the double splat, without the splat, without keyword arguments and without positional arguments.</p>
<a class="header" href="print.html#components-of-a-method-call" id="components-of-a-method-call"><h2>Components of a method call</h2></a>
<p>A method call also has some parts:</p>
<pre><code class="language-crystal">foo(
  # These are positional arguments
  1, 2,
  # These are named arguments
  a: 1, b: 2
)
</code></pre>
<p>Additionally, a call argument can have a splat (<code>*</code>) or double splat (<code>**</code>). A splat expands a <a href="literals/tuple.html">Tuple</a> into positional arguments, while a double splat expands a <a href="literals/named_tuple.html">NamedTuple</a> into named arguments. Multiple argument splats and double splats are allowed.</p>
<a class="header" href="print.html#how-call-arguments-are-matched-to-method-arguments" id="how-call-arguments-are-matched-to-method-arguments"><h2>How call arguments are matched to method arguments</h2></a>
<p>When invoking a method, the algorithm to match call arguments to method arguments is:</p>
<ul>
<li>First positional arguments are matched with positional method arguments. The number of these must be at least the number of positional arguments without a default value. If there's a splat method argument with a name (the case without a name is explained below), more positional arguments are allowed and they are captured as a tuple. Positional arguments never match past the splat method argument.</li>
<li>Then named arguments are matched, by name, with any argument in the method (it can be before or after the splat method argument). If an argument was already filled by a positional argument then it's an error.</li>
<li>Extra named arguments are placed in the double splat method argument, as a <a href="literals/named_tuple.html">NamedTuple</a>, if it exists, otherwise it's an error.</li>
</ul>
<p>When a splat method argument has no name, it means no more positional arguments can be passed, and next arguments must be passed as named arguments. For example:</p>
<pre><code class="language-crystal"># Only one positional argument allowed, y must be passed as a named argument
def foo(x, *, y)
end

foo 1 # Error, missing argument: y
foo 1, 2 # Error: wrong number of arguments (given 2, expected 1)
foo 1, y: 10 # OK
</code></pre>
<p>But even if a splat method argument has a name, arguments that follow it must be passed as named arguments:</p>
<pre><code class="language-crystal"># One or more positional argument allowed, y must be passed as a named argument
def foo(x, *args, y)
end

foo 1 # Error, missing argument: y
foo 1, 2 # Error: missing argument; y
foo 1, 2, 3 # Error: missing argument: y
foo 1, y: 10 # OK
foo 1, 2, 3, y: 4 # OK
</code></pre>
<p>There's also the possibility of making a method only receive named arguments (and list them), by placing the star at the beginning:</p>
<pre><code class="language-crystal"># A method with two required named arguments: x and y
def foo(*, x, y)
end

foo # Error: missing arguments: x, y
foo x: 1 # Error: missing argument: y
foo x: 1, y: 2 # OK
</code></pre>
<p>Arguments past the star can also have default values. It means: they must be passed as named arguments, but they aren't required (so: optional named arguments):</p>
<pre><code class="language-crystal"># A method with two required named arguments: x and y
def foo(*, x, y = 2)
end

foo # Error: missing argument: x
foo x: 1 # OK, y is 2
foo x: 1, y: 3 # OK, y is 3
</code></pre>
<p>Because arguments (without a default value) after the splat method argument must be passed by name, two methods with different required named arguments overload:</p>
<pre><code class="language-crystal">def foo(*, x)
  puts &quot;Passed with x: #{x}&quot;
end

def foo(*, y)
  puts &quot;Passed with y: #{y}&quot;
end

foo x: 1 # =&gt; Passed with x: 1
foo y: 2 # =&gt; Passed with y: 2
</code></pre>
<p>Positional arguments can always be matched by name:</p>
<pre><code class="language-crystal">def foo(x, *, y)
end

foo 1, y: 2 # OK
foo y: 2, x: 3 # OK
</code></pre>
<a class="header" href="print.html#external-names" id="external-names"><h2>External names</h2></a>
<p>An external name can be specified for a method argument. The external name is the one used when passing an argument as a named argument, and the internal name is the one used inside the method definition:</p>
<pre><code class="language-crystal">def foo(external_name internal_name)
  # here we use internal_name
end

foo external_name: 1
</code></pre>
<p>This covers two uses cases.</p>
<p>The first use case is using keywords as named arguments:</p>
<pre><code class="language-crystal">def plan(begin begin_time, end end_time)
  puts &quot;Planning between #{begin_time} and #{end_time}&quot;
end

plan begin: Time.now, end: 2.days.from_now
</code></pre>
<p>The second use case is making a method argument more readable inside a method body:</p>
<pre><code class="language-crystal">def increment(value, by)
  # OK, but reads odd
  value + by
end

def increment(value, by amount)
  # Better
  value + amount
end
</code></pre>
<a class="header" href="print.html#a操作符" id="a操作符"><h1>操作符</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/operators.md">syntax_and_semantics/operators.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/45485f2aa890b84587571fd343d1c4f5b87e9361">commit 45485f2aa890b84587571fd343d1c4f5b87e9361</a></p>
</blockquote>
<p>像 <code>+</code> 和 <code>-</code> 这样的操作符都是正常的方法调用。例如：</p>
<pre><code class="language-crystal">a + b
</code></pre>
<p>is the same as:</p>
<pre><code class="language-crystal">a.+(b)
</code></pre>
<p>可以像下面这样为一个类型定义一个操作符：</p>
<pre><code class="language-crystal">struct Vector2
  getter x, y

  def initialize(@x : Int32, @y : Int32)
  end

  def +(other)
    Vector2.new(x + other.x, y + other.y)
  end
end

v1 = Vector2.new(1, 2)
v2 = Vector2.new(3, 4)
v1 + v2               #=&gt; Vector2(@x=4, @y=6)
</code></pre>
<p>下面是所有操作符的列表以及其通用含义。</p>
<a class="header" href="print.html#a一元操作符" id="a一元操作符"><h2>一元操作符</h2></a>
<pre><code class="language-crystal">+   # 正号
-   # 负号
!   # 非
~   # 按位求补
</code></pre>
<p>其都是无参定义。例如</p>
<pre><code class="language-crystal">struct Vector2
  def -
    Vector2.new(-x, -y)
  end
end

v1 = Vector2.new(1, 2)
-v1                    #=&gt; Vector2(@x=-1, @y=-2)
</code></pre>
<p><strong>注意:</strong> <code>!</code> （非）无法定义为一个方法（其意义不可更改）。</p>
<a class="header" href="print.html#a二元操作符" id="a二元操作符"><h2>二元操作符</h2></a>
<ul>
<li><code>+</code> – 加法</li>
<li><code>-</code> – 减法</li>
<li><code>*</code> – 乘法</li>
<li><code>/</code> – 除法</li>
<li><code>%</code> – 取模</li>
<li><code>&amp;</code> – 按位与</li>
<li><code>|</code> – 按位或</li>
<li><code>^</code> – 按位异或</li>
<li><code>**</code> – 指数运算</li>
<li><code>&lt;&lt;</code> – 左移，追加</li>
<li><code>&gt;&gt;</code> – 右移</li>
<li><code>==</code> – 等于</li>
<li><code>!=</code> – 不等于</li>
<li><code>&lt;</code> – 小于</li>
<li><code>&lt;=</code> – 小于等于</li>
<li><code>&gt;</code> – 大于</li>
<li><code>&gt;=</code> – 大于等于</li>
<li><code>&lt;=&gt;</code> – 比较</li>
<li><code>===</code> – <a href="case.html">真实等于</a></li>
</ul>
<a class="header" href="print.html#a索引" id="a索引"><h2>索引</h2></a>
<pre><code class="language-crystal">[]  # 数组索引（越界抛异常）
[]? # 数组索引（越界返回 nil）
[]= # 数组索引赋值
</code></pre>
<p>例如：</p>
<pre><code class="language-crystal">class MyArray
  def [](index)
    # ...
  end

  def [](index1, index2, index3)
    # ...
  end

  def []=(index, value)
    # ...
  end
end

array = MyArray.new

array[1]       # invokes the first method
array[1, 2, 3] # invokes the second method
array[1] = 2   # invokes the third method

array.[](1)       # invokes the first method
array.[](1, 2, 3) # invokes the second method
array.[]=(1, 2)   # invokes the third method
</code></pre>
<a class="header" href="print.html#a意义" id="a意义"><h2>意义</h2></a>
<p>可以为操作符赋予任何意义，但遵从上面所列方便于避免隐晦的或异常行为的代码。</p>
<a class="header" href="print.html#a可见性" id="a可见性"><h1>可见性</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/visibility.md">syntax_and_semantics/visibility.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/f510983efc4bd9579c56ecbce5df5b96d54b11b6">commit f510983efc4bd9579c56ecbce5df5b96d54b11b6</a></p>
</blockquote>
<p>方法默认是共有的：编译器总允许调用方法，即使没有 <code>public</code> 关键字。</p>
<p>可以将方法标记为 <code>private</code> 或 <code>protected</code> 。</p>
<a class="header" href="print.html#a私有方法" id="a私有方法"><h2>私有方法</h2></a>
<p>私有方法只可以被一个非接收者调用，也就是说，在点号之前无任何东西：</p>
<pre><code class="language-crystal">class Person
  private def say(message)
    puts message
  end

  def say_hello
    say &quot;hello&quot; # OK, no receiver
    self.say &quot;hello&quot; # Error, self is a receiver

    other = Person.new &quot;Other&quot;
    other.say &quot;hello&quot; # Error, other is a receiver
  end
end
</code></pre>
<p>注意 <code>private</code> 方法是可以被子类访问的：</p>
<pre><code class="language-crystal">class Employee &lt; Person
  def say_bye
    say &quot;bye&quot; # OK
  end
end
</code></pre>
<a class="header" href="print.html#a私有类型" id="a私有类型"><h2>私有类型</h2></a>
<p>私有类型只可以在其定义的命名空间内部引用。</p>
<pre><code class="language-crystal">class Foo
  private class Bar
  end

  Bar      # OK
  Foo::Bar # Error
end

Foo::Bar # Error
</code></pre>
<p><code>private</code> 可以用于 <code>class</code> 、 <code>module</code> 、 <code>lib</code> 、 <code>enum</code> 、 <code>alias</code> 以及常量：</p>
<pre><code class="language-crystal">class Foo
  private ONE = 1

  ONE # =&gt; 1
end

Foo::ONE # Error
</code></pre>
<a class="header" href="print.html#protected-方法" id="protected-方法"><h2>protected 方法</h2></a>
<p>一个<code>protected</code> 方法只可以被下面两种请况下调用：</p>
<ol>
<li>与当前类型相同类型的实例</li>
<li>与当前类型在同一命名空间内的实例 （ class 、 struct 、 module 等）</li>
</ol>
<pre><code class="language-crystal">### Example of 1

class Person
  protected def say(message)
    puts message
  end

  def say_hello
    say &quot;hello&quot; # OK, implicit self is a Person
    self.say &quot;hello&quot; # OK, self is a Person

    other = Person.new &quot;Other&quot;
    other.say &quot;hello&quot; # OK, other is a Person
  end
end

class Animal
  def make_a_person_talk
    person = Person.new
    person.say &quot;hello&quot; # Error, person is a Person
                       # but current type is an Animal
  end
end

one_more = Person.new &quot;One more&quot;
one_more.say &quot;hello&quot; # Error, one_more is a Person
                     # but current type is the Program

### Example of 2

module Namespace
  class Foo
    protected def foo
      puts &quot;Hello&quot;
    end
  end

  class Bar
    def bar
      # Works, because Foo and Bar are under Namespace
      Foo.new.foo
    end
  end
end

Namespace::Bar.new.bar
</code></pre>
<p><code>protected</code> 类方法可以在一个实例方法中调用：</p>
<pre><code class="language-crystal">class Person
  protected def self.say(message)
    puts message
  end

  def say_hello
    Person.say &quot;hello&quot; # OK
  end
end
</code></pre>
<a class="header" href="print.html#a私有顶级方法" id="a私有顶级方法"><h2>私有顶级方法</h2></a>
<p>一个 <code>private</code> 的顶级方法只可以在当前文件中被访问。</p>
<pre><code class="language-crystal"># In file one.cr
private def greet
  puts &quot;Hello&quot;
end

greet #=&gt; &quot;Hello&quot;

# In file two.cr
require &quot;./one&quot;

greet # undefined local variable or method 'greet'
</code></pre>
<p>这可以在一个文件中定义只为该文件所知的辅助方法。</p>
<a class="header" href="print.html#a私有顶级类型" id="a私有顶级类型"><h2>私有顶级类型</h2></a>
<p>一个 <code>private</code> 的顶级类型只能在当前文件中被访问。</p>
<pre><code class="language-crystal"># In file one.cr
private class Greeter
  def self.greet
    &quot;Hello&quot;
  end
end

Greeter.greet #=&gt; &quot;Hello&quot;

# In file two.cr
require &quot;./one&quot;

Greeter.greet # undefined constant 'Greeter'
</code></pre>
<a class="header" href="print.html#a继承" id="a继承"><h1>继承</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/inheritance.md">syntax_and_semantics/inheritance.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/a32014850bb26937bcee0e2f969e66cb81616cb1">commit a32014850bb26937bcee0e2f969e66cb81616cb1</a></p>
</blockquote>
<p>除了层次的根 <code>Object</code> 类，每一个类都是从另一个类（该类的父类）继承而来。如果不特别指明，其默认是类的 <code>Reference</code> 和结构体的 <code>Struct</code> 。</p>
<p>类继承其父类的所有实例变量以及所有实例方法和类方法，包括其构造器（ <code>new</code> 和 <code>initialize</code> ）。</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
  end

  def greet
    puts &quot;Hi, I'm #{@name}&quot;
  end
end

class Employee &lt; Person
end

employee = Employee.new &quot;John&quot;
employee.greet # &quot;Hi, I'm John&quot;
</code></pre>
<p>如果类定义了 <code>new</code> 或  <code>initialize</code> 方法，则其父类的构造器不会被继承：</p>
<pre><code class="language-crystal">class Person
  def initialize(@name : String)
  end
end

class Employee &lt; Person
  def initialize(@name : String, @company_name : String)
  end
end

Employee.new &quot;John&quot;, &quot;Acme&quot; # OK
Employee.new &quot;Peter&quot; # Error: wrong number of arguments
                     # for 'Employee:Class#new' (1 for 2)
</code></pre>
<p>可以在派生类中覆盖方法：</p>
<pre><code class="language-crystal">class Person
  def greet(msg)
    puts &quot;Hi, #{msg}&quot;
  end
end

class Employee &lt; Person
  def greet(msg)
    puts &quot;Hello, #{msg}&quot;
  end
end

p = Person.new
p.greet &quot;everyone&quot; # &quot;Hi, everyone&quot;

e = Employee.new
e.greet &quot;everyone&quot; # &quot;Hello, everyone&quot;
</code></pre>
<p>除了覆盖，也可以用保留类型来定义特定的方法：</p>
<pre><code class="language-crystal">class Person
  def greet(msg)
    puts &quot;Hi, #{msg}&quot;
  end
end

class Employee &lt; Person
  def greet(msg : Int32)
    puts &quot;Hi, this is a number: #{msg}&quot;
  end
end

e = Employee.new
e.greet &quot;everyone&quot; # &quot;Hi, everyone&quot;

e.greet 1 # &quot;Hi, this is a number: 1&quot;
</code></pre>
<a class="header" href="print.html#super" id="super"><h2>super</h2></a>
<p>可以用  <code>super</code> 来调用父类的方法：</p>
<pre><code class="language-crystal">class Person
  def greet(msg)
    puts &quot;Hello, #{msg}&quot;
  end
end

class Employee &lt; Person
  def greet(msg)
    super # Same as: super(msg)
    super(&quot;another message&quot;)
  end
end
</code></pre>
<p>不待参数和括号的 <code>super</code> 接收和方法相同的参数。否则，接收所传递给它的参数。</p>
<a class="header" href="print.html#virtual-and-abstract-types" id="virtual-and-abstract-types"><h1>Virtual and abstract types</h1></a>
<p>When a variable's type combines different types under the same class hierarchy, its type becomes a <strong>virtual type</strong>. This applies to every class and struct except for <code>Reference</code>, <code>Value</code>, <code>Int</code> and <code>Float</code>. An example:</p>
<pre><code class="language-crystal">class Animal
end

class Dog &lt; Animal
  def talk
    &quot;Woof!&quot;
  end
end

class Cat &lt; Animal
  def talk
    &quot;Miau&quot;
  end
end

class Person
  getter pet

  def initialize(@name : String, @pet : Animal)
  end
end

john = Person.new &quot;John&quot;, Dog.new
peter = Person.new &quot;Peter&quot;, Cat.new
</code></pre>
<p>If you compile the above program with the <code>tool hierarchy</code> command you will see this for <code>Person</code>:</p>
<pre><code>- class Object
  |
  +- class Reference
     |
     +- class Person
            @name : String
            @pet : Animal+
</code></pre>
<p>You can see that <code>@pet</code> is <code>Animal+</code>. The <code>+</code> means it's a virtual type, meaning &quot;any class that inherits from <code>Animal</code>, including <code>Animal</code>&quot;.</p>
<p>The compiler will always resolve a type union to a virtual type if they are under the same hierarchy:</p>
<pre><code>if some_condition
  pet = Dog.new
else
  pet = Cat.new
end

# pet : Animal+
</code></pre>
<p>The compiler will always do this for classes and structs under the same hierarchy: it will find the first superclass from which all types inherit from (excluding <code>Reference</code>, <code>Value</code>, <code>Int</code> and <code>Float</code>). If it can't find one, the type union remains.</p>
<p>The real reason the compiler does this is to be able to compile programs faster by not creating all kinds of different similar unions, also making the generated code smaller in size. But, on the other hand, it makes sense: classes under the same hierarchy should behave in a similar way.</p>
<p>Lets make John's pet talk:</p>
<pre><code class="language-crystal">john.pet.talk # Error: undefined method 'talk' for Animal
</code></pre>
<p>We get an error because the compiler now treats <code>@pet</code> as an <code>Animal+</code>, which includes <code>Animal</code>. And since it can't find a <code>talk</code> method on it, it errors.</p>
<p>What the compiler doesn't know is that for us, <code>Animal</code> will never be instantiated as it doesn't make sense to instantiate one. We have a way to tell the compiler so by marking the class as <code>abstract</code>:</p>
<pre><code class="language-crystal">abstract class Animal
end
</code></pre>
<p>Now the code compiles:</p>
<pre><code class="language-crystal">john.pet.talk #=&gt; &quot;Woof!&quot;
</code></pre>
<p>Marking a class as abstract will also prevent us from creating an instance of it:</p>
<pre><code class="language-crystal">Animal.new # Error: can't instantiate abstract class Animal
</code></pre>
<p>To make it more explicit that an <code>Animal</code> must define a <code>talk</code> method, we can add it to <code>Animal</code> as an abstract method:</p>
<pre><code class="language-crystal">abstract class Animal
  # Makes this animal talk
  abstract def talk
end
</code></pre>
<p>By marking a method as <code>abstract</code> the compiler will check that all subclasses implement this method, even if a program doesn't use them.</p>
<p>Abstract methods can also be defined in modules, and the compiler will check that including types implement them.</p>
<a class="header" href="print.html#a类方法" id="a类方法"><h1>类方法</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/class_methods.md">syntax_and_semantics/class_methods.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/25b85d805ea5650c761308e282e8606cc3635560">commit 25b85d805ea5650c761308e282e8606cc3635560</a></p>
</blockquote>
<p>类方法是与类或模块而非特定实例相关联的方法。</p>
<pre><code class="language-crystal">module CaesarCipher
  def self.encrypt(string : String)
    string.chars.map{ |char| ((char.upcase.ord - 52) % 26 + 65).chr }.join
  end
end

CaesarCipher.encrypt(&quot;HELLO&quot;) # =&gt; &quot;URYYB&quot;
</code></pre>
<p>类方法由方法名和一个带逗点的类型名定义。</p>
<pre><code class="language-crystal">def CaesarCipher.decrypt(string : String)
  encrypt(string)
end
</code></pre>
<p>当类方法定义在类或模块内部时，使用 <code>self</code> 要比类名更方便。</p>
<p>类方法也可以由<a href="modules.md#extend-self"><code>模块</code>扩展</a>来定义。</p>
<p>类方法可以在其定义的同名之下调用(<code>CaesarCipher.decrypt(&quot;HELLO&quot;)</code>)。</p>
<p>当在相同类或模块范围内调用类方法时，接收者可以是 <code>self</code> 或隐式调用 （如<code>encrypt(string)</code>）。</p>
<a class="header" href="print.html#a构造器" id="a构造器"><h1>构造器</h1></a>
<p>构造器是常规类方法，其可以<a href="new,_initialize_and_allocate.md">创建类的新实例</a>。
Crystal 中所有的类默认至少有一个名为 <code>new</code> 的构造器，但也可以以不同的名字定义其他的构造器。</p>
<a class="header" href="print.html#a类变量" id="a类变量"><h1>类变量</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/class_variables.md">syntax_and_semantics/class_variables.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/f3435e1d16811195be4b05c478e8a542f5de5365">commit f3435e1d16811195be4b05c478e8a542f5de5365</a></p>
</blockquote>
<p>类变量是和类而不是实例有关的变量。其以两个 “at”（ <code>@@</code> ）符号作为前缀。例如：</p>
<pre><code class="language-crystal">class Counter
  @@instances = 0

  def initialize
    @@instances += 1
  end

  def self.instances
    @@instances
  end
end

Counter.instances #=&gt; 0
Counter.new
Counter.new
Counter.new
Counter.instances #=&gt; 3
</code></pre>
<p>可以在类方法或实例方法中读写类变量。</p>
<p>类变量的类型使用<a href="type_inference.html">全局类型推断算法</a>来猜测。</p>
<p>类变量从父类中继承，这意味着：其类型相同，但每个类都有不同的运行时值。例如：</p>
<pre><code class="language-crystal">class Parent
  @@numbers = [] of Int32

  def self.numbers
    @@numbers
  end
end

class Child &lt; Parent
end

Parent.numbers # =&gt; []
Child.numbers # =&gt; []

Parent.numbers &lt;&lt; 1
Parent.numbers # =&gt; [1]
Child.numbers # =&gt; []
</code></pre>
<p>类变量也可以关联模块或结构体。和上面一样，他们继承自导入类型或父类类型。</p>
<a class="header" href="print.html#finalize" id="finalize"><h1>finalize</h1></a>
<p>If a class defines a <code>finalize</code> method, when an instance of that class is
garbage-collected that method will be invoked:</p>
<pre><code class="language-crystal">class Foo
  def finalize
    # Invoked when Foo is garbage-collected
    # Use to release non-managed resources (ie. C libraries, structs)
  end
end
</code></pre>
<p>Use this method to release resources allocated by external libraries that are
not directly managed by Crystal garbage collector.</p>
<p>Examples of this can be found in <a href="https://crystal-lang.org/api/IO/FileDescriptor.html#finalize-instance-method"><code>IO::FileDescriptor#finalize</code></a>
or <a href="https://crystal-lang.org/api/OpenSSL/Digest.html#finalize-instance-method"><code>OpenSSL::Digest#finalize</code></a>.</p>
<p><strong>Notes</strong>:</p>
<ul>
<li>
<p>The <code>finalize</code> method will only be invoked once the object has been
fully initialized via the <code>initialize</code> method. If an exception is raised
inside the <code>initialize</code> method, <code>finalize</code> won't be invoked. If your class
defines a <code>finalize</code> method, be sure to catch any exceptions that might be
raised in the <code>initialize</code> methods and free resources.</p>
</li>
<li>
<p>Allocating any new object instances during garbage-collection might result
in undefined behavior and most likely crashing your program.</p>
</li>
</ul>
<a class="header" href="print.html#modules" id="modules"><h1>Modules</h1></a>
<p>Modules serve two purposes:</p>
<ul>
<li>as namespaces for defining other types, methods and constants</li>
<li>as partial types that can be mixed in other types</li>
</ul>
<p>An example of a module as a namespace:</p>
<pre><code class="language-crystal">module Curses
  class Window
  end
end

Curses::Window.new
</code></pre>
<p>Library authors are advised to put their definitions inside a module to avoid name clashes. The standard library usually doesn't have a namespace as its types and methods are very common, to avoid writing long names.</p>
<p>To use a module as a partial type you use <code>include</code> or <code>extend</code>.</p>
<p>An <code>include</code> makes a type include methods defined in that module as instance methods:</p>
<pre><code class="language-crystal">module ItemsSize
  def size
    items.size
  end
end

class Items
  include ItemsSize

  def items
    [1, 2, 3]
  end
end

items = Items.new
items.size #=&gt; 3
</code></pre>
<p>In the above example, it is as if we pasted the <code>size</code> method from the module into the <code>Items</code> class. The way this really works is by making each type have a list of ancestors, or parents. By default this list starts with the superclass. As modules are included they are <strong>prepended</strong> to this list. When a method is not found in a type it is looked up in this list. When you invoke <code>super</code>, the first type in this ancestors list is used.</p>
<p>A <code>module</code> can include other modules, so when a method is not found in it it will be looked up in the included modules.</p>
<p>An <code>extend</code> makes a type include methods defined in that module as class methods:</p>
<pre><code class="language-crystal">module SomeSize
  def size
    3
  end
end

class Items
  extend SomeSize
end

Items.size #=&gt; 3
</code></pre>
<p>Both <code>include</code> and <code>extend</code> make constants defined in the module available to the including/extending type.</p>
<p>Both of them can be used at the top level to avoid writing a namespace over and over (although the chances of name clashes increase):</p>
<pre><code class="language-crystal">module SomeModule
  class SomeType
  end

  def some_method
    1
  end
end

include SomeModule

SomeType.new # OK, same as SomeModule::SomeType
some_method  # OK, 1
</code></pre>
<a class="header" href="print.html#extend-self" id="extend-self"><h2>extend self</h2></a>
<p>A common pattern for modules is <code>extend self</code>:</p>
<pre><code class="language-crystal">module Base64
  extend self

  def encode64(string)
    # ...
  end

  def decode64(string)
    # ...
  end
end
</code></pre>
<p>In this way a module can be used as a namespace:</p>
<pre><code class="language-crystal">Base64.encode64 &quot;hello&quot; #=&gt; &quot;aGVsbG8=&quot;
</code></pre>
<p>But also it can be included in the program and its methods can be invoked without a namespace:</p>
<pre><code class="language-crystal">include Base64

encode64 &quot;hello&quot; #=&gt; &quot;aGVsbG8=&quot;
</code></pre>
<p>For this to be useful the method name should have some reference to the module, otherwise chances of name clashes are high.</p>
<p>A module cannot be instantiated:</p>
<pre><code class="language-crystal">module Moo
end

Moo.new # undefined method 'new' for Moo:Class
</code></pre>
<a class="header" href="print.html#generics" id="generics"><h1>Generics</h1></a>
<p>Generics allow you to parameterize a type based on other type. Consider a Box type:</p>
<pre><code class="language-crystal">class MyBox(T)
  def initialize(@value : T)
  end

  def value
    @value
  end
end

int_box = MyBox(Int32).new(1)
int_box.value # =&gt; 1 (Int32)

string_box = MyBox(String).new(&quot;hello&quot;)
string_box.value # =&gt; &quot;hello&quot; (String)

another_box = MyBox(String).new(1) # Error, Int32 doesn't match String
</code></pre>
<p>Generics are especially useful for implementing collection types. <code>Array</code>, <code>Hash</code>, <code>Set</code> are generic types, as is <code>Pointer</code>.</p>
<p>More than one type argument is allowed:</p>
<pre><code class="language-crystal">class MyDictionary(K, V)
end
</code></pre>
<p>Any name can be used for type arguments:</p>
<pre><code class="language-crystal">class MyDictionary(KeyType, ValueType)
end
</code></pre>
<a class="header" href="print.html#type-variables-inference" id="type-variables-inference"><h2>Type variables inference</h2></a>
<p>Type restrictions in a generic type's constructor are free variables when type arguments were not specified, and then are used to infer them. For example:</p>
<pre><code class="language-crystal">MyBox.new(1)       # : MyBox(Int32)
MyBox.new(&quot;hello&quot;) # : MyBox(String)
</code></pre>
<p>In the above code we didn't have to specify the type arguments of <code>MyBox</code>, the compiler inferred them following this process:</p>
<ul>
<li><code>MyBox.new(value)</code> delegates to <code>initialize(@value : T)</code></li>
<li><code>T</code> isn't bound to a type yet, so the compiler binds it to the type of the given argument</li>
</ul>
<p>In this way generic types are less tedious to work with.</p>
<a class="header" href="print.html#generic-structs-and-modules" id="generic-structs-and-modules"><h2>Generic structs and modules</h2></a>
<p>Structs and modules can be generic too. When a module is generic you include it like this:</p>
<pre><code class="language-crystal">module Moo(T)
  def t
    T
  end
end

class Foo(U)
  include Moo(U)

  def initialize(@value : U)
  end
end

foo = Foo.new(1)
foo.t # Int32
</code></pre>
<p>Note that in the above example <code>T</code> becomes <code>Int32</code> because <code>Foo.new(1)</code> makes <code>U</code> become <code>Int32</code>, which in turn makes <code>T</code> become <code>Int32</code> via the inclusion of the generic module.</p>
<a class="header" href="print.html#generic-types-inheritance" id="generic-types-inheritance"><h2>Generic types inheritance</h2></a>
<p>Generic classes and structs can be inherited. When inheriting you can specify an instance of the generic type, or delegate type variables:</p>
<pre><code class="language-crystal">class Parent(T)
end

class Int32Child &lt; Parent(Int32)
end

class GenericChild(T) &lt; Parent(T)
end
</code></pre>
<a class="header" href="print.html#structs" id="structs"><h1>Structs</h1></a>
<p>Instead of defining a type with <code>class</code> you can do so with <code>struct</code>:</p>
<pre><code class="language-crystal">struct Point
  property x, y

  def initialize(@x : Int32, @y : Int32)
  end
end
</code></pre>
<p>The differences between a struct and a class are:</p>
<ul>
<li>Invoking <code>new</code> on a struct allocates it on the stack instead of the heap</li>
<li>A struct is <a href="http://crystal-lang.org/api/Value.html">passed by value</a> while a class is passed by reference</li>
<li>A struct implicitly inherits from <a href="http://crystal-lang.org/api/Struct.html">Struct</a>, which inherits from <a href="http://crystal-lang.org/api/Value.html">Value</a>. A class implicitly inherits from <a href="http://crystal-lang.org/api/Reference.html">Reference</a>.</li>
<li>A struct cannot inherit a non-abstract struct.</li>
</ul>
<p>The last point has a reason to it: a struct has a very well defined memory layout. For example, the above <code>Point</code> struct occupies 8 bytes. If you have an array of points the points are embedded inside the array's buffer:</p>
<pre><code class="language-crystal"># The array's buffer will have 8 bytes dedicated to each Point
ary = [] of Point
</code></pre>
<p>If <code>Point</code> is inherited, an array of such type must also account for the fact that other types can be inside it, so the size of each element must grow to accommodate that. That is certainly unexpected. So, non-abstract structs can't be inherited. Abstract structs, on the other hand, will have descendants, so it's expected that an array of them will account for the possibility of having multiple types inside it.</p>
<p>A struct can also include modules and can be generic, just like a class.</p>
<p>A struct is mostly used for performance reasons to avoid lots of small memory allocations when passing small copies might be more efficient.</p>
<p>So how do you choose between a struct and a class? The rule of thumb is that if no instance variable is ever reassigned, i.e. your type is immutable, you could use a struct, otherwise use a class.</p>
<a class="header" href="print.html#constants" id="constants"><h1>Constants</h1></a>
<p>Constants can be declared at the top level or inside other types. They must start with a capital letter:</p>
<pre><code class="language-crystal">PI = 3.14

module Earth
  RADIUS = 6_371_000
end

PI #=&gt; 3.14
Earth::RADIUS #=&gt; 6_371_000
</code></pre>
<p>Although not enforced by the compiler, constants are usually named with all capital letters and underscores to separate words.</p>
<p>A constant definition can invoke methods and have complex logic:</p>
<pre><code class="language-crystal">TEN = begin
  a = 0
  while a &lt; 10
    a += 1
  end
  a
end

TEN #=&gt; 10
</code></pre>
<a class="header" href="print.html#pseudo-constants" id="pseudo-constants"><h1>Pseudo Constants</h1></a>
<p>Crystal provides a few pseudo-constants which provide reflective data about the source code being executed.</p>
<p><code>__LINE__</code> is the current line number in the currently executing crystal file. When <code>__LINE__</code> is declared as the default value to a method parameter, it represents the line number at the location of the method call.</p>
<p><code>__END_LINE__</code> is the line number of the <code>end</code> of the calling block. Can only be used as a default value to a method parameter.</p>
<p><code>__FILE__</code> references the full path to the currently executing crystal file.</p>
<p><code>__DIR__</code> references the full path to the directory where the currently executing crystal file is located.</p>
<pre><code class="language-crystal"># Assuming this example code is saved at: /crystal_code/pseudo_constants.cr
#
def pseudo_constants(caller_line = __LINE__, end_of_caller = __END_LINE__)
  puts &quot;Called from line number: #{caller_line}&quot;
  puts &quot;Currently at line number: #{__LINE__}&quot;
  puts &quot;End of caller block is at: #{end_of_caller}&quot;
  puts &quot;File path is: #{__FILE__}&quot;
  puts &quot;Directory file is in: #{__DIR__}&quot;
end


begin
  pseudo_constants
end

# Program prints:
# Called from line number: 13
# Currently at line number: 5
# End of caller block is at: 14
# File path is: /crystal_code/pseudo_constants.cr
# Directory file is in: /crystal_code
</code></pre>
<a class="header" href="print.html#enums" id="enums"><h1>Enums</h1></a>
<p>An enum is a set of integer values, where each value has an associated name. For example:</p>
<pre><code class="language-crystal">enum Color
  Red
  Green
  Blue
end
</code></pre>
<p>An enum is defined with the <code>enum</code> keyword, followed by its name. The enum's body contains the values. Values start with the value <code>0</code> and are incremented by one. The default value can be overwritten:</p>
<pre><code class="language-crystal">enum Color
  Red         # 0
  Green       # 1
  Blue   = 5  # overwritten to 5
  Yellow      # 6 (5 + 1)
end
</code></pre>
<p>Each constant in the enum has the type of the enum:</p>
<pre><code class="language-crystal">Color::Red #:: Color
</code></pre>
<p>To get the underlying value you invoke <code>value</code> on it:</p>
<pre><code class="language-crystal">Color::Green.value #=&gt; 1
</code></pre>
<p>The type of the value is <code>Int32</code> by default but can be changed:</p>
<pre><code class="language-crystal">enum Color : UInt8
  Red
  Green
  Blue
end

Color::Red.value #:: UInt8
</code></pre>
<p>Only integer types are allowed as the underlying type.</p>
<p>All enums inherit from <a href="http://crystal-lang.org/api/Enum.html">Enum</a>.</p>
<a class="header" href="print.html#flags-enums" id="flags-enums"><h2>Flags enums</h2></a>
<p>An enum can be marked with the <code>@[Flags]</code> attribute. This changes the default values:</p>
<pre><code class="language-crystal">@[Flags]
enum IOMode
  Read # 1
  Write  # 2
  Async # 4
end
</code></pre>
<p>The <code>@[Flags]</code> attribute makes the first constant's value be <code>1</code>, and successive constants are multiplied by <code>2</code>.</p>
<p>Implicit constants, <code>None</code> and <code>All</code>, are automatically added to these enums, where <code>None</code> has the value <code>0</code> and <code>All</code> has the &quot;or&quot;ed value of all constants.</p>
<pre><code class="language-crystal">IOMode::None.value #=&gt; 0
IOMode::All.value  #=&gt; 7
</code></pre>
<p>Additionally, some <code>Enum</code> methods check the <code>@[Flags]</code> attribute. For example:</p>
<pre><code class="language-crystal">puts(Color::Red)                    # prints &quot;Red&quot;
puts(IOMode::Write | IOMode::Async) # prints &quot;Write, Async&quot;
</code></pre>
<a class="header" href="print.html#enums-from-integers" id="enums-from-integers"><h2>Enums from integers</h2></a>
<p>An enum can be created from an integer:</p>
<pre><code class="language-crystal">puts Color.new(1) #=&gt; prints &quot;Green&quot;
</code></pre>
<p>Values that don't correspond to an enum's constants are allowed: the value will still be of type <code>Color</code>, but when printed you will get the underlying value:</p>
<pre><code class="language-crystal">puts Color.new(10) #=&gt; prints &quot;10&quot;
</code></pre>
<p>This method is mainly intended to convert integers from C to enums in Crystal.</p>
<a class="header" href="print.html#methods" id="methods"><h2>Methods</h2></a>
<p>Just like a class or a struct, you can define methods for enums:</p>
<pre><code class="language-crystal">enum Color
  Red
  Green
  Blue

  def red?
    self == Color::Red
  end
end

Color::Red.red?  #=&gt; true
Color::Blue.red? #=&gt; false
</code></pre>
<p>Class variables are allowed, but instance variables are not.</p>
<a class="header" href="print.html#usage" id="usage"><h2>Usage</h2></a>
<p>Enums are a type-safe alternative to <a href="http://crystal-lang.org/api/Symbol.html">Symbol</a>. For example, an API's method can specify a <a href="type_restrictions.html">type restriction</a> using an enum type:</p>
<pre><code class="language-crystal">def paint(color : Color)
  case color
  when Color::Red
    # ...
  else
    # Unusual, but still can happen
    raise &quot;unknown color: #{color}&quot;
  end
end

paint Color::Red
</code></pre>
<p>The above could also be implemented with a Symbol:</p>
<pre><code class="language-crystal">def paint(color : Symbol)
  case color
  when :red
    # ...
  else
    raise &quot;unknown color: #{color}&quot;
  end
end

paint :red
</code></pre>
<p>However, if the programmer makes a typo, say <code>:reed</code>, the error will only be caught at runtime, while attempting to use <code>Color::Reed</code> will result in a compile-time error.</p>
<p>The recommended thing to do is to use enums whenever possible, only use symbols for the internal implementation of an API, and avoid symbols for public APIs. But you are free to do what you want.</p>
<a class="header" href="print.html#blocks-and-procs" id="blocks-and-procs"><h1>Blocks and Procs</h1></a>
<p>Methods can accept a block of code that is executed
with the <code>yield</code> keyword. For example:</p>
<pre><code class="language-crystal">def twice
  yield
  yield
end

twice do
  puts &quot;Hello!&quot;
end
</code></pre>
<p>The above program prints &quot;Hello!&quot; twice, once for each <code>yield</code>.</p>
<p>To define a method that receives a block, simply use <code>yield</code> inside it and the compiler will know. You can make this more evident by declaring a dummy block argument, indicated as a last argument prefixed with ampersand (<code>&amp;</code>):</p>
<pre><code class="language-crystal">def twice(&amp;block)
  yield
  yield
end
</code></pre>
<p>To invoke a method and pass a block, you use <code>do ... end</code> or <code>{ ... }</code>. All of these are equivalent:</p>
<pre><code class="language-crystal">twice() do
  puts &quot;Hello!&quot;
end

twice do
  puts &quot;Hello!&quot;
end

twice { puts &quot;Hello!&quot; }
</code></pre>
<p>The difference between using <code>do ... end</code> and <code>{ ... }</code> is that <code>do ... end</code> binds to the left-most call, while <code>{ ... }</code> binds to the right-most call:</p>
<pre><code class="language-crystal">foo bar do
  something
end

# The above is the same as
foo(bar) do
  something
end

foo bar { something }

# The above is the same as

foo(bar { something })
</code></pre>
<p>The reason for this is to allow creating Domain Specific Languages (DSLs) using <code>do ... end</code> to have them be read as plain English:</p>
<pre><code class="language-crystal">open file &quot;foo.cr&quot; do
  something
end

# Same as:
open(file(&quot;foo.cr&quot;)) do
end
</code></pre>
<p>You wouldn't want the above to be:</p>
<pre><code class="language-crystal">open(file(&quot;foo.cr&quot;) do
end)
</code></pre>
<a class="header" href="print.html#overloads" id="overloads"><h2>Overloads</h2></a>
<p>Two methods, one that yields and another that doesn't, are considered different overloads, as explained in the <a href="overloading.html">overloading</a> section.</p>
<a class="header" href="print.html#yield-arguments" id="yield-arguments"><h2>Yield arguments</h2></a>
<p>The <code>yield</code> expression is similar to a call and can receive arguments. For example:</p>
<pre><code class="language-crystal">def twice
  yield 1
  yield 2
end

twice do |i|
  puts &quot;Got #{i}&quot;
end
</code></pre>
<p>The above prints &quot;Got 1&quot; and &quot;Got 2&quot;.</p>
<p>A curly braces notation is also available:</p>
<pre><code class="language-crystal">twice { |i| puts &quot;Got #{i}&quot; }
</code></pre>
<p>You can <code>yield</code> many values:</p>
<pre><code class="language-crystal">def many
  yield 1, 2, 3
end

many do |x, y, z|
  puts x + y + z
end

# Output: 6
</code></pre>
<p>A block can specify less than the arguments yielded:</p>
<pre><code class="language-crystal">def many
  yield 1, 2, 3
end

many do |x, y|
  puts x + y
end

# Output: 3
</code></pre>
<p>It's an error specifying more block arguments than those yielded:</p>
<pre><code class="language-crystal">def twice
  yield
  yield
end

twice do |i| # Error: too many block arguments
end
</code></pre>
<p>Each block variable has the type of every yield expression in that position. For example:</p>
<pre><code class="language-crystal">def some
  yield 1, 'a'
  yield true, &quot;hello&quot;
  yield 2, nil
end

some do |first, second|
  # first is Int32 | Bool
  # second is Char | String | Nil
end
</code></pre>
<p>The block variable <code>second</code> also includes the <code>Nil</code> type because the last <code>yield</code> expression didn't include a second argument.</p>
<a class="header" href="print.html#short-one-argument-syntax" id="short-one-argument-syntax"><h2>Short one-argument syntax</h2></a>
<p>A short syntax exists for specifying a block that receives a single argument and invokes a method on it. This:</p>
<pre><code class="language-crystal">method do |argument|
  argument.some_method
end
</code></pre>
<p>Can be written as this:</p>
<pre><code class="language-crystal">method &amp;.some_method
</code></pre>
<p>Or like this:</p>
<pre><code class="language-crystal">method(&amp;.some_method)
</code></pre>
<p>The above is just syntax sugar and doesn't have any performance penalty.</p>
<p>Arguments can be passed to <code>some_method</code> as well:</p>
<pre><code class="language-crystal">method &amp;.some_method(arg1, arg2)
</code></pre>
<p>And operators can be invoked too:</p>
<pre><code class="language-crystal">method &amp;.+(2)
method &amp;.[index]
</code></pre>
<a class="header" href="print.html#yield-value" id="yield-value"><h2>yield value</h2></a>
<p>The <code>yield</code> expression itself has a value: the last expression of the block. For example:</p>
<pre><code class="language-crystal">def twice
  v1 = yield 1
  puts v1

  v2 = yield 2
  puts v2
end

twice do |i|
  i + 1
end
</code></pre>
<p>The above prints &quot;2&quot; and &quot;3&quot;.</p>
<p>A <code>yield</code> expression's value is mostly useful for transforming and filtering values. The best examples of this are <a href="http://crystal-lang.org/api/Enumerable.html#map%28%26block%20%3A%20T%20-%3E%20U%29-instance-method">Enumerable#map</a> and <a href="http://crystal-lang.org/api/Enumerable.html#select%28%26block%20%3A%20T%20-%3E%20%29-instance-method">Enumerable#select</a>:</p>
<pre><code class="language-crystal">ary = [1, 2, 3]
ary.map { |x| x + 1 }         #=&gt; [2, 3, 4]
ary.select { |x| x % 2 == 1 } #=&gt; [1, 3]
</code></pre>
<p>A dummy transformation method:</p>
<pre><code class="language-crystal">def transform(value)
  yield value
end

transform(1) { |x| x + 1 } #=&gt; 2
</code></pre>
<p>The result of the last expression is <code>2</code> because the last expression of the <code>transform</code> method is <code>yield</code>, whose value is the last expression of the block.</p>
<a class="header" href="print.html#type-restrictions-1" id="type-restrictions-1"><h2>Type restrictions</h2></a>
<p>The type of the block in a method that uses <code>yield</code> can be restricted using the <code>&amp;block</code> syntax. For example:</p>
<pre><code class="language-crystal">def transform_int(start : Int32, &amp;block : Int32 -&gt; Int32)
  result = yield start
  result * 2
end

transform_int(3) { |x| x + 2 } #=&gt; 10
transform_int(3) { |x| &quot;foo&quot; } # Error: expected block to return Int32, not String
</code></pre>
<a class="header" href="print.html#break-1" id="break-1"><h2>break</h2></a>
<p>A <code>break</code> expression inside a block exits early from the method:</p>
<pre><code class="language-crystal">def thrice
  puts &quot;Before 1&quot;
  yield 1
  puts &quot;Before 2&quot;
  yield 2
  puts &quot;Before 3&quot;
  yield 3
  puts &quot;After 3&quot;
end

thrice do |i|
  if i == 2
    break
  end
end
</code></pre>
<p>The above prints &quot;Before 1&quot; and &quot;Before 2&quot;. The <code>thrice</code> method didn't execute the <code>puts &quot;Before 3&quot;</code> expression because of the <code>break</code>.</p>
<p><code>break</code> can also accept arguments: these become the method's return value. For example:</p>
<pre><code class="language-crystal">def twice
  yield 1
  yield 2
end

twice { |i| i + 1 } #=&gt; 3
twice { |i| break &quot;hello&quot; } #=&gt; &quot;hello&quot;
</code></pre>
<p>The first call's value is 3 because the last expression of the <code>twice</code> method is <code>yield</code>, which gets the value of the block. The second call's value is &quot;hello&quot; because a <code>break</code> was performed.</p>
<p>If there are conditional breaks, the call's return value type will be a union of the type of the block's value and the type of the many <code>break</code>s:</p>
<pre><code class="language-crystal">value = twice do |i|
  if i == 1
    break &quot;hello&quot;
  end
  i + 1
end
value #:: Int32 | String
</code></pre>
<p>If a <code>break</code> receives many arguments, they are automatically transformed to a <a href="http://crystal-lang.org/api/Tuple.html">Tuple</a>:</p>
<pre><code class="language-crystal">values = twice { break 1, 2 }
values #=&gt; {1, 2}
</code></pre>
<p>If a <code>break</code> receives no arguments, it's the same as receiving a single <code>nil</code> argument:</p>
<pre><code class="language-crystal">value = twice { break }
value #=&gt; nil
</code></pre>
<a class="header" href="print.html#next-1" id="next-1"><h2>next</h2></a>
<p>The <code>next</code> expression inside a block exits early from the block (not the method). For example:</p>
<pre><code class="language-crystal">def twice
  yield 1
  yield 2
end

twice do |i|
  if i == 1
    puts &quot;Skipping 1&quot;
    next
  end

  puts &quot;Got #{i}&quot;
end

# Ouptut:
# Skipping 1
# Got 2
</code></pre>
<p>The <code>next</code> expression accepts arguments, and these give the value of the <code>yield</code> expression that invoked the block:</p>
<pre><code class="language-crystal">def twice
  v1 = yield 1
  puts v1

  v2 = yield 2
  puts v2
end

twice do |i|
  if i == 1
    next 10
  end

  i + 1
end

# Output
# 10
# 3
</code></pre>
<p>If a <code>next</code> receives many arguments, they are automaticaly transformed to a <a href="http://crystal-lang.org/api/Tuple.html">Tuple</a>. If it receives no arguments it's the same as receiving a single <code>nil</code> argument.</p>
<a class="header" href="print.html#with--yield" id="with--yield"><h2>with ... yield</h2></a>
<p>A <code>yield</code> expression can be modified, using the <code>with</code> keyword, to specify an object to use as the default receiver of method calls within the block:</p>
<pre><code class="language-crystal">class Foo
  def one
    1
  end

  def yield_with_self
    with self yield
  end

  def yield_normally
    yield
  end
end

def one
  &quot;one&quot;
end

Foo.new.yield_with_self { one } # =&gt; 1
Foo.new.yield_normally { one }  # =&gt; &quot;one&quot;
</code></pre>
<a class="header" href="print.html#unpacking-block-arguments" id="unpacking-block-arguments"><h2>Unpacking block arguments</h2></a>
<p>A block argument can specify sub-arguments enclosed in parentheses:</p>
<pre><code class="language-crystal">array = [{1, &quot;one&quot;}, {2, &quot;two&quot;}]
array.each do |(number, word)|
  puts &quot;#{number}: #{word}&quot;
end
</code></pre>
<p>The above is simply syntax sugar of this:</p>
<pre><code class="language-crystal">array = [{1, &quot;one&quot;}, {2, &quot;two&quot;}]
array.each do |arg|
  number = arg[0]
  word = arg[1]
  puts &quot;#{number}: #{word}&quot;
end
</code></pre>
<p>That means that any type that responds to <code>[]</code> with integers can be unpacked in a block argument.</p>
<a class="header" href="print.html#performance" id="performance"><h2>Performance</h2></a>
<p>When using blocks with <code>yield</code>, the blocks are <strong>always</strong> inlined: no closures, calls or function pointers are involved. This means that this:</p>
<pre><code class="language-crystal">def twice
  yield 1
  yield 2
end

twice do |i|
  puts &quot;Got: #{i}&quot;
end
</code></pre>
<p>is exactly the same as writing this:</p>
<pre><code class="language-crystal">i = 1
puts &quot;Got: #{i}&quot;
i = 2
puts &quot;Got: #{i}&quot;
</code></pre>
<p>For example, the standard library includes a <code>times</code> method on integers, allowing you to write:</p>
<pre><code class="language-crystal">3.times do |i|
  puts i
end
</code></pre>
<p>This looks very fancy, but is it as fast as a C for loop? The answer is: yes!</p>
<p>This is <code>Int#times</code> definition:</p>
<pre><code class="language-crystal">struct Int
  def times
    i = 0
    while i &lt; self
      yield i
      i += 1
    end
  end
end
</code></pre>
<p>Because a non-captured block is always inlined, the above method invocation is <strong>exactly the same</strong> as writing this:</p>
<pre><code class="language-crystal">i = 0
while i &lt; 3
  puts i
  i += 1
end
</code></pre>
<p>Have no fear using blocks for readability or code reuse, it won't affect the resulting executable performance.</p>
<a class="header" href="print.html#capturing-blocks" id="capturing-blocks"><h1>Capturing blocks</h1></a>
<p>A block can be captured and turned into a <code>Proc</code>, which represents a block of code with an associated context: the closured data.</p>
<p>To capture a block you must specify it as a method's block argument, give it a name and specify the input and output types. For example:</p>
<pre><code class="language-crystal">def int_to_int(&amp;block : Int32 -&gt; Int32)
  block
end

proc = int_to_int { |x| x + 1 }
proc.call(1) #=&gt; 2
</code></pre>
<p>The above code captures the block of code passed to <code>int_to_int</code> in the <code>block</code> variable, and returns it from the method. The type of <code>proc</code> is <a href="http://crystal-lang.org/api/Proc.html">Proc(Int32, Int32)</a>, a function that accepts a single <code>Int32</code> argument and returns an <code>Int32</code>.</p>
<p>In this way a block can be saved as a callback:</p>
<pre><code class="language-crystal">class Model
  def on_save(&amp;block)
    @on_save_callback = block
  end

  def save
    if callback = @on_save_callback
      callback.call
    end
  end
end

model = Model.new
model.on_save { puts &quot;Saved!&quot; }
model.save # prints &quot;Saved!&quot;
</code></pre>
<p>In the above example the type of <code>&amp;block</code> wasn't specified: this just means that the captured block doesn't have arguments and doesn't return anything.</p>
<p>Note that if the return type is not specified, nothing gets returned from the proc call:</p>
<pre><code class="language-crystal">def some_proc(&amp;block : Int32 -&gt;)
  block
end

proc = some_proc { |x| x + 1 }
proc.call(1) # void
</code></pre>
<p>To have something returned, either specify the return type or use an underscore to allow any return type:</p>
<pre><code class="language-crystal">def some_proc(&amp;block : Int32 -&gt; _)
  block
end

proc = some_proc { |x| x + 1 }
proc.call(1) # 2

proc = some_proc { |x| x.to_s }
proc.call(1) # &quot;1&quot;
</code></pre>
<a class="header" href="print.html#break-and-next" id="break-and-next"><h2>break and next</h2></a>
<p><code>return</code> and <code>break</code> can't be used inside a captured block. <code>next</code> can be used and will exit and give the value of the captured block.</p>
<a class="header" href="print.html#with--yield-1" id="with--yield-1"><h2>with ... yield</h2></a>
<p>The default receiver within a captured block can't be changed by using <code>with ... yield</code>.</p>
<a class="header" href="print.html#proc-literal" id="proc-literal"><h1>Proc literal</h1></a>
<p>A captured block is the same as declaring a <a href="literals/proc.html">Proc literal</a> and <a href="block_forwarding.html">passing</a> it to the method.</p>
<pre><code class="language-crystal">def some_proc(&amp;block : Int32 -&gt; Int32)
  block
end

x = 0
proc = -&gt;(i : Int32) { x += i }
proc = some_proc(&amp;proc)
proc.call(1)  #=&gt; 1
proc.call(10) #=&gt; 11
x #=&gt; 11
</code></pre>
<p>As explained in the <a href="literals/proc.html">proc literals</a> section, a Proc can also be created from existing methods:</p>
<pre><code class="language-crystal">def add(x, y)
  x + y
end

adder = -&gt;add(Int32, Int32)
adder.call(1, 2) #=&gt; 3
</code></pre>
<a class="header" href="print.html#block-forwarding" id="block-forwarding"><h1>Block forwarding</h1></a>
<p>To forward captured blocks, you use a block argument, prefixing an expression with <code>&amp;</code>:</p>
<pre><code class="language-crystal">def capture(&amp;block)
  block
end

def invoke(&amp;block)
  block.call
end

proc = capture { puts &quot;Hello&quot; }
invoke(&amp;proc) # prints &quot;Hello&quot;
</code></pre>
<p>In the above example, <code>invoke</code> receives a block. We can't pass <code>proc</code> directly to it because <code>invoke</code> doesn't receive regular arguments, just a block argument. We use <code>&amp;</code> to specify that we really want to pass <code>proc</code> as the block argument. Otherwise:</p>
<pre><code class="language-crystal">invoke(proc) # Error: wrong number of arguments for 'invoke' (1 for 0)
</code></pre>
<p>You can actually pass a proc to a method that yields:</p>
<pre><code class="language-crystal">def capture(&amp;block)
  block
end

def twice
  yield
  yield
end

proc = capture { puts &quot;Hello&quot; }
twice &amp;proc
</code></pre>
<p>The above is simply rewritten to:</p>
<pre><code class="language-crystal">proc = capture { puts &quot;Hello&quot; }
twice do
  proc.call
end
</code></pre>
<p>Or, combining the <code>&amp;</code> and <code>-&gt;</code> syntaxes:</p>
<pre><code class="language-crystal">twice &amp;-&gt;{ puts &quot;Hello&quot; }
</code></pre>
<p>Or:</p>
<pre><code class="language-crystal">def say_hello
  puts &quot;Hello&quot;
end

twice &amp;-&gt;say_hello
</code></pre>
<a class="header" href="print.html#forwarding-non-captured-blocks" id="forwarding-non-captured-blocks"><h2>Forwarding non-captured blocks</h2></a>
<p>To forward non-captured blocks, you must use <code>yield</code>:</p>
<pre><code class="language-crystal">def foo
  yield 1
end

def wrap_foo
  puts &quot;Before foo&quot;
  foo do |x|
    yield x
  end
  puts &quot;After foo&quot;
end

wrap_foo do |i|
  puts i
end

# Output:
# Before foo
# 1
# After foo
</code></pre>
<p>You can also use the <code>&amp;block</code> syntax to forward blocks, but then you have to at least specify the input types, and the generated code will involve closures and will be slower:</p>
<pre><code class="language-crystal">def foo
  yield 1
end

def wrap_foo(&amp;block : Int32 -&gt; _)
  puts &quot;Before foo&quot;
  foo(&amp;block)
  puts &quot;After foo&quot;
end

wrap_foo do |i|
  puts i
end

# Output:
# Before foo
# 1
# After foo
</code></pre>
<p>Try to avoid forwarding blocks like this if doing <code>yield</code> is enough. There's also the issue that <code>break</code> and <code>next</code> are not allowed inside captured blocks, so the following won't work when using <code>&amp;block</code> forwarding:</p>
<pre><code class="language-crystal">foo_forward do |i|
  break # error
end
</code></pre>
<p>In short, avoid <code>&amp;block</code> forwarding when <code>yield</code> is involved.</p>
<a class="header" href="print.html#closures" id="closures"><h1>Closures</h1></a>
<p>Captured blocks and proc literals closure local variables and <code>self</code>. This is better understood with an example:</p>
<pre><code class="language-crystal">x = 0
proc = -&gt;{ x += 1; x }
proc.call #=&gt; 1
proc.call #=&gt; 2
x         #=&gt; 2
</code></pre>
<p>Or with a proc returned from a method:</p>
<pre><code class="language-crystal">def counter
  x = 0
  -&gt;{ x += 1; x }
end

proc = counter
proc.call #=&gt; 1
proc.call #=&gt; 2
</code></pre>
<p>In the above example, even though <code>x</code> is a local variable, it was captured by the proc literal. In this case the compiler allocates <code>x</code> on the heap and uses it as the context data of the proc to make it work, because normally local variables live in the stack and are gone after a method returns.</p>
<a class="header" href="print.html#type-of-closured-variables" id="type-of-closured-variables"><h2>Type of closured variables</h2></a>
<p>The compiler is usually moderately smart about the type of local variables. For example:</p>
<pre><code class="language-crystal">def foo
  yield
end

x = 1
foo do
  x = &quot;hello&quot;
end
x # : Int32 | String
</code></pre>
<p>The compiler knows that after the block, <code>x</code> can be Int32 or String (it could know that it will always be String because the method always yields; this may improve in the future).</p>
<p>If <code>x</code> is assigned something else after the block, the compiler knows the type changed:</p>
<pre><code class="language-crystal">x = 1
foo do
  x = &quot;hello&quot;
end
x # : Int32 | String

x = 'a'
x # : Char
</code></pre>
<p>However, if <code>x</code> is closured by a proc, the type is always the mixed type of all assignments to it:</p>
<pre><code class="language-crystal">def capture(&amp;block)
  block
end

x = 1
capture { x = &quot;hello&quot; }

x = 'a'
x # : Int32 | String | Char
</code></pre>
<p>This is because the captured block could have been potentially stored in a class or instance variable and invoked in a separate thread in between the instructions. The compiler doesn't do an exhaustive analysis of this: it just assumes that if a variable is captured by a proc, the time of that proc invocation is unknown.</p>
<p>This also happens with regular proc literals, even if it's evident that the proc wasn't invoked or stored:</p>
<pre><code class="language-crystal">def capture(&amp;block)
  block
end

x = 1
-&gt;{ x = &quot;hello&quot; }

x = 'a'
x # : Int32 | String | Char
</code></pre>
<a class="header" href="print.html#a别名" id="a别名"><h1>别名</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/alias.md">syntax_and_semantics/alias.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/c55247a364ee0c01fd8b1e3d78f2e1352faaa1ea">commit c55247a364ee0c01fd8b1e3d78f2e1352faaa1ea</a></p>
</blockquote>
<p>可以用 <code>alias</code> 来给类型起一个不同的名字：</p>
<pre><code class="language-crystal">alias PInt32 = Pointer(Int32)

ptr = PInt32.malloc(1) # : Pointer(Int32)
</code></pre>
<p>每次使用别名时，编译器会用其所引用的类型替换它。</p>
<p>在避免写长类型名时，别名是非常有用的，但也要考虑递归类型。</p>
<pre><code class="language-crystal">alias RecArray = Array(Int32) | Array(RecArray)

ary = [] of RecArray
ary.push [1, 2, 3]
ary.push ary
ary #=&gt; [[1, 2, 3], [...]]
</code></pre>
<p>递归类型的一个真实例子是 json ：</p>
<pre><code class="language-crystal">module Json
  alias Type = Nil |
               Bool |
               Int64 |
               Float64 |
               String |
               Array(Type) |
               Hash(String, Type)
end
</code></pre>
<a class="header" href="print.html#exception-handling" id="exception-handling"><h1>Exception handling</h1></a>
<p>Crystal's way to do error handling is by raising and rescuing exceptions.</p>
<a class="header" href="print.html#raising-exception" id="raising-exception"><h2>Raising exception</h2></a>
<p>You raise exceptions by invoking a top-level <code>raise</code> method. Unlike other keywords, <code>raise</code> is a regular method with two overloads: <a href="http://crystal-lang.org/api/toplevel.html#raise%28message%20%3A%20String%29-class-method">one accepting a String</a> and another <a href="http://crystal-lang.org/api/toplevel.html#raise%28ex%20%3A%20Exception%29-class-method">accepting an Exception instance</a>:</p>
<pre><code class="language-crystal">raise &quot;OH NO!&quot;
raise Exception.new(&quot;Some error&quot;)
</code></pre>
<p>The String version just creates a new <a href="http://crystal-lang.org/api/Exception.html">Exception</a> instance with that message.</p>
<p>Only <code>Exception</code> instances or subclasses can be raised.</p>
<a class="header" href="print.html#defining-custom-exceptions" id="defining-custom-exceptions"><h2>Defining custom exceptions</h2></a>
<p>To define a custom exception type, just subclass from <a href="http://crystal-lang.org/api/Exception.html">Exception</a>:</p>
<pre><code class="language-crystal">class MyException &lt; Exception
end

class MyOtherException &lt; Exception
end
</code></pre>
<p>You can, as always, define a constructor for your exception or just use the default one.</p>
<a class="header" href="print.html#rescuing-exceptions" id="rescuing-exceptions"><h2>Rescuing exceptions</h2></a>
<p>To rescue any exception use a <code>begin ... rescue ... end</code> expression:</p>
<pre><code class="language-crystal">begin
  raise &quot;OH NO!&quot;
rescue
  puts &quot;Rescued!&quot;
end

# Output: Rescued!
</code></pre>
<p>To access the rescued exception you can specify a variable in the <code>rescue</code> clause:</p>
<pre><code class="language-crystal">begin
  raise &quot;OH NO!&quot;
rescue ex
  puts ex.message
end

# Output: OH NO!
</code></pre>
<p>To rescue just one type of exception (or any of its subclasses):</p>
<pre><code class="language-crystal">begin
  raise MyException.new(&quot;OH NO!&quot;)
rescue MyException
  puts &quot;Rescued MyException&quot;
end

# Output: Rescued MyException
</code></pre>
<p>And to access it, use a syntax similar to type restrictions:</p>
<pre><code class="language-crystal">begin
  raise MyException.new(&quot;OH NO!&quot;)
rescue ex : MyException
  puts &quot;Rescued MyException: #{ex.message}&quot;
end

# Output: Rescued MyException: OH NO!
</code></pre>
<p>Multiple <code>rescue</code> clauses can be specified:</p>
<pre><code class="language-crystal">begin
  # ...
rescue ex1 : MyException
  # only MyException...
rescue ex2 : MyOtherException
  # only MyOtherException...
rescue
  # any other kind of exception
end
</code></pre>
<p>You can also rescue multiple exception types at once by specifying a union type:</p>
<pre><code class="language-crystal">begin
  # ...
rescue ex : MyException | MyOtherException
  # only MyException or MyOtherException
rescue
  # any other kind of exception
end
</code></pre>
<a class="header" href="print.html#else" id="else"><h2>else</h2></a>
<p>An <code>else</code> clause is executed only if no exceptions were rescued:</p>
<pre><code class="language-crystal">begin
  something_dangerous
rescue
  # execute this if an exception is raised
else
  # execute this if an exception isn't raised
end
</code></pre>
<p>An <code>else</code> clause can only be specified if at least one <code>rescue</code> clause is specified.</p>
<a class="header" href="print.html#ensure" id="ensure"><h2>ensure</h2></a>
<p>An <code>ensure</code> clause is executed at the end of a <code>begin ... end</code> or <code>begin ... rescue ... end</code> expression regardless of whether an exception was raised or not:</p>
<pre><code class="language-crystal">begin
  something_dangerous
ensure
  puts &quot;Cleanup...&quot;
end

# Will print &quot;Cleanup...&quot; after invoking something_dangerous,
# regardless of whether it raised or not
</code></pre>
<p>Or:</p>
<pre><code class="language-crystal">begin
  something_dangerous
rescue
  # ...
else
  # ...
ensure
  # this will always be executed
end
</code></pre>
<p><code>ensure</code> clauses are usually used for clean up, freeing resources, etc.</p>
<a class="header" href="print.html#short-syntax-form" id="short-syntax-form"><h2>Short syntax form</h2></a>
<p>Exception handling has a short syntax form: assume a method or block definition is an implicit <code>begin ... end</code> expression, then specify <code>rescue</code>, <code>else</code>, and <code>ensure</code> clauses:</p>
<pre><code class="language-crystal">def some_method
  something_dangerous
rescue
  # execute if an exception is raised
end

# The above is the same as:
def some_method
  begin
    something_dangerous
  rescue
    # execute if an exception is raised
  end
end
</code></pre>
<p>With <code>ensure</code>:</p>
<pre><code class="language-crystal">def some_method
  something_dangerous
ensure
  # always execute this
end

# The above is the same as:
def some_method
  begin
    something_dangerous
  ensure
    # always execute this
  end
end

# Similarly, the shorthand also works with blocks:
(1..10).each do |n|
  # potentially dangerous operation
rescue
  #..
else
  #..
ensure
  #..
end
</code></pre>
<a class="header" href="print.html#type-inference-1" id="type-inference-1"><h2>Type inference</h2></a>
<p>Variables declared inside the <code>begin</code> part of an exception handler also get the <code>Nil</code> type when considered inside a <code>rescue</code> or <code>ensure</code> body. For example:</p>
<pre><code class="language-crystal">begin
  a = something_dangerous_that_returns_Int32
ensure
  puts a + 1 # error, undefined method '+' for Nil
end
</code></pre>
<p>The above happens even if <code>something_dangerous_that_returns_Int32</code> never raises, or if <code>a</code> was assigned a value and then a method that potentially raises is executed:</p>
<pre><code class="language-crystal">begin
  a = 1
  something_dangerous
ensure
  puts a + 1 # error, undefined method '+' for Nil
end
</code></pre>
<p>Although it is obvious that <code>a</code> will always be assigned a value, the compiler will still think <code>a</code> might never had a chance to be initialized. Even though this logic might improve in the future, right now it forces you to keep your exception handlers to their necessary minimum, making the code's intention more clear:</p>
<pre><code class="language-crystal"># Clearer than the above: `a` doesn't need
# to be in the exception handling code.
a = 1
begin
  something_dangerous
ensure
  puts a + 1 # works
end
</code></pre>
<a class="header" href="print.html#alternative-ways-to-do-error-handling" id="alternative-ways-to-do-error-handling"><h2>Alternative ways to do error handling</h2></a>
<p>Although exceptions are available as one of the mechanisms for handling errors, they are not your only choice. Raising an exception involves allocating memory, and executing an exception handler is generally slow.</p>
<p>The standard library usually provides a couple of methods to accomplish something: one raises, one returns <code>nil</code>. For example:</p>
<pre><code class="language-crystal">array = [1, 2, 3]
array[4]  # raises because of IndexError
array[4]? # returns nil because of index out of bounds
</code></pre>
<p>The usual convention is to provide an alternative &quot;question&quot; method to signal that this variant of the method returns <code>nil</code> instead of raising. This lets the user choose whether she wants to deal with exceptions or with <code>nil</code>. Note, however, that this is not available for every method out there, as exceptions are still the preferred way because they don't pollute the code with error handling logic.</p>
<a class="header" href="print.html#type-grammar" id="type-grammar"><h1>Type grammar</h1></a>
<p>When:</p>
<ul>
<li>specifying <a href="type_restrictions.html">type restrictions</a></li>
<li>specifying <a href="generics.html">type arguments</a></li>
<li><a href="declare_var.html">declaring variables</a></li>
<li>declaring <a href="alias.html">aliases</a></li>
<li>declaring <a href="c_bindings/type.html">typedefs</a></li>
<li>the argument of an <a href="is_a.html">is_a?</a> pseudo-call</li>
<li>the argument of an <a href="as.html">as</a> expression</li>
<li>the argument of a <a href="sizeof.html">sizeof</a> expression</li>
<li>the argument of an <a href="instance_sizeof.html">instance_sizeof</a> expression</li>
<li>a method's <a href="return_types.html">return type</a></li>
</ul>
<p>a convenient syntax is provided for some common types. These are especially useful when writing <a href="c_bindings/index.html">C bindings</a>, but can be used in any of the above locations.</p>
<a class="header" href="print.html#paths-and-generics" id="paths-and-generics"><h2>Paths and generics</h2></a>
<p>Regular types and generics can be used:</p>
<pre><code class="language-crystal">Int32
My::Nested::Type
Array(String)
</code></pre>
<a class="header" href="print.html#union" id="union"><h2>Union</h2></a>
<pre><code class="language-crystal">alias Int32OrString = Int32 | String
</code></pre>
<p>The pipe (<code>|</code>) in types creates a union type. <code>Int32 | String</code> is read &quot;Int32 or String&quot;. In regular code, <code>Int32 | String</code> means invoking the method <code>|</code> on <code>Int32</code> with <code>String</code> as an argument.</p>
<a class="header" href="print.html#nilable" id="nilable"><h2>Nilable</h2></a>
<pre><code class="language-crystal">alias Int32OrNil = Int32?
</code></pre>
<p>is the same as:</p>
<pre><code class="language-crystal">alias Int32OrNil = Int32 | ::Nil
</code></pre>
<p>In regular code, <code>Int32?</code> is a syntax error.</p>
<a class="header" href="print.html#pointer" id="pointer"><h2>Pointer</h2></a>
<pre><code class="language-crystal">alias Int32Ptr = Int32*
</code></pre>
<p>is the same as:</p>
<pre><code class="language-crystal">alias Int32Ptr = Pointer(Int32)
</code></pre>
<p>In regular code, <code>Int32*</code> means invoking the <code>*</code> method on <code>Int32</code>.</p>
<a class="header" href="print.html#staticarray" id="staticarray"><h2>StaticArray</h2></a>
<pre><code class="language-crystal">alias Int32_8 = Int32[8]
</code></pre>
<p>is the same as:</p>
<pre><code class="language-crystal">alias Int32_8 = StaticArray(Int32, 8)
</code></pre>
<p>In regular code, <code>Int32[8]</code> means invoking the <code>[]</code> method on <code>Int32</code> with <code>8</code> as an argument.</p>
<a class="header" href="print.html#tuple" id="tuple"><h2>Tuple</h2></a>
<pre><code class="language-crystal">alias Int32StringTuple = {Int32, String}
</code></pre>
<p>is the same as:</p>
<pre><code class="language-crystal">alias Int32StringTuple = Tuple(Int32, String)
</code></pre>
<p>In regular code, <code>{Int32, String}</code> is a tuple instance containing <code>Int32</code> and <code>String</code> as its elements. This is different than the above tuple <strong>type</strong>.</p>
<a class="header" href="print.html#namedtuple" id="namedtuple"><h2>NamedTuple</h2></a>
<pre><code class="language-crystal">alias Int32StringNamedTuple = {x: Int32, y: String}
</code></pre>
<p>is the same as:</p>
<pre><code class="language-crystal">alias Int32StringNamedTuple = NamedTuple(x: Int32, y: String)
</code></pre>
<p>In regular code, <code>{x: Int32, y: String}</code> is a named tuple instance containing <code>Int32</code> and <code>String</code> for <code>x</code> and <code>y</code>. This is different than the above named tuple <strong>type</strong>.</p>
<a class="header" href="print.html#proc" id="proc"><h2>Proc</h2></a>
<pre><code class="language-crystal">alias Int32ToString = Int32 -&gt; String
</code></pre>
<p>is the same as:</p>
<pre><code class="language-crystal">alias Int32ToString = Proc(Int32, String)
</code></pre>
<p>To specify a Proc without arguments:</p>
<pre><code class="language-crystal">alias ProcThatReturnsInt32 = -&gt; Int32
</code></pre>
<p>To specify multiple arguments:</p>
<pre><code class="language-crystal">alias Int32AndCharToString = Int32, Char -&gt; String
</code></pre>
<p>For nested procs (and any type, in general), you can use parentheses:</p>
<pre><code class="language-crystal">alias ComplexProc = (Int32 -&gt; Int32) -&gt; String
</code></pre>
<p>In regular code <code>Int32 -&gt; String</code> is a syntax error.</p>
<a class="header" href="print.html#self" id="self"><h2>self</h2></a>
<p><code>self</code> can be used in the type grammar to denote a <code>self</code> type. Refer to the <a href="type_restrictions.html">type restrictions</a> section.</p>
<a class="header" href="print.html#class" id="class"><h2>class</h2></a>
<p><code>class</code> is used to refer to a class type, instead of an instance type.</p>
<p>For example:</p>
<pre><code class="language-crystal">def foo(x : Int32)
  &quot;instance&quot;
end

def foo(x : Int32.class)
  &quot;class&quot;
end

foo 1     # &quot;instance&quot;
foo Int32 # &quot;class&quot;
</code></pre>
<p><code>class</code> is also useful for creating arrays and collections of class type:</p>
<pre><code class="language-crystal">class Parent
end

class Child1 &lt; Parent
end

class Child2 &lt; Parent
end

ary = [] of Parent.class
ary &lt;&lt; Child1
ary &lt;&lt; Child2
</code></pre>
<a class="header" href="print.html#underscore" id="underscore"><h2>Underscore</h2></a>
<p>An underscore is allowed in type restrictions. It matches anything:</p>
<pre><code class="language-crystal"># Same as not specifying a restriction, not very useful
def foo(x : _)
end

# A bit more useful: any two arguments Proc that returns an Int32:
def foo(x : _, _ -&gt; Int32)
end
</code></pre>
<a class="header" href="print.html#typeof" id="typeof"><h2>typeof</h2></a>
<p><code>typeof</code> is allowed in the type grammar. It returns a union type of the type of the passed expressions:</p>
<pre><code class="language-crystal">typeof(1 + 2) # =&gt; Int32
typeof(1, &quot;a&quot;) # =&gt; (Int32 | String)
</code></pre>
<a class="header" href="print.html#type-reflection" id="type-reflection"><h1>Type reflection</h1></a>
<p>Crystal provides basic methods to do type reflection, casting and introspection.</p>
<a class="header" href="print.html#is_a" id="is_a"><h1>is_a?</h1></a>
<p>The pseudo-method <code>is_a?</code> determines whether an expression's runtime type inherits or includes another type. For example:</p>
<pre><code class="language-crystal">a = 1
a.is_a?(Int32)          #=&gt; true
a.is_a?(String)         #=&gt; false
a.is_a?(Number)         #=&gt; true
a.is_a?(Int32 | String) #=&gt; true
</code></pre>
<p>It is a pseudo-method because the compiler knows about it and it can affect type information, as explained in <a href="if_varis_a.html">if var.is_a?(...)</a>. Also, it accepts a <a href="type_grammar.html">type</a> that must be known at compile-time as its argument.</p>
<a class="header" href="print.html#nil" id="nil"><h1>nil?</h1></a>
<p>The pseudo-method <code>nil?</code> determines whether an expression's runtime type is <code>Nil</code>. For example:</p>
<pre><code class="language-crystal">a = 1
a.nil?          # =&gt; false

b = nil
b.nil?          # =&gt; true
</code></pre>
<p>It is a pseudo-method because the compiler knows about it and it can affect type information, as explained in <a href="if_var_nil.html">if var.nil?(...)</a>.</p>
<p>It has the same effect as writing <code>is_a?(Nil)</code> but it's shorter and easier to read and write.</p>
<a class="header" href="print.html#responds_to" id="responds_to"><h1>responds_to?</h1></a>
<p>The pseudo-method <code>responds_to?</code> determines whether a type has a method with the given name. For example:</p>
<pre><code class="language-crystal">a = 1
a.responds_to?(:abs)    #=&gt; true
a.responds_to?(:size) #=&gt; false
</code></pre>
<p>It is a pseudo-method because it only accepts a symbol literal as its argument, and is also treated specially by the compiler, as explained in <a href="if_varresponds_to.html">if var.responds_to?(...)</a>.</p>
<a class="header" href="print.html#as" id="as"><h1>as</h1></a>
<p>The <code>as</code> pseudo-method restricts the types of an expression. For example:</p>
<pre><code class="language-crystal">if some_condition
  a = 1
else
  a = &quot;hello&quot;
end

# a : Int32 | String
</code></pre>
<p>In the above code, <code>a</code> is a union of <code>Int32 | String</code>. If for some reason we are sure <code>a</code> is an <code>Int32</code> after the <code>if</code>, we can force the compiler to treat it like one:</p>
<pre><code class="language-crystal">a_as_int = a.as(Int32)
a_as_int.abs          # works, compiler knows that a_as_int is Int32
</code></pre>
<p>The <code>as</code> pseudo-method performs a runtime check: if <code>a</code> wasn't an <code>Int32</code>, an <a href="exception_handling.html">exception</a> is raised.</p>
<p>The argument to the expression is a <a href="type_grammar.html">type</a>.</p>
<p>If it is impossible for a type to be restricted by another type, a compile-time error is issued:</p>
<pre><code class="language-crystal">1.as(String) # Compile-time error
</code></pre>
<p>**Note: ** you can't use <code>as</code> to convert a type to an unrelated type: <code>as</code> is not like a <code>cast</code> in other languages. Methods on integers, floats and chars are provided for these conversions. Alternatively, use pointer casts as explained below.</p>
<a class="header" href="print.html#converting-between-pointer-types" id="converting-between-pointer-types"><h2>Converting between pointer types</h2></a>
<p>The <code>as</code> pseudo-method also allows to cast between pointer types:</p>
<pre><code class="language-crystal">ptr = Pointer(Int32).malloc(1)
ptr.as(Int8*)                    #:: Pointer(Int8)
</code></pre>
<p>In this case, no runtime checks are done: pointers are unsafe and this type of casting is usually only needed in C bindings and low-level code.</p>
<a class="header" href="print.html#converting-between-pointer-types-and-other-types" id="converting-between-pointer-types-and-other-types"><h2>Converting between pointer types and other types</h2></a>
<p>Conversion between pointer types and Reference types is also possible:</p>
<pre><code class="language-crystal">array = [1, 2, 3]

# object_id returns the address of an object in memory,
# so we create a pointer with that address
ptr = Pointer(Void).new(array.object_id)

# Now we cast that pointer to the same type, and
# we should get the same value
array2 = ptr.as(Array(Int32))
array2.same?(array) #=&gt; true
</code></pre>
<p>No runtime checks are performed in these cases because, again, pointers are involved. The need for this cast is even more rare than the previous one, but allows to implement some core types (like String) in Crystal itself, and it also allows passing a Reference type to C functions by casting it to a void pointer.</p>
<a class="header" href="print.html#usage-for-casting-to-a-bigger-type" id="usage-for-casting-to-a-bigger-type"><h2>Usage for casting to a bigger type</h2></a>
<p>The <code>as</code> pseudo-method can be used to cast an expression to a &quot;bigger&quot; type. For example:</p>
<pre><code class="language-crystal">a = 1
b = a.as(Int32 | Float64)
b #:: Int32 | Float64
</code></pre>
<p>The above might not seem to be useful, but it is when, for example, mapping an array of elements:</p>
<pre><code class="language-crystal">ary = [1, 2, 3]

# We want to create an array 1, 2, 3 of Int32 | Float64
ary2 = ary.map { |x| x.as(Int32 | Float64) }

ary2 #:: Array(Int32 | Float64)
ary2 &lt;&lt; 1.5 # OK
</code></pre>
<p>The <code>Array#map</code> method uses the block's type as the generic type for the Array. Without the <code>as</code> pseudo-method, the inferred type would have been <code>Int32</code> and we wouldn't have been able to add a <code>Float64</code> into it.</p>
<a class="header" href="print.html#usage-for-when-the-compiler-cant-infer-the-type-of-a-block" id="usage-for-when-the-compiler-cant-infer-the-type-of-a-block"><h2>Usage for when the compiler can't infer the type of a block</h2></a>
<p>Sometimes the compiler can't infer the type of a block. This can happen in recursive calls that depend on each other. In those cases you can use <code>as</code> to let it know the type:</p>
<pre><code class="language-crystal">some_call { |v| v.method.as(ExpectedType) }
</code></pre>
<a class="header" href="print.html#as-1" id="as-1"><h1>as?</h1></a>
<p>The <code>as?</code> pseudo-method is similar to <code>as</code>, except that it returns <code>nil</code> instead of raising an exception when the type doesn't match. It also can't be used to cast between pointer types and other types.</p>
<p>Example:</p>
<pre><code class="language-crystal">value = rand &lt; 0.5 ? -3 : nil
result = value.as?(Int32) || 10

value.as?(Int32).try &amp;.abs
</code></pre>
<a class="header" href="print.html#typeof-1" id="typeof-1"><h1>typeof</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/typeof.md">syntax_and_semantics/typeof.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/ab174eb5c083fdad72b78c59414a73e9631653c6">commit ab174eb5c083fdad72b78c59414a73e9631653c6</a></p>
</blockquote>
<p><code>typeof</code> 表达式返回一个表达式的类型：</p>
<pre><code class="language-crystal">a = 1
b = typeof(a) #=&gt; Int32
</code></pre>
<p>其接收多个参数，结果是表达式类型的联合体：</p>
<pre><code class="language-crystal">typeof(1, &quot;a&quot;, 'a') #=&gt; (Int32 | String | Char)
</code></pre>
<p>其在一般代码中经常用到，用于编译器的类型推断容量：</p>
<pre><code class="language-crystal">hash = {} of Int32 =&gt; String
another_hash = typeof(hash).new #:: Hash(Int32, String)
</code></pre>
<p>因为 <code>typeof</code> 实际上并不计算表达式，它只能用于编译时的方法中，例如，递归的构成一个内嵌类型参数的联合类型：</p>
<pre><code class="language-crystal">class Array
  def self.elem_type(typ)
    if typ.is_a?(Array)
      elem_type(typ.first)
    else
      typ
    end
  end
end

nest = [1, [&quot;b&quot;, [:c, ['d']]]]
flat = Array(typeof(Array.elem_type(nest))).new
typeof(nest) #=&gt; Array(Int32 | Array(String | Array(Symbol | Array(Char))))
typeof(flat) #=&gt; Array(String | Int32 | Symbol | Char)
</code></pre>
<p>该表达式也可以在<a href="type_grammar.html">类型语法</a>中使用。</p>
<a class="header" href="print.html#macros" id="macros"><h1>Macros</h1></a>
<p>Macros are methods that receive AST nodes at compile-time and produce
code that is pasted into a program. For example:</p>
<pre><code class="language-crystal">macro define_method(name, content)
  def {{name}}
    {{content}}
  end
end

# This generates:
#
#     def foo
#       1
#     end
define_method foo, 1

foo #=&gt; 1
</code></pre>
<p>A macro's definition body looks like regular Crystal code with extra syntax to manipulate the AST nodes. The generated code must be valid Crystal code, meaning that you can't for example generate a <code>def</code> without a matching <code>end</code>, or a single <code>when</code> expression of a <code>case</code>, since both of them are not complete valid expressions. Refer to <a href="print.html#pitfalls">Pitfalls</a> for more information.</p>
<a class="header" href="print.html#scope" id="scope"><h2>Scope</h2></a>
<p>Macros declared at the top-level are visible anywhere. If a top-level macro is marked as <code>private</code> it is only accessible in that file.</p>
<p>They can also be defined in classes and modules, and are visible in those scopes. Macros are also looked-up in the ancestors chain (superclasses and included modules).</p>
<p>For example, a block which is given an object to use as the default receiver by being invoked with <code>with ... yield</code> can access macros defined within that object's ancestors chain:</p>
<pre><code class="language-crystal">class Foo
  macro emphasize(value)
    &quot;***#{ {{value}} }***&quot;
  end

  def yield_with_self
    with self yield
  end
end

Foo.new.yield_with_self { emphasize(10) } #=&gt; &quot;***10***&quot;
</code></pre>
<p>Macros defined in classes and modules can be invoked from outside of them too:</p>
<pre><code class="language-crystal">class Foo
  macro emphasize(value)
    &quot;***#{ {{value}} }***&quot;
  end
end

Foo.emphasize(10) # =&gt; &quot;***10***&quot;
</code></pre>
<a class="header" href="print.html#interpolation" id="interpolation"><h2>Interpolation</h2></a>
<p>You use <code>{{...}}</code> to paste, or interpolate, an AST node, as in the above example.</p>
<p>Note that the node is pasted as-is. If in the previous example we pass a symbol, the generated code becomes invalid:</p>
<pre><code class="language-crystal"># This generates:
#
#     def :foo
#       1
#     end
define_method :foo, 1
</code></pre>
<p>Note that <code>:foo</code> was the result of the interpolation, because that's what was passed to the macro. You can use the method <code>ASTNode#id</code> in these cases, where you just need an identifier.</p>
<a class="header" href="print.html#macro-calls" id="macro-calls"><h2>Macro calls</h2></a>
<p>You can invoke a <strong>fixed subset</strong> of methods on AST nodes at compile-time. These methods are documented in a fictitious <a href="http://crystal-lang.org/api/Crystal/Macros.html">Crystal::Macros</a> module.</p>
<p>For example, invoking <code>ASTNode#id</code> in the above example solves the problem:</p>
<pre><code class="language-crystal">macro define_method(name, content)
  def {{name.id}}
    {{content}}
  end
end

# This correctly generates:
#
#     def foo
#       1
#     end
define_method :foo, 1
</code></pre>
<a class="header" href="print.html#modules-and-classes" id="modules-and-classes"><h2>Modules and classes</h2></a>
<p>Modules, classes and structs can also be generated:</p>
<pre><code class="language-crystal">macro define_class(module_name, class_name, method, content)
  module {{module_name}}
    class {{class_name}}
      def initialize(@name : String)
      end

      def {{method}}
        {{content}} + @name
      end
    end
  end
end

# This generates:
#     module Foo
#       class Bar
#         def initialize(@name : String)
#         end
#
#         def say
#           &quot;hi &quot; + @name
#         end
#       end
#     end
define_class Foo, Bar, say, &quot;hi &quot;

p Foo::Bar.new(&quot;John&quot;).say # =&gt; &quot;hi John&quot;
</code></pre>
<a class="header" href="print.html#conditionals" id="conditionals"><h2>Conditionals</h2></a>
<p>You use <code>{% if condition %}</code> ... <code>{% end %}</code> to conditionally generate code:</p>
<pre><code class="language-crystal">macro define_method(name, content)
  def {{name}}
    {% if content == 1 %}
      &quot;one&quot;
    {% elsif content == 2 %}
      &quot;two&quot;
    {% else %}
      {{content}}
    {% end %}
  end
end

define_method foo, 1
define_method bar, 2
define_method baz, 3

foo #=&gt; one
bar #=&gt; two
baz #=&gt; 3
</code></pre>
<p>Similar to regular code, <code>Nop</code>, <code>NilLiteral</code> and a false <code>BoolLiteral</code> are considered <em>falsey</em>, while everything else is considered truthy.</p>
<p>Macro conditionals can be used outside a macro definition:</p>
<pre><code class="language-crystal">{% if env(&quot;TEST&quot;) %}
  puts &quot;We are in test mode&quot;
{% end %}
</code></pre>
<a class="header" href="print.html#iteration" id="iteration"><h2>Iteration</h2></a>
<p>You can iterate a finite amount of times:</p>
<pre><code class="language-crystal">macro define_constants(count)
  {% for i in (1..count) %}
    PI_{{i.id}} = Math::PI * {{i}}
  {% end %}
end

define_constants(3)

PI_1 #=&gt; 3.14159...
PI_2 #=&gt; 6.28318...
PI_3 #=&gt; 9.42477... 
</code></pre>
<p>To iterate an <code>ArrayLiteral</code>:</p>
<pre><code class="language-crystal">macro define_dummy_methods(names)
  {% for name, index in names %}
    def {{name.id}}
      {{index}}
    end
  {% end %}
end

define_dummy_methods [foo, bar, baz]

foo #=&gt; 0
bar #=&gt; 1
baz #=&gt; 2
</code></pre>
<p>The <code>index</code> variable in the above example is optional.</p>
<p>To iterate a <code>HashLiteral</code>:</p>
<pre><code class="language-crystal">macro define_dummy_methods(hash)
  {% for key, value in hash %}
    def {{key.id}}
      {{value}}
    end
  {% end %}
end
define_dummy_methods({foo: 10, bar: 20})
foo #=&gt; 10
bar #=&gt; 20
</code></pre>
<p>Macro iterations can be used outside a macro definition:</p>
<pre><code class="language-crystal">{% for name, index in [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;] %}
  def {{name.id}}
    {{index}}
  end
{% end %}

foo #=&gt; 0
bar #=&gt; 1
baz #=&gt; 2
</code></pre>
<a class="header" href="print.html#variadic-arguments-and-splatting" id="variadic-arguments-and-splatting"><h2>Variadic arguments and splatting</h2></a>
<p>A macro can accept variadic arguments:</p>
<pre><code class="language-crystal">macro define_dummy_methods(*names)
  {% for name, index in names %}
    def {{name.id}}
      {{index}}
    end
  {% end %}
end

define_dummy_methods foo, bar, baz

foo #=&gt; 0
bar #=&gt; 1
baz #=&gt; 2
</code></pre>
<p>The arguments are packed into an <code>ArrayLiteral</code> and passed to the macro.</p>
<p>Additionally, using <code>*</code> when interpolating an <code>ArrayLiteral</code> interpolates the elements separated by commas:</p>
<pre><code class="language-crystal">macro println(*values)
  print {{*values}}, '\n'
end

println 1, 2, 3 # outputs 123\n
</code></pre>
<a class="header" href="print.html#type-information" id="type-information"><h2>Type information</h2></a>
<p>When a macro is invoked you can access the current scope, or type, with a special instance variable: <code>@type</code>. The type of this variable is <code>TypeNode</code>, which gives you access to type information at compile time.</p>
<p>Note that <code>@type</code> is always the <em>instance</em> type, even when the macro is invoked in a class method.</p>
<p>For example:</p>
<pre><code class="language-crystal">macro add_describe_methods
  def describe
    &quot;Class is: &quot; + {{ @type.stringify }}
  end
  
  def self.describe
    &quot;Class is: &quot; + {{ @type.stringify }}
  end
end

class Foo
  add_describe_methods
end

Foo.new.describe #=&gt; &quot;Class is Foo&quot;
Foo.describe #=&gt; &quot;Class is Foo&quot;
</code></pre>
<a class="header" href="print.html#constants-1" id="constants-1"><h2>Constants</h2></a>
<p>Macros can access constants. For example:</p>
<pre><code class="language-crystal">VALUES = [1, 2, 3]

{% for value in VALUES %}
  puts {{value}}
{% end %}
</code></pre>
<p>If the constant denotes a type, you get back a <code>TypeNode</code>.</p>
<a class="header" href="print.html#nested-macros" id="nested-macros"><h2>Nested macros</h2></a>
<p>It is possible to define a macro which generates one or more macro definitions. You must escape macro expressions of the inner macro by preceding them with a backslash character &quot;\&quot; to prevent them from being evaluated by the outer macro.</p>
<pre><code class="language-crystal">macro define_macros(*names)
  {% for name in names %}
    macro greeting_for_{{name.id}}(greeting)
      \{% if greeting == &quot;hola&quot; %}
        &quot;¡hola {{name.id}}!&quot;
      \{% else %}
        &quot;\{{greeting.id}} {{name.id}}&quot;
      \{% end %}
    end
  {% end %}
end

# This generates:
#
#     macro greeting_for_alice
#       {% if greeting == &quot;hola&quot; %}
#         &quot;¡hola alice!&quot;
#       {% else %}
#         &quot;{{greeting.id}} alice&quot;
#       {% end %}
#     end
#     macro greeting_for_bob
#       {% if greeting == &quot;hola&quot; %}
#         &quot;¡hola bob!&quot;
#       {% else %}
#         &quot;{{greeting.id}} bob&quot;
#       {% end %}
#     end
define_macros alice, bob

greeting_for_alice &quot;hello&quot;  #=&gt; &quot;hello alice&quot;
greeting_for_bob &quot;hallo&quot;    #=&gt; &quot;hallo bob&quot;
greeting_for_alice &quot;hej&quot;    #=&gt; &quot;hej alice&quot;
greeting_for_bob &quot;hola&quot;     #=&gt; &quot;¡hola bob!&quot;
</code></pre>
<a class="header" href="print.html#pitfalls" id="pitfalls"><h2>Pitfalls</h2></a>
<p>When writing macros (especially outside of a macro definition) it is important to remember that the generated code from the macro must be valid Crystal code by itself even before it is merged into the main program's code. This means, for example, a macro cannot generate a one or more <code>when</code> expressions of a <code>case</code> statement unless <code>case</code> was a part of the generated code.</p>
<p>Here is an example of such an invalid macro:</p>
<pre><code class="language-crystal">case 42
{% for klass in [Int32, String] %}
  when {{klass.id}}
    p &quot;is {{klass}}&quot;
{% end %}
end
</code></pre>
<p>Notice that <code>case</code> is not within the macro. The code generated by the macro consists solely of two <code>when</code> expressions which, by themselves, is not valid Crystal code. We must include <code>case</code> within the macro in order to make it valid by using <code>begin</code> and <code>end</code>:</p>
<pre><code class="language-crystal">{% begin %}
  case 42
  {% for klass in [Int32, String] %}
    when {{klass.id}}
      p &quot;is {{klass}}&quot;
  {% end %}
  end
{% end %}
</code></pre>
<a class="header" href="print.html#macro-methods" id="macro-methods"><h1>Macro methods</h1></a>
<p>Macro defs allow you to define a method for a class hierarchy which is then instantiated for each concrete subtype.</p>
<p>A <code>def</code> is implicitly considered a <code>macro def</code> if it contains a macro expression which refers to <code>@type</code>. For example:</p>
<pre><code class="language-crystal">class Object
  def instance_vars_names
    {{ @type.instance_vars.map &amp;.name.stringify }}
  end
end

class Person
  def initialize(@name : String, @age : Int32)
  end
end

person = Person.new &quot;John&quot;, 30
person.instance_vars_names #=&gt; [&quot;name&quot;, &quot;age&quot;]
</code></pre>
<p>In macro definitions, arguments are passed as their AST nodes, giving you access to them in macro expansions (<code>{{some_macro_argument}}</code>). However that is not true for macro defs. Here the argument list is that of the method generated by the macro def. You cannot access their compile-time value.</p>
<pre><code class="language-crystal">class Object
  def has_instance_var?(name) : Bool
    # We cannot access name inside the macro expansion here,
    # instead we need to use the macro language to construct an array
    # and do the inclusion check at runtime.
    {{ @type.instance_vars.map &amp;.name.stringify }}.includes? name
  end
end

person = Person.new &quot;John&quot;, 30
person.has_instance_var?(&quot;name&quot;) #=&gt; true
person.has_instance_var?(&quot;birthday&quot;) #=&gt; false
</code></pre>
<a class="header" href="print.html#hooks" id="hooks"><h1>Hooks</h1></a>
<p>Special macros exist that are invoked in some situations as hooks, at compile time:</p>
<ul>
<li><code>inherited</code> is invoked when a subclass is defined. <code>@type</code> is the inheriting type.</li>
<li><code>included</code> is invoked when a module is included. <code>@type</code> is the including type.</li>
<li><code>extended</code> is invoked when a module is extended. <code>@type</code> is the extending type.</li>
<li><code>method_missing</code> is invoked when a method is not found.</li>
<li><code>method_added</code> is invoked when a new method is defined in the current scope.</li>
<li><code>finished</code> is invoked after instance variable types for all classes are known.</li>
</ul>
<p>Example of <code>inherited</code>:</p>
<pre><code class="language-crystal">class Parent
  macro inherited
    def lineage
      &quot;{{@type.name.id}} &lt; Parent&quot;
    end
  end
end

class Child &lt; Parent
end

Child.new.lineage #=&gt; &quot;Child &lt; Parent&quot;
</code></pre>
<p>Example of <code>method_missing</code>:</p>
<pre><code class="language-crystal">macro method_missing(call)
  print &quot;Got &quot;, {{call.name.id.stringify}}, &quot; with &quot;, {{call.args.size}}, &quot; arguments&quot;, '\n'
end

foo          # Prints: Got foo with 0 arguments
bar 'a', 'b' # Prints: Got bar with 2 arguments
</code></pre>
<p>Example of <code>method_added</code>:</p>
<pre><code class="language-crystal">macro method_added(method)
  {% puts &quot;Method added:&quot;, method.name.stringify %}
end

def generate_random_number
  4
end
#=&gt; Method added: generate_random_number 
</code></pre>
<p>Both <code>method_missing</code> and <code>method_added</code> only apply to calls or methods in the same class that the macro is defined in, or only in the top level if the macro is defined outside of a class. For example:</p>
<pre><code class="language-crystal">macro method_missing(call)
  puts &quot;In outer scope, got call: &quot;, {{ call.name.stringify }}
end

class SomeClass
  macro method_missing(call)
    puts &quot;Inside SomeClass, got call: &quot;, {{ call.name.stringify }}
  end
end

class OtherClass
end

# This call is handled by the top-level `method_missing`
foo #=&gt; In outer scope, got call: foo

obj = SomeClass.new
# This is handled by the one inside SomeClass
obj.bar #=&gt; Inside SomeClass, got call: bar

other = OtherClass.new
# Neither OtherClass or its parents define a `method_missing` macro
other.baz #=&gt; Error: Undefined method 'baz' for OtherClass
</code></pre>
<p><code>finished</code> is called once a type has been completely defined - this includes extensions on that class. Consider the following program:</p>
<pre><code class="language-crystal">macro print_methods
  {% puts @type.methods.map &amp;.name %}
end

class Foo
  macro finished
    {% puts @type.methods.map &amp;.name %}
  end
  print_methods
end

class Foo
  def bar
    puts &quot;I'm a method!&quot;
  end
end

Foo.new.bar
</code></pre>
<p>The <code>print_methods</code> macro will be run as soon as it is encountered - and will print an empty list as there are no methods defined at that point. Once the second declaration of <code>Foo</code> is compiled the <code>finished</code> macro will be run, which will print <code>[bar]</code>.</p>
<a class="header" href="print.html#fresh-variables" id="fresh-variables"><h1>Fresh variables</h1></a>
<p>Once macros generate code, they are parsed with a regular Crystal parser where local variables in the context of the macro invocations are assumed to be defined.</p>
<p>This is better understood with an example:</p>
<pre><code class="language-crystal">macro update_x
  x = 1
end

x = 0
update_x
x #=&gt; 1
</code></pre>
<p>This can sometimes be useful to avoid repetitive code by deliberately reading/writing local variables, but can also overwrite local variables by mistake. To avoid this, fresh variables can be declared with <code>%name</code>:</p>
<pre><code class="language-crystal">macro dont_update_x
  %x = 1
  puts %x
end

x = 0
dont_update_x # outputs 1
x #=&gt; 0
</code></pre>
<p>Using <code>%x</code> in the above example, we declare a variable whose name is guaranteed not to conflict with local variables in the current scope.</p>
<p>Additionally, fresh variables with respect to some other AST node can be declared with <code>%var{key1, key2, ..., keyN}</code>. For example:</p>
<pre><code class="language-crystal">macro fresh_vars_sample(*names)
  # First declare vars
  {% for name, index in names %}
    print &quot;Declaring: &quot;, &quot;%name{index}&quot;, '\n'
    %name{index} = {{index}}
  {% end %}

  # Then print them
  {% for name, index in names %}
    print &quot;%name{index}: &quot;, %name{index}, '\n'
  {% end %}
end

fresh_vars_sample a, b, c

# Sample output:
# Declaring: __temp_255
# Declaring: __temp_256
# Declaring: __temp_257
# __temp_255: 0
# __temp_256: 1
# __temp_257: 2
</code></pre>
<p>In the above example, three indexed variables are declared, assigned values, and then printed, displaying their corresponding indices.</p>
<a class="header" href="print.html#attributes" id="attributes"><h1>Attributes</h1></a>
<p>Some types and methods can be annotated with attributes. The attribute list is fixed, but eventually (maybe) there will be user-defined attributes.</p>
<a class="header" href="print.html#link" id="link"><h2>Link</h2></a>
<p>Tells the compiler how to link a C library. This is explained in the <a href="c_bindings/lib.html">lib</a> section.</p>
<a class="header" href="print.html#extern" id="extern"><h2>Extern</h2></a>
<p>Marking a Crystal struct with this attribute makes it possible to use it in lib declarations:</p>
<pre><code class="language-crystal">@[Extern]
struct MyStruct
end

lib MyLib
  fun my_func(s : MyStruct) # OK (gives an error without the Extern attribute)
end
</code></pre>
<p>You can also make a struct behave like a C union (this can be pretty unsafe):</p>
<pre><code class="language-crystal"># A struct to easily convert between Int32 codepoints and Chars
@[Extern(union: true)]
struct Int32OrChar
  property int = 0
  property char = '\0'
end

s = Int32OrChar.new
s.char = 'A'
s.int # =&gt; 65

s.int = 66
s.char # =&gt; 'B'
</code></pre>
<a class="header" href="print.html#threadlocal" id="threadlocal"><h2>ThreadLocal</h2></a>
<p>The <code>@[ThreadLocal]</code> attribute can be applied to class variables and C external variables. It makes them be thread local.</p>
<pre><code class="language-crystal">class DontUseThis
  # One for each thread
  @[ThreadLocal]
  @@values = [] of Int32
end
</code></pre>
<p>ThreadLocal is used in the standard library to implement the runtime and shouldn't be
needed or used outside it.</p>
<a class="header" href="print.html#packed" id="packed"><h2>Packed</h2></a>
<p>Marks a <a href="c_bindings/struct.html">C struct</a> as packed, which prevents the automatic insertion of padding bytes between fields. This is typically only needed if the C library explicitly uses packed structs.</p>
<a class="header" href="print.html#alwaysinline" id="alwaysinline"><h2>AlwaysInline</h2></a>
<p>Gives a hint to the compiler to always inline a method:</p>
<pre><code class="language-crystal">@[AlwaysInline]
def foo
  1
end
</code></pre>
<a class="header" href="print.html#noinline" id="noinline"><h2>NoInline</h2></a>
<p>Tells the compiler to never inline a method call. This has no effect if the method yields, since functions which yield are always inlined.</p>
<pre><code class="language-crystal">@[NoInline]
def foo
  1
end
</code></pre>
<a class="header" href="print.html#returnstwice" id="returnstwice"><h2>ReturnsTwice</h2></a>
<p>Marks a method or <a href="c_bindings/fun.html">lib fun</a> as returning twice. The C <code>setjmp</code> is an example of such a function.</p>
<a class="header" href="print.html#raises" id="raises"><h2>Raises</h2></a>
<p>Marks a method or <a href="c_bindings/fun.html">lib fun</a> as potentially raising an exception. This is explained in the <a href="c_bindings/callbacks.html">callbacks</a> section.</p>
<a class="header" href="print.html#callconvention" id="callconvention"><h2>CallConvention</h2></a>
<p>Indicates the call convention of a <a href="c_bindings/fun.html">lib fun</a>. For example:</p>
<pre><code class="language-crystal">lib LibFoo
  @[CallConvention(&quot;X86_StdCall&quot;)]
  fun foo : Int32
end
</code></pre>
<p>The list of valid call conventions is:</p>
<ul>
<li>C (the default)</li>
<li>Fast</li>
<li>Cold</li>
<li>WebKit_JS</li>
<li>AnyReg</li>
<li>X86_StdCall</li>
<li>X86_FastCall</li>
</ul>
<p>They are explained <a href="http://llvm.org/docs/LangRef.html#calling-conventions">here</a>.</p>
<a class="header" href="print.html#flags" id="flags"><h2>Flags</h2></a>
<p>Marks an <a href="enum.html">enum</a> as a &quot;flags enum&quot;, which changes the behaviour of some of its methods, like <code>to_s</code>.</p>
<a class="header" href="print.html#low-level-primitives" id="low-level-primitives"><h1>Low-level primitives</h1></a>
<p>Some low-level primitives are provided. They are mostly useful for interfacing with C libraries and for low-level code.</p>
<a class="header" href="print.html#pointerof" id="pointerof"><h1>pointerof</h1></a>
<p>The <code>pointerof</code> expression returns a <a href="http://crystal-lang.org/api/Pointer.html">Pointer</a> that points to the contents of a variable or instance variable.</p>
<p>An example with a variable:</p>
<pre><code class="language-crystal">a = 1

ptr = pointerof(a)
ptr.value = 2

a #=&gt; 2
</code></pre>
<p>An example with an instance variable:</p>
<pre><code class="language-crystal">class Point
  def initialize(@x : Int32, @y : Int32)
  end

  def x
    @x
  end

  def x_ptr
    pointerof(@x)
  end
end

point = Point.new 1, 2

ptr = point.x_ptr
ptr.value = 10

point.x #=&gt; 10
</code></pre>
<p>Because <code>pointerof</code> involves pointers, it is considered <a href="unsafe.html">unsafe</a>.</p>
<a class="header" href="print.html#sizeof" id="sizeof"><h1>sizeof</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/sizeof.md">syntax_and_semantics/sizeof.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0c157b7eaad13f191ddb73f148171f3579287279">commit 0c157b7eaad13f191ddb73f148171f3579287279</a></p>
</blockquote>
<p><code>sizeof</code> 表达式返回所给定类型字节大小的 <code>Int32</code> 类型值。例如：</p>
<pre><code class="language-crystal">sizeof(Int32)  #=&gt; 4
sizeof(Int64)  #=&gt; 8
</code></pre>
<p>对于<a href="http://crystal-lang.org/api/Reference.html">引用</a>类型来说，其大小等同于指针的大小：</p>
<pre><code class="language-crystal"># On a 64 bits machine
sizeof(Pointer(Int32)) #=&gt; 8
sizeof(String)         #=&gt; 8
</code></pre>
<p>这是因为引用的内存是在堆上分配然后一个指针指向它。可以使用 <a href="instance_sizeof.html">instance_sizeof</a> 来获取一个类的有效大小。</p>
<p>sizeof 的参数是一个<a href="type_grammar.html">类型</a>，且常和 <a href="typeof.html">typeof</a> 结合使用。</p>
<pre><code class="language-crystal">a = 1
sizeof(typeof(a)) #=&gt; 4
</code></pre>
<a class="header" href="print.html#instance_sizeof" id="instance_sizeof"><h1>instance_sizeof</h1></a>
<p>The <code>instance_sizeof</code> expression returns an <code>Int32</code> with the instance size of a given class. For example:</p>
<pre><code class="language-crystal">class Point
  def initialize(@x, @y)
  end
end

Point.new 1, 2

# 2 x Int32 = 2 x 4 = 8
instance_sizeof(Point) #=&gt; 12
</code></pre>
<p>Even though the instance has two <code>Int32</code> fields, the compiler always includes an extra <code>Int32</code> field for the type id of the object. That's why the instance size ends up being 12 and not 8.</p>
<a class="header" href="print.html#uninitialized-variable-declaration" id="uninitialized-variable-declaration"><h1>Uninitialized variable declaration</h1></a>
<p>Crystal allows declaring uninitialized variables:</p>
<pre><code class="language-crystal">x = uninitialized Int32
x #=&gt; some random value, garbage, unreliable
</code></pre>
<p>This is <a href="unsafe.html">unsafe</a> code and is almost always used in low-level code for declaring uninitialized <a href="http://crystal-lang.org/api/StaticArray.html">StaticArray</a> buffers without a performance penalty:</p>
<pre><code class="language-crystal">buffer = uninitialized UInt8[256]
</code></pre>
<p>The buffer is allocated on the stack, avoiding a heap allocation.</p>
<p>The type after the <code>uninitialized</code> keyword follows the <a href="type_grammar.html">type grammar</a>.</p>
<a class="header" href="print.html#compile-time-flags" id="compile-time-flags"><h1>Compile-time flags</h1></a>
<p>Types, methods and generally any part of your code can be conditionally defined based on some flags available at compile time. These flags are by default read from the hosts <a href="http://llvm.org/docs/LangRef.html#target-triple">LLVM Target Triple</a>, split on <code>-</code>. To get the target you can execute <code>llvm-config --host-target</code>.</p>
<pre><code class="language-bash">$ llvm-config --host-target
x86_64-unknown-linux-gnu

# so the flags are: x86_64, unknown, linux, gnu
</code></pre>
<p>To define a flag, simply use the <code>--define</code> or <code>-D</code> option, like so:</p>
<pre><code class="language-bash">$ crystal some_program.cr -Dflag
</code></pre>
<p>Additionally, if a program is compiled with <code>--release</code>, the <code>release</code> flag will be set.</p>
<p>You can check if a flag is defined with the <code>flag?</code> macro method:</p>
<pre><code class="language-crystal">{% if flag?(:x86_64) %}
  # some specific code for 64 bits platforms
{% else %}
  # some specific code for non-64 bits platforms
{% end %}
</code></pre>
<p><code>flag?</code> returns a boolean, so you can use it with <code>&amp;&amp;</code> and <code>||</code>:</p>
<pre><code class="language-crystal">{% if flag?(:linux) &amp;&amp; flag?(:x86_64) %}
  # some specific code for linux 64 bits
{% end %}
</code></pre>
<p>These flags are generally used in C bindings to conditionally define types and functions. For example, the very well known <code>size_t</code> type is defined like this in Crystal:</p>
<pre><code class="language-crystal">lib C
  {% if flag?(:x86_64) %}
    alias SizeT = UInt64
  {% else %}
    alias SizeT = UInt32
  {% end %}
end
</code></pre>
<a class="header" href="print.html#cross-compilation" id="cross-compilation"><h1>Cross-compilation</h1></a>
<p>Crystal supports a basic form of <a href="http://en.wikipedia.org/wiki/Cross_compiler">cross compilation</a>.</p>
<p>In order to achieve this, the compiler executable provides two flags:</p>
<ul>
<li><code>--cross-compile</code>: When given enables cross compilation mode</li>
<li><code>--target</code>: the <a href="http://llvm.org/docs/LangRef.html#target-triple">LLVM Target Triple</a> to use and set the default <a href="compile_time_flags.html">compile-time flags</a> from</li>
</ul>
<p>To get the <code>--target</code> flags you can execute <code>llvm-config --host-target</code> using an installed LLVM 3.5. For example on a Linux it could say &quot;x86_64-unknown-linux-gnu&quot;.</p>
<p>If you need to set any compile-time flags not set implicitly through <code>--target</code>, you can use the <code>-D</code> command line flag.</p>
<p>Using these two, we can compile a program in a Mac that will run on that Linux like this:</p>
<pre><code class="language-bash">crystal build your_program.cr --cross-compile --target &quot;x86_64-unknown-linux-gnu&quot;
</code></pre>
<p>This will generate a <code>.o</code> (<a href="http://en.wikipedia.org/wiki/Object_file">Object file</a>) and will print a line with a command to execute on the system we are trying to cross-compile to. For example:</p>
<pre><code class="language-bash">cc your_program.o -o your_program -lpcre -lrt -lm -lgc -lunwind
</code></pre>
<p>You must copy this <code>.o</code> file to that system and execute those commands. Once you do this the executable will be available in that target system.</p>
<p>This procedure is usually done with the compiler itself to port it to new platforms where a compiler is not yet available. Because in order to compile a Crystal compiler we need an older Crystal compiler, the only two ways to generate a compiler for a system where there isn't a compiler yet are:</p>
<ul>
<li>We checkout the latest version of the compiler written in Ruby, and from that compiler we compile the next versions until the current one.</li>
<li>We create a <code>.o</code> file in the target system and from that file we create a compiler.</li>
</ul>
<p>The first alternative is long and cumbersome, while the second one is much easier.</p>
<p>Cross-compiling can be done for other executables, but its main target is the compiler. If Crystal isn't available in some system you can try cross-compiling it there.</p>
<a class="header" href="print.html#c-bindings" id="c-bindings"><h1>C bindings</h1></a>
<p>Crystal allows you to bind to existing C libraries without writing a single line in C.</p>
<p>Additionally, it provides some conveniences like <code>out</code> and <code>to_unsafe</code> so writing bindings is as painless as possible.</p>
<a class="header" href="print.html#lib" id="lib"><h1>lib</h1></a>
<p>A <code>lib</code> declaration groups C functions and types that belong to a library.</p>
<pre><code class="language-crystal">@[Link(&quot;pcre&quot;)]
lib LibPCRE
end
</code></pre>
<p>Although not enforced by the compiler, a <code>lib</code>'s name usually starts with <code>Lib</code>.</p>
<p>Attributes are used to pass flags to the linker to find external libraries:</p>
<ul>
<li><code>@[Link(&quot;pcre&quot;)]</code> will pass <code>-lpcre</code> to the linker, but the compiler will first try to use <a href="http://en.wikipedia.org/wiki/Pkg-config">pkg-config</a>.</li>
<li><code>@[Link(ldflags: &quot;...&quot;)]</code> will pass those flags directly to the linker, without modification. For example: <code>@[Link(ldflags: &quot;-lpcre&quot;)]</code>. A common technique is to use backticks to execute commands: <code>@[Link(ldflags: &quot;`pkg-config libpcre --libs`&quot;)]</code>.</li>
<li><code>@[Link(framework: &quot;Cocoa&quot;)]</code> will pass <code>-framework Cocoa</code> to the linker (only useful in Mac OS X).</li>
</ul>
<p>Attributes can be omitted if the library is implicitly linked, as in the case of libc.</p>
<a class="header" href="print.html#fun" id="fun"><h1>fun</h1></a>
<p>A <code>fun</code> declaration inside a <code>lib</code> binds to a C function.</p>
<pre><code class="language-crystal">lib C
  # In C: double cos(double x)
  fun cos(value : Float64) : Float64
end
</code></pre>
<p>Once you bind it, the function is available inside the <code>C</code> type as if it was a class method:</p>
<pre><code class="language-crystal">C.cos(1.5) #=&gt; 0.0707372
</code></pre>
<p>You can omit the parentheses if the function doesn't have arguments (and omit them in the call as well):</p>
<pre><code class="language-crystal">lib C
  fun getch : Int32
end

C.getch
</code></pre>
<p>If the return type is void you can omit it:</p>
<pre><code class="language-crystal">lib C
  fun srand(seed : UInt32)
end

C.srand(1_u32)
</code></pre>
<p>You can bind to variadic functions:</p>
<pre><code class="language-crystal">lib X
  fun variadic(value : Int32, ...) : Int32
end

X.variadic(1, 2, 3, 4)
</code></pre>
<p>Note that there are no implicit conversions (except <code>to_unsafe</code>, which is explained later) when invoking a C function: you must pass the exact type that is expected. For integers and floats you can use the various <code>to_...</code> methods.</p>
<a class="header" href="print.html#function-names" id="function-names"><h2>Function names</h2></a>
<p>Function names in a <code>lib</code> definition can start with an upper case letter. That's different from methods and function definitions outside a <code>lib</code>, which must start with a lower case letter.</p>
<p>Function names in Crystal can be different from the C name. The following example shows how to bind the C function name <code>SDL_Init</code> as <code>LibSDL.init</code> in Crystal.</p>
<pre><code class="language-crystal">lib LibSDL
  fun init = SDL_Init(flags : UInt32) : Int32
end
</code></pre>
<p>The C name can be put in quotes to be able to write a name that is not a valid identifier:</p>
<pre><code class="language-crystal">lib LLVMIntrinsics
  fun ceil_f32 = &quot;llvm.ceil.f32&quot;(value : Float32) : Float32
end
</code></pre>
<p>This can also be used to give shorter, nicer names to C functions, as these tend to be long and are usually prefixed with the library name.</p>
<a class="header" href="print.html#types-in-c-bindings" id="types-in-c-bindings"><h2>Types in C Bindings</h2></a>
<p>The valid types to use in C bindings are:</p>
<ul>
<li>Primitive types (<code>Int8</code>, ..., <code>Int64</code>, <code>UInt8</code>, ..., <code>UInt64</code>, <code>Float32</code>, <code>Float64</code>)</li>
<li>Pointer types (<code>Pointer(Int32)</code>, which can also be written as <code>Int32*</code>)</li>
<li>Static arrays (<code>StaticArray(Int32, 8)</code>, which can also be written as <code>Int32[8]</code>)</li>
<li>Function types (<code>Function(Int32, Int32)</code>, which can also be written as <code>Int32 -&gt; Int32</code>)</li>
<li>Other <code>struct</code>, <code>union</code>, <code>enum</code>, <code>type</code> or <code>alias</code> declared previously.</li>
<li><code>Void</code>: the absence of a return value.</li>
<li><code>NoReturn</code>: similar to <code>Void</code>, but the compiler understands that no code can be executed after that invocation.</li>
<li>Crystal structs marked with the <code>@[Extern]</code> attribute</li>
</ul>
<p>Refer to the <a href="../type_grammar.html">type grammar</a> for the notation used in fun types.</p>
<p>The standard library defines the <a href="https://github.com/crystal-lang/crystal/blob/master/src/lib_c.cr">LibC</a> lib with aliases for common C types, like <code>int</code>, <code>short</code>, <code>size_t</code>. Use them in bindings like this:</p>
<pre><code class="language-crystal">lib MyLib
  fun my_fun(some_size : LibC::SizeT)
end
</code></pre>
<p><strong>Note:</strong> The C <code>char</code> type is <code>UInt8</code> in Crystal, so a <code>char*</code> or a <code>const char*</code> is <code>UInt8*</code>. The <code>Char</code> type in Crystal is a unicode codepoint so it is represented by four bytes, making it similar to an <code>Int32</code>, not to an <code>UInt8</code>. There's also the alias <code>LibC::Char</code> if in doubt.</p>
<a class="header" href="print.html#out" id="out"><h1>out</h1></a>
<p>Consider the <a href="http://www.gnu.org/software/libc/manual/html_node/Process-Completion.html">waitpid</a> function:</p>
<pre><code class="language-crystal">lib C
  fun waitpid(pid : Int32, status_ptr : Int32*, options : Int32) : Int32
end
</code></pre>
<p>The documentation of the function says:</p>
<pre><code>The status information from the child process is stored in the object
that status_ptr points to, unless status_ptr is a null pointer.
</code></pre>
<p>We can use this function like this:</p>
<pre><code class="language-crystal">pid = ...
options = ...
status_ptr = uninitialized Int32

C.waitpid(pid, pointerof(status_ptr), options)
</code></pre>
<p>In this way we pass a pointer of <code>status_ptr</code> to the function for it to fill its value.</p>
<p>There's a simpler way to write the above by using an <code>out</code> parameter:</p>
<pre><code class="language-crystal">pid = ...
options = ...

C.waitpid(pid, out status_ptr, options)
</code></pre>
<p>The compiler will automatically declare a <code>status_ptr</code> variable of type <code>Int32</code>, because the argument is an <code>Int32*</code>.</p>
<p>This will work for any type, as long as the argument is a pointer of that type (and, of course, as long as the function does fill the value the pointer is pointing to).</p>
<a class="header" href="print.html#to_unsafe" id="to_unsafe"><h1>to_unsafe</h1></a>
<p>If a type defines a <code>to_unsafe</code> method, when passing it to C the value returned by this method will be passed. For example:</p>
<pre><code class="language-crystal">lib C
  fun exit(status : Int32) : NoReturn
end

class IntWrapper
  def initialize(@value)
  end

  def to_unsafe
    @value
  end
end

wrapper = IntWrapper.new(1)
C.exit(wrapper) # wrapper is not an Int32, but its to_unsafe
                # method is, so wrapper.to_unsafe
                # is passed instead
</code></pre>
<p>This is very useful for defining wrappers of C types without having to explicitly transform them to their wrapped values.</p>
<p>For example, the <code>String</code> class implements <code>to_unsafe</code> to return <code>UInt8*</code>:</p>
<pre><code class="language-crystal">lib C
  fun printf(format : UInt8*, ...) : Int32
end

a = 1
b = 2
C.printf &quot;%d + %d = %d\n&quot;, a, b, a + b
</code></pre>
<a class="header" href="print.html#struct" id="struct"><h1>struct</h1></a>
<p>A <code>struct</code> declaration inside a <code>lib</code> declares a C struct.</p>
<pre><code class="language-crystal">lib C
  # In C:
  #
  #  struct TimeZone {
  #    int minutes_west;
  #    int dst_time;
  #  };
  struct TimeZone
    minutes_west : Int32
    dst_time     : Int32
  end
end
</code></pre>
<p>You can also specify many fields of the same type:</p>
<pre><code class="language-crystal">lib C
  struct TimeZone
    minutes_west, dst_time : Int32
  end
end
</code></pre>
<p>Recursive structs work just like you expect them to:</p>
<pre><code class="language-crystal">lib C
  struct LinkedListNode
    prev, _next : LinkedListNode*
  end
  
  struct LinkedList
    head : LinkedListNode*
  end
end
</code></pre>
<p>To create an instance of a struct use <code>new</code>:</p>
<pre><code class="language-crystal">tz = C::TimeZone.new
</code></pre>
<p>This allocates the struct on the stack.</p>
<p>A C struct starts with all its fields set to &quot;zero&quot;: integers and floats start at zero, pointers start with an address of zero, etc.</p>
<p>To avoid this initialization you can use <code>uninitialized</code>:</p>
<pre><code class="language-crystal">tz = uninitialized C::TimeZone
tz.minutes_west #=&gt; some garbage value
</code></pre>
<p>You can set and get its properties:</p>
<pre><code class="language-crystal">tz = C::TimeZone.new
tz.minutes_west = 1
tz.minutes_west #=&gt; 1
</code></pre>
<p>If the assigned value is not exactly the same as the property's type, <a href="to_unsafe.html">to_unsafe</a> will be tried.</p>
<p>You can also initialize some fields with a syntax similar to <a href="../default_and_named_arguments.html">named arguments</a>:</p>
<pre><code class="language-crystal">tz = C::TimeZone.new minutes_west: 1, dst_time: 2
tz.minutes_west #=&gt; 1
tz.dst_time     #=&gt; 2
</code></pre>
<p>A C struct is passed by value (as a copy) to functions and methods, and also passed by value when it is returned from a method:</p>
<pre><code class="language-crystal">def change_it(tz)
  tz.minutes_west = 1
end

tz = C::TimeZone.new
change_it tz
tz.minutes_west #=&gt; 0
</code></pre>
<p>Refer to the <a href="../type_grammar.html">type grammar</a> for the notation used in struct field types.</p>
<a class="header" href="print.html#union-1" id="union-1"><h1>union</h1></a>
<p>A <code>union</code> declaration inside a <code>lib</code> declares a C union:</p>
<pre><code class="language-crystal">lib U
  # In C:
  #
  #  union IntOrFloat {
  #    int some_int;
  #    double some_float;
  #  };
  union IntOrFloat
    some_int : Int32
    some_float : Float64
  end
end
</code></pre>
<p>To create an instance of a union use <code>new</code>:</p>
<pre><code class="language-crystal">value = U::IntOrFloat.new
</code></pre>
<p>This allocates the union on the stack.</p>
<p>A C union starts with all its fields set to &quot;zero&quot;: integers and floats start at zero, pointers start with an address of zero, etc.</p>
<p>To avoid this initialization you can use <code>uninitialized</code>:</p>
<pre><code class="language-crystal">value = uninitialized U::IntOrFloat
value.some_int #=&gt; some garbage value
</code></pre>
<p>You can set and get its properties:</p>
<pre><code class="language-crystal">value = U::IntOrFloat.new
value.some_int = 1
value.some_int #=&gt; 1
value.some_float #=&gt; 4.94066e-324
</code></pre>
<p>If the assigned value is not exactly the same as the property's type, <a href="to_unsafe.html">to_unsafe</a> will be tried.</p>
<p>A C union is passed by value (as a copy) to functions and methods, and also passed by value when it is returned from a method:</p>
<pre><code class="language-crystal">def change_it(value)
  value.some_int = 1
end

value = U::IntOrFloat.new
change_it value
value.some_int #=&gt; 0
</code></pre>
<p>Refer to the <a href="../type_grammar.html">type grammar</a> for the notation used in union field types.</p>
<a class="header" href="print.html#enum" id="enum"><h1>enum</h1></a>
<p>An <code>enum</code> declaration inside a <code>lib</code> declares a C enum:</p>
<pre><code class="language-crystal">lib X
  # In C:
  #
  #  enum SomeEnum {
  #    Zero,
  #    One,
  #    Two,
  #    Three,
  #  };
  enum SomeEnum
    Zero
    One
    Two
    Three
  end
end
</code></pre>
<p>As in C, the first member of the enum has a value of zero and each successive value is incremented by one.</p>
<p>To use a value:</p>
<pre><code class="language-crystal">X::SomeEnum::One #=&gt; One
</code></pre>
<p>You can specify the value of a member:</p>
<pre><code class="language-crystal">lib X
  enum SomeEnum
    Ten = 10
    Twenty = 10 * 2
    ThirtyTwo = 1 &lt;&lt; 5
  end
end
</code></pre>
<p>As you can see, some basic math is allowed for a member value: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&amp;</code>, <code>|</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code> and <code>%</code>.</p>
<p>The type of an enum member is <code>Int32</code> by default, even if you specify a different type in a constant value:</p>
<pre><code class="language-crystal">lib X
  enum SomeEnum
    A = 1_u32
  end
end

X::SomeEnum #=&gt; 1_i32
</code></pre>
<p>However, you can change this default type:</p>
<pre><code class="language-crystal">lib X
  enum SomeEnum : Int8
    Zero,
    Two = 2
  end
end

X::SomeEnum::Zero #=&gt; 0_i8
X::SomeEnum::Two  #=&gt; 2_i8
</code></pre>
<p>You can use an enum as a type in a <code>fun</code> argument or <code>struct</code> or <code>union</code> members:</p>
<pre><code class="language-crystal">lib X
  enum SomeEnum
    One
    Two
  end

  fun some_fun(value : SomeEnum)
end
</code></pre>
<a class="header" href="print.html#variables" id="variables"><h1>Variables</h1></a>
<p>Variables exposed by a C library can be declared inside a <code>lib</code> declaration using a global-variable-like declaration:</p>
<pre><code class="language-crystal">lib C
  $errno : Int32
end
</code></pre>
<p>Then it can be get and set:</p>
<pre><code class="language-crystal">C.errno #=&gt; some value
C.errno = 0
C.errno #=&gt; 0
</code></pre>
<p>A variable can be marked as thread local with an attribute:</p>
<pre><code class="language-crystal">lib C
  @[ThreadLocal]
  $errno : Int32
end
</code></pre>
<p>Refer to the <a href="../type_grammar.html">type grammar</a> for the notation used in external variables types.</p>
<a class="header" href="print.html#a常量-1" id="a常量-1"><h1>常量</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/c_bindings/constants.md">syntax_and_semantics/c_bindings/constants.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0c157b7eaad13f191ddb73f148171f3579287279">commit 0c157b7eaad13f191ddb73f148171f3579287279</a></p>
</blockquote>
<p>也可以在一个 <code>lib</code> 声明中声明常量：</p>
<pre><code class="language-crystal">@[Link(&quot;pcre&quot;)]
lib PCRE
  INFO_CAPTURECOUNT = 2
end

PCRE::INFO_CAPTURECOUNT #=&gt; 2
</code></pre>
<a class="header" href="print.html#a类型" id="a类型"><h1>类型</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/c_bindings/type.md">syntax_and_semantics/c_bindings/type.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/974511cd057ed5b3d54a5b08704241500c56ef34">commit 974511cd057ed5b3d54a5b08704241500c56ef34&gt;</a></p>
</blockquote>
<p><code>lib</code> 中的 <code>type</code> 声明了一种 C 语言的 <code>typedef</code>，但比 C 语言的 <code>typedef</code> 更强大：</p>
<pre><code class="language-crystal">lib X
  type MyInt = Int32
end
</code></pre>
<p>和 C 语言不同，<code>Int32</code> 和 <code>MyInt</code> 是无法互换的：</p>
<pre><code class="language-crystal">lib X
  type MyInt = Int32

  fun some_fun(value : MyInt)
end

X.some_fun 1 # Error: argument 'value' of 'X#some_fun'
             # must be X::MyInt, not Int32
</code></pre>
<p>因此， <code>type</code> 声明对于那些由封装的 C 库所创建的难懂的类型是非常有用的。例如，从 <code>fopen</code> 函数返回的 <code>FILE</code> 类型。</p>
<p>参考<a href="../type_grammar.html">类型语法</a>来获取在使用 typedef 类型时的注意事项。</p>
<a class="header" href="print.html#alias" id="alias"><h1>alias</h1></a>
<p>An <code>alias</code> declaration inside a <code>lib</code> declares a C <code>typedef</code>:</p>
<pre><code class="language-crystal">lib X
  alias MyInt = Int32
end
</code></pre>
<p>Now <code>Int32</code> and <code>MyInt</code> are interchangeable:</p>
<pre><code class="language-crystal">lib X
  alias MyInt = Int32

  fun some_fun(value : MyInt)
end

X.some_fun 1 # OK
</code></pre>
<p>An <code>alias</code> is most useful to avoid writing long types over and over, but also to declare a type based on compile-time flags:</p>
<pre><code class="language-crystal">lib C
  {% if flag?:(x86_64) %}
    alias SizeT = Int64
  {% else %}
    alias SizeT = Int32
  {% end %}

  fun memcmp(p1 : Void*, p2 : Void*, size : C::SizeT) : Int32
end
</code></pre>
<p>Refer to the <a href="../type_grammar.html">type grammar</a> for the notation used in alias types.</p>
<a class="header" href="print.html#callbacks" id="callbacks"><h1>Callbacks</h1></a>
<p>You can use function types in C declarations:</p>
<pre><code class="language-crystal">lib X
  # In C:
  #
  #    void callback(int (*f)(int));
  fun callback(f : Int32 -&gt; Int32)
end
</code></pre>
<p>Then you can pass a function (a <a href="http://crystal-lang.org/api/Proc.html">Proc</a>) like this:</p>
<pre><code class="language-crystal">f = -&gt;(x : Int32) { x + 1 }
X.callback(f)
</code></pre>
<p>If you define the function inline in the same call you can omit the argument types, the compiler will add the types for you based on the <code>fun</code> signature:</p>
<pre><code class="language-crystal">X.callback -&gt;(x) { x + 1 }
</code></pre>
<p>Note, however, that functions passed to C can't form closures. If the compiler detects at compile-time that a closure is being passed, an error will be issued:</p>
<pre><code class="language-crystal">y = 2
X.callback -&gt;(x) { x + y } # Error: can't send closure
                           # to C function
</code></pre>
<p>If the compiler can't detect this at compile-time, an exception will be raised at runtime.</p>
<p>Refer to the <a href="../type_grammar.html">type grammar</a> for the notation used in callbacks and procs types.</p>
<p>If you want to pass <code>NULL</code> instead of a callback, just pass <code>nil</code>:</p>
<pre><code class="language-crystal"># Same as callback(NULL) in C
X.callback nil
</code></pre>
<a class="header" href="print.html#passing-a-closure-to-a-c-function" id="passing-a-closure-to-a-c-function"><h3>Passing a closure to a C function</h3></a>
<p>Most of the time a C function that allows setting a callback also provide an argument for custom data. This custom data is then sent as an argument to the callback. For example, suppose a C function that invokes a callback at every tick, passing that tick:</p>
<pre><code class="language-crystal">lib LibTicker
  fun on_tick(callback : (Int32, Void* -&gt;), data : Void*)
end
</code></pre>
<p>To properly define a wrapper for this function we must send the Proc as the callback data, and then convert that callback data to the Proc and finally invoke it.</p>
<pre><code class="language-crystal">module Ticker
  @@box : Box(Int32 -&gt;)

  # The callback for the user doesn't have a Void*
  def self.on_tick(&amp;callback : Int32 -&gt;)
    # Since Proc is a {Void*, Void*}, we can't turn that into a Void*, so we
    # &quot;box&quot; it: we allocate memory and store the Proc there
    boxed_data = Box.box(callback)

    # We must save this in Crystal-land so the GC doesn't collect it (*)
    @@box = boxed_data

    # We pass a callback that doesn't form a closure, and pass the boxed_data as
    # the callback data
    LibTicker.on_tick(-&gt;(tick, data) {
      # Now we turn data back into the Proc, using Box.unbox
      data_as_callback = Box(typeof(callback)).unbox(data)
      # And finally invoke the user's callback
      data_as_callback.call(tick)
    }, boxed_data)
  end
end

Ticker.on_tick do |tick|
  puts tick
end
</code></pre>
<p>Note that we save the boxed callback in <code>@@box</code>. The reason is that if we don't do it, and our code doesn't reference it anymore, the GC will collect it. The C library will of course store the callback, but Crystal's GC has no way of knowing that.</p>
<a class="header" href="print.html#raises-attribute" id="raises-attribute"><h2>Raises attribute</h2></a>
<p>If a C function executes a user-provided callback that might raise, it must be annotated with the <code>@[Raises]</code> attribute.</p>
<p>The compiler infers this attribute for a method if it invokes a method that is marked as <code>@[Raises]</code> or raises (recursively).</p>
<p>However, some C functions accept callbacks to be executed by other C functions. For example, suppose a fictitious library:</p>
<pre><code class="language-crystal">lib LibFoo
  fun store_callback(callback : -&gt;)
  fun execute_callback
end

LibFoo.store_callback -&gt;{ raise &quot;OH NO!&quot; }
LibFoo.execute_callback
</code></pre>
<p>If the callback passed to <code>store_callback</code> raises, then <code>execute_callback</code> will raise. However, the compiler doesn't know that <code>execute_callback</code> can potentially raise because it is not marked as <code>@[Raises]</code> and the compiler has no way to figure this out. In these cases you have to manually mark such functions:</p>
<pre><code class="language-crystal">lib LibFoo
  fun store_callback(callback : -&gt;)

  @[Raises]
  fun execute_callback
end
</code></pre>
<p>If you don't mark them, <code>begin/rescue</code> blocks that surround this function's calls won't work as expected.</p>
<a class="header" href="print.html#a不安全代码" id="a不安全代码"><h1>不安全代码</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/syntax_and_semantics/unsafe.md">syntax_and_semantics/unsafe.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/0c157b7eaad13f191ddb73f148171f3579287279">commit 0c157b7eaad13f191ddb73f148171f3579287279</a></p>
</blockquote>
<p>Crystal 语言的这部分被认为是不安全的：</p>
<ul>
<li>代码调用原生指针：<a href="http://crystal-lang.org/api/Pointer.html">Pointer</a> 类型与 <a href="pointerof.html">pointerof</a></li>
<li><a href="new,_initialize_and_allocate.html">allocate</a> 类方法</li>
<li>代码调用 C 语言绑定</li>
<li><a href="declare_var.html">未初始化变量声明</a></li>
</ul>
<p>“不安全”意味着可能发生内存泄漏、段错误和程序崩溃。例如：</p>
<pre><code class="language-crystal">a = 1
ptr = pointerof(a)
ptr[100_000] = 2   # undefined behaviour, probably a segmentation fault
</code></pre>
<p>然而，正常的代码通常不会调用指针操作或未初始化变量，以及 C 语言绑定通常被封装在安全的封装器之中，其包括空指针和范围检查。</p>
<p>没有语言是 100% 安全的：一些部分必将处于低级别，操作系统相关的接口和涉及指针操作。但是一旦将其抽象然后在更高级别上操作，并假设（经过数学证明或彻底测试之后）低级部分是安全的，则可以确信整个代码是安全的。</p>
<a class="header" href="print.html#a惯例" id="a惯例"><h1>惯例</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/conventions/README.md">conventions/README.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/f3302ae47c34ccd5f7ef22d5cbdced382cc853bf">commit f3302ae47c34ccd5f7ef22d5cbdced382cc853bf</a></p>
</blockquote>
<p>遵从下面这些惯例，因此，你的代码会被其他开发者更容易理解。</p>
<ul>
<li>使用 <a href="coding_style.md">标准代码风格</a>，对其他人来说，你的项目会可操作和可读。</li>
<li>编写<a href="documenting_code.md">文档</a>以解释代码的目的，并可支持 <code>crystal doc</code> 生成器。</li>
</ul>
<a class="header" href="print.html#a代码风格" id="a代码风格"><h1>代码风格</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/conventions/coding_style.md">conventions/coding_style.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/261694dcfb416870928ca6593f065b39d2d6c283">commit 261694dcfb416870928ca6593f065b39d2d6c283</a></p>
</blockquote>
<p>该代码风格在标准库中被使用。可以在你自己的项目中使用该代码风格，以便为其他开发者所熟悉。</p>
<a class="header" href="print.html#a命名" id="a命名"><h2>命名</h2></a>
<p>驼峰式__类型名__。例如：</p>
<pre><code class="language-crystal">class ParseError &lt; Exception
end

module HTTP
  class RequestHandler
  end
end

alias NumericValue = Float32 | Float64 | Int32 | Int64

lib LibYAML
end

struct TagDirective
end

enum Time::DayOfWeek
end
</code></pre>
<p>下划线式__方法名__。例如：</p>
<pre><code class="language-crystal">class Person
  def first_name
  end

  def date_of_birth
  end

  def homepage_url
  end
end
</code></pre>
<p>下划线式__变量名__。例如：</p>
<pre><code class="language-crystal">class Greeting
  @@default_greeting = &quot;Hello world&quot;

  def initialize(@custom_greeting = nil)
  end

  def print_greeting
    greeting = @custom_greeting || @@default_greeting
    puts greeting
  end
end
</code></pre>
<p>尖锐式__常量名__。例如：</p>
<pre><code class="language-crystal">LUCKY_NUMBERS     = [3, 7, 11]
DOCUMENTATION_URL = &quot;http://crystal-lang.org/docs&quot;
</code></pre>
<a class="header" href="print.html#a缩写" id="a缩写"><h3>缩写</h3></a>
<p>类名中，缩写全部_大写_。例如：<code>HTTP</code> 和 <code>LibXML</code>。</p>
<p>方法名中，缩写全部小写。例如 <code>#from_json</code> 和 <code>#to_io</code> 。</p>
<a class="header" href="print.html#a库" id="a库"><h3>库</h3></a>
<p><code>Lib</code> 名以 <code>Lib</code> 为前缀。例如：<code>LibC</code> 和 <code>LibEvent2</code> 。</p>
<a class="header" href="print.html#a目录和文件名" id="a目录和文件名"><h3>目录和文件名</h3></a>
<p>在项目中：</p>
<ul>
<li><code>/</code> 包含 readme 、任何项目配置（如 CI 或其他配置）、任何其他项目级文档（如 changlog 或贡献指引）。</li>
<li><code>src/</code> 包含项目源代码。</li>
<li><code>spec/</code> 包含<a href="../guides/testing.md">项目 specs</a> ，其可以用 <code>crystal spec</code> 来执行。</li>
<li><code>bin/</code> 包含可执行文件。</li>
</ul>
<p>文件路径与其内容相匹配。文件以其定义的类名或命名空间名为名，并使用_下划线式_。
例如，<code>HTTP::WebSocket</code> 定义在 <code>src/http/web_socket.cr</code> 中。</p>
<a class="header" href="print.html#a空格" id="a空格"><h2>空格</h2></a>
<p>在命名空间、代码块或其他内嵌内容中，使用__两个空格__缩进代码。例如：</p>
<pre><code class="language-crystal">module Scorecard
  class Parser
    def parse(score_text)
      begin
        score_text.scan(SCORE_PATTERN) do |match|
          handle_match(match)
        end
      rescue err : ParseError
        # handle error ...
      end
    end
  end
end
</code></pre>
<p>在类中，用__换行符__隔开代码定义、常量以及其他类内部的定义。例如：</p>
<pre><code class="language-crystal">module Money
  CURRENCIES = {
    &quot;EUR&quot; =&gt; 1.0,
    &quot;ARS&quot; =&gt; 10.55,
    &quot;USD&quot; =&gt; 1.12,
    &quot;JPY&quot; =&gt; 134.15,
  }

  class Amount
    getter :currency, :value

    def initialize(@currency, @value)
    end
  end

  class CurrencyConversion
    def initialize(@amount, @target_currency)
    end

    def amount
      # implement conversion ...
    end
  end
end
</code></pre>
<a class="header" href="print.html#a文档化代码" id="a文档化代码"><h1>文档化代码</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/conventions/documenting_code.md">conventions/documenting_code.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/3b8344fba1d309657d15060009811376455c9d08">commit 3b8344fba1d309657d15060009811376455c9d08</a></p>
</blockquote>
<p>Crystal 文档注释使用 <a href="https://daringfireball.net/projects/markdown/">Markdown</a> 的子集。</p>
<ul>
<li>文档应该放在类、模块以及方法的正上面。二者之间无空格。</li>
</ul>
<pre><code class="language-crystal"># A unicorn is a **legendary animal** (see the `Legendary` module) that has been
# described since antiquity as a beast with a large, spiraling horn projecting
# from its forehead.
class Unicorn
end

# Bad: This is not attached to any class.

class Legendary
end
</code></pre>
<ul>
<li>
<p>方法文档放在方法摘要和方法实现的内部。前者只有第一行，后者包括整个文档。简言之，是指：</p>
<ol>
<li>在第一行说明方法的目的或功能。</li>
<li>随后补充使用细节。</li>
</ol>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-crystal"># Returns the number of horns this unicorn has.
#
# ```
# Unicorn.new.horns # =&gt; 1
# ```
def horns
  @horns
end
</code></pre>
<ul>
<li>
<p>使用第三人称：<code>Returns the number of horns this unicorn has</code> 而不是 <code>Return the number of horns this unicorn has</code> 。</p>
</li>
<li>
<p>参数名应该 <em>italicized</em> （以单个<code>星号</code>或<code>下划线</code>包围）：</p>
</li>
</ul>
<pre><code class="language-crystal"># Creates a unicorn with the specified number of *horns*.
def initialize(@horns = 1)
  raise &quot;Not a unicorn&quot; if @horns != 1
end
</code></pre>
<ul>
<li>有 Crystal 代码的代码块应该使用三个反引号(```) 或四个空格缩进。</li>
</ul>
<pre><code class="language-crystal"># ```
# unicorn = Unicorn.new
# unicorn.speak
# ```
</code></pre>
<p>或者</p>
<pre><code class="language-crystal">#     unicorn = Unicorn.new
#     unicorn.speak
</code></pre>
<ul>
<li>文本块必须以三个反引号(```) 并随后跟 &quot;text&quot; 来包围，例如，显示程序输出。</li>
</ul>
<pre><code class="language-crystal"># ```text
# &quot;I'm a unicorn&quot;
# ```
</code></pre>
<ul>
<li>使用一个反引号来自动连接到其他的类型。</li>
</ul>
<pre><code class="language-crystal"># the `Legendary` module
</code></pre>
<ul>
<li>
<p>使用 <code>#horns</code> 或 <code>#index(char)</code>并用单个反引号包围这样的 hash 来把当前文档化的类型自动连接到方法上。</p>
</li>
<li>
<p>使用 <code>OtherType#method(arg1, arg2)</code> 或只用 <code>OtherType#method</code> 并用单个反引号包围来将其他类型自动链接到方法上。</p>
</li>
</ul>
<p>例如：</p>
<pre><code class="language-crystal"># Check the number of horns with `#horns`.
# See what a unicorn would say with `Unicorn#speak`.
</code></pre>
<ul>
<li>使用 <code># =&gt;</code> 来显示代码块中表达式的值。</li>
</ul>
<pre><code class="language-crystal">1 + 2             # =&gt; 3
Unicorn.new.speak # =&gt; &quot;I'm a unicorn&quot;
</code></pre>
<ul>
<li>像之前的声明那样把 <code>ditto</code> 应用于同样的注释中。</li>
</ul>
<pre><code class="language-crystal"># ditto
def number_of_horns
  horns
end
</code></pre>
<ul>
<li>在生成的文档中，使用 <code>:nodoc:</code> 来隐藏共有的声明。私有的和受保护的方法总是被隐藏的。</li>
</ul>
<pre><code class="language-crystal">class Unicorn
  # :nodoc:
  class Helper
  end
end
</code></pre>
<a class="header" href="print.html#a标记类模块和方法" id="a标记类模块和方法"><h3>标记类、模块和方法</h3></a>
<p>考虑到关键字，Crystal 会自动生成可视化标记以帮助高亮问题、注意点或（和）可能的问题。</p>
<p>支持的标记：</p>
<ul>
<li>BUG</li>
<li>DEPRECATED</li>
<li>FIXME</li>
<li>NOTE</li>
<li>OPTIMIZE</li>
<li>TODO</li>
</ul>
<p>关键字标记必须放在各自行的行首，并且都必须大写。为了可读性，可选择结尾冒号。</p>
<pre><code class="language-crystal"># Makes the unicorn speak to STDOUT
#
# NOTE: Although unicorns don't normally talk, this one is special
# TODO: Check if unicorn is asleep and raise exception if not able to speak
# TODO: Create another `speak` method that takes and prints a string
def speak
  puts &quot;I'm a unicorn&quot;
end

# Makes the unicorn talk to STDOUT
#
# DEPRECATED: Use `speak`
def talk
  puts &quot;I'm a unicorn&quot;
end
</code></pre>
<a class="header" href="print.html#a使用-crystal-的代码格式器" id="a使用-crystal-的代码格式器"><h3>使用 Crystal 的代码格式器</h3></a>
<p>Crystal 内置的代码格式器不仅可以用于格式化代码，而且也可以格式化文档块中的代码示例。</p>
<p>当调用 <code>crystal tool format</code> 时，这会自动完成，其会自动格式化当前目录下的所有 <code>.cr</code> 文件。</p>
<p>格式化单个文件：</p>
<pre><code>$ crystal tool format file.cr
</code></pre>
<p>格式化目录下所有 <code>.cr</code> 文件：</p>
<pre><code>$ crystal tool format src/
</code></pre>
<p>用这个工具来统一代码风格并为 Crystal 自身提升文档化。</p>
<p>格式化也非常快，所以相比于单个文件，格式化整个项目只使用一点点时间。</p>
<a class="header" href="print.html#a一个完整的例子" id="a一个完整的例子"><h3>一个完整的例子</h3></a>
<pre><code class="language-crystal"># A unicorn is a **legendary animal** (see the `Legendary` module) that has been
# described since antiquity as a beast with a large, spiraling horn projecting
# from its forehead.
#
# To create a unicorn:
#
# ```
# unicorn = Unicorn.new
# unicorn.speak
# ```
#
# The above produces:
#
# ```text
# &quot;I'm a unicorn&quot;
# ```
#
# Check the number of horns with `#horns`.
class Unicorn
  include Legendary

  # Creates a unicorn with the specified number of *horns*.
  def initialize(@horns = 1)
    raise &quot;Not a unicorn&quot; if @horns != 1
  end

  # Returns the number of horns this unicorn has
  #
  # ```
  # Unicorn.new.horns # =&gt; 1
  # ```
  def horns
    @horns
  end

  # ditto
  def number_of_horns
    horns
  end

  # Makes the unicorn speak to STDOUT
  def speak
    puts &quot;I'm a unicorn&quot;
  end

  # :nodoc:
  class Helper
  end
end
</code></pre>
<a class="header" href="print.html#a生成文档" id="a生成文档"><h3>生成文档</h3></a>
<p>调用 <code>crystal docs</code> 来生成项目文档。这会创建一个以 <code>docs/index.html</code> 为入口的 <code>docs</code> 目录。要考虑在 <code>src</code> 根目录下的所有文件。</p>
<a class="header" href="print.html#a数据库" id="a数据库"><h1>数据库</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/database/README.md">database/README.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/266dc253028ecdf07a0e8cb14fb783e747c7104c">commit 266dc253028ecdf07a0e8cb14fb783e747c7104c</a></p>
</blockquote>
<p>可以使用一个为数据库服务器设计的 shard 来访问关系型数据库。在不同的驱动上，<a href="https://github.com/crystal-lang/crystal-db">crystal-lang/crystal-db</a> 提供了统一的 api 接口。</p>
<p>下面的包适用于 crystal-db：</p>
<ul>
<li>sqlite 的 <a href="https://github.com/crystal-lang/crystal-sqlite3">crystal-lang/crystal-sqlite3</a></li>
<li>mysql 和 mariadb 的 <a href="https://github.com/crystal-lang/crystal-mysql">crystal-lang/crystal-mysql</a></li>
<li>postgres 的 <a href="https://github.com/will/crystal-pg">will/crystal-pg</a></li>
</ul>
<p>该指引提供 crystal-db 的 api ，鉴于 postgres 、mysql 和 sqlit 的差异，根据具体的驱动，需要 合适的 sql 命令。</p>
<p>另外，一些驱动可能会提供额外的功能，如 postgres 的 <code>LISTEN</code>/<code>NOTIFY</code> 。</p>
<a class="header" href="print.html#a安装-shard" id="a安装-shard"><h2>安装 shard</h2></a>
<p>和其他 shard 一样，从上面列表中选择适当的驱动并把它加入到应用的 <code>shard.yml</code> 文件中。</p>
<p>不需要再明确地导入 <code>crystal-lang/crystal-db</code> 。</p>
<p>在本指引中，使用 <code>crystal-lang/crystal-mysql</code> 。</p>
<pre><code class="language-yaml">dependencies:
  mysql:
    github: crystal-lang/crystal-mysql
</code></pre>
<a class="header" href="print.html#a打开数据库连接" id="a打开数据库连接"><h2>打开数据库连接</h2></a>
<p>通过连接 url ，可以很容易地使用 <code>DB.open</code> 来连接数据库。uri 的规则决定了所需要的驱动。下面的例子用 root 用户以及空密码连接到一个本地 mysql 数据库中的 test 库。</p>
<pre><code class="language-crystal">require &quot;db&quot;
require &quot;mysql&quot;

DB.open &quot;mysql://root@localhost/test&quot; do |db|
  # ... use db to perform queries
end
</code></pre>
<p>其他的 连接  uri 为：</p>
<ul>
<li><code>sqlite3:///path/to/data.db</code></li>
<li><code>mysql://user:password@server:port/database</code></li>
<li><code>postgres://server:port/database</code></li>
</ul>
<p>Alternatively you can use a non yielding <code>DB.open</code> method as long as <code>Database#close</code> is called at the end.
另外，在 <code>Database#close</code> 被调用之前，可以使用一个非生产的 <code>DB.open</code> 方法。</p>
<pre><code class="language-crystal">require &quot;db&quot;
require &quot;mysql&quot;

db = DB.open &quot;mysql://root@localhost/test&quot;
begin
  # ... use db to perform queries
ensure
  db.close
end
</code></pre>
<a class="header" href="print.html#a执行" id="a执行"><h2>执行</h2></a>
<p>可以用 <code>Database#exec</code> 来执行 sql 语句。</p>
<pre><code class="language-crystal">db.exec &quot;create table contacts (name varchar(30), age int)&quot;
</code></pre>
<p>用参数来提交数据以防止 sql 注入。</p>
<pre><code class="language-crystal">db.exec &quot;insert into contacts values (?, ?)&quot;, &quot;John&quot;, 30
db.exec &quot;insert into contacts values (?, ?)&quot;, &quot;Sarah&quot;, 33
</code></pre>
<p>Note: When using the pg driver, use <code>$1</code>, <code>$2</code>, etc. instead of <code>?</code>
注意：当用 pg 驱动时，用 <code>$</code> 、 <code>$2</code> 等代替 <code>?</code> 。</p>
<a class="header" href="print.html#a查询" id="a查询"><h2>查询</h2></a>
<p>使用 <code>Database#query</code> 来执行查询并获取结果集，在 <code>Database#exec</code> 中可以使用参数。</p>
<p><code>Database#query</code> 需要返回 <code>ResultSet</code> 类型来关闭查询。和在 <code>Database#open</code> 中一样，如果在代码块中调用，<code>ResultSet</code> 会默认关闭。</p>
<pre><code class="language-crystal">db.query &quot;select name, age from contacts order by age desc&quot; do |rs|
  rs.each do
    # ... perform for each row in the ResultSet
  end
end
</code></pre>
<p>当从数据库中读取值时，crystal 在编译时并无类型信息可用。你需要在类型 <code>T</code> 上调用 <code>rs.read(T)</code> 方法来从数据库中获取你想要的。</p>
<pre><code class="language-crystal">db.query &quot;select name, age from contacts order by age desc&quot; do |rs|
  rs.each do
    name = rs.read(String)
    age = rs.read(Int32)
    puts &quot;#{name} (#{age})&quot;
    # =&gt; Sarah (33)
    # =&gt; John Doe (30)
  end
end
</code></pre>
<p>有很多方便的查询方法被编译进 <code>#query</code> 里。</p>
<p>可以一次读取多个列：</p>
<pre><code class="language-crystal">name, age = rs.read(String, Int32)
</code></pre>
<p>或读取一行：</p>
<pre><code class="language-crystal">name, age = db.query_one &quot;select name, age from contacts order by age desc limit 1&quot;, as: { String, Int32 }
</code></pre>
<p>也可以读取标量值而无需用 ResultSet  明确的处理：</p>
<pre><code class="language-crystal">max_age = db.scalar &quot;select max(age) from contacts&quot;
</code></pre>
<p>所有在数据库中执行语句的可用方法都定义在 <code>DB::QueryMethods</code> 中。</p>
<a class="header" href="print.html#a连接池" id="a连接池"><h1>连接池</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/database/connection_pool.md">database/connection_pool.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/c7a2f89e6156a570f1a8183b47128dbcd9c391a9">commit c7a2f89e6156a570f1a8183b47128dbcd9c391a9</a></p>
</blockquote>
<p>当创建连接时，通常意味着打开了一个 TCP 连接或 Socket 。该 socket 一次处理一条语句。如果程序需要同时执行多条查询，或者处理旨在使用数据库的同时发生的请求，则需要多个有效连接。</p>
<p>鉴于应用在使用数据库时，数据库是独立的服务，连接可能丢失，服务可能重启，以及其他各种程序无需关心的情况。</p>
<p>在处理这样的问题上，一般连接池（ connection pool ）是一个利索的解决方法。</p>
<p>当使用 <code>crystal-db</code> 打开一个数据库时，已经有一个连接池在运行了。<code>DB.open</code> 返回一个 <code>DB::Database</code> 对象，其管理整个连接池而不仅仅是单个连接。</p>
<pre><code class="language-crystal">DB.open(&quot;mysql://root@localhost/test&quot;) do |db|
  # db is a DB::Database
end
</code></pre>
<p>当使用 <code>db.query</code> 、 <code>db.exec</code> 、 <code>db.scalar</code> 等执行语句时，该算法：</p>
<ol>
<li>在连接池中找到一个可用连接。
<ol>
<li>如果需要或可能的话，则创建一个连接。</li>
<li>如果连接池不再允许创建新的连接，则等待连接可用。
<ol>
<li>如果等待太久，则会被中断。</li>
</ol>
</li>
</ol>
</li>
<li>从连接池中检出该连接。</li>
<li>执行 SQL 命令。</li>
<li>如果无 `DB::ResultSet 产生，则将该连接返回给连接池。否则，则在 结果集关闭时返回给连接池。</li>
<li>返回语句结果。</li>
</ol>
<p>如果无法创建连接，或者在赤星语句时发生连接丢失，则重复上面的过程。</p>
<blockquote>
<p>重试逻辑只在通过 <code>DB::Database</code> 发送语句时发生。但如果用 <code>DB::Connection</code> 或 <code>DB::Transaction</code> 发送语句，是不执行重复逻辑的，因为代码规定了使用确定的连接对象。</p>
</blockquote>
<a class="header" href="print.html#a配置-1" id="a配置-1"><h2>配置</h2></a>
<p>可以用一个参数集来配置连接池的行为，该参数集出现在 URI 连接的查询语句中。</p>
<table><thead><tr><th align="left"> Name </th><th align="left"> Default value </th></tr></thead><tbody>
<tr><td align="left"> initial_pool_size </td><td align="left"> 1 </td></tr>
<tr><td align="left"> max_pool_size </td><td align="left"> 0 (unlimited) </td></tr>
<tr><td align="left"> max_idle_pool_size </td><td align="left"> 1 </td></tr>
<tr><td align="left"> checkout_timeout </td><td align="left"> 5.0 (seconds) </td></tr>
<tr><td align="left"> retry_attempts </td><td align="left"> 1 </td></tr>
<tr><td align="left"> retry_delay </td><td align="left"> 1.0 (seconds) </td></tr>
</tbody></table>
<p>当 <code>DB::Database</code> 打开时，则初始创建了 <code>initial_pool_size</code> 个连接。该连接池不会持有超过 <code>max_pool_size</code> 个连接。当把一个连接返回或释放给连接池时，如果有 <code>max_idle_pool_size</code> 个空闲连接，则该连接会被关闭。</p>
<p>如果达到 <code>max_pool_size</code> 而又需要一个连接时，则会等待一个已有连接可用直到 <code>checkout_timeout</code> 秒超时。</p>
<p>如果连接丢失或无法创建，重试至多 <code>retry_attempts</code> 次，每次间隔 <code>retry_delay</code> 秒。</p>
<a class="header" href="print.html#a示例" id="a示例"><h2>示例</h2></a>
<p>下面的程序会打印从 MySQL 中读取的当前时间，但如果丢失连接或整个服务宕机几秒，该程序仍然运行而没有抛异常。</p>
<pre><code class="language-crystal"># file: sample.cr
require &quot;mysql&quot;

DB.open &quot;mysql://root@localhost?retry_attempts=8&amp;retry_delay=3&quot; do |db|
  loop do
    pp db.scalar(&quot;SELECT NOW()&quot;)
    sleep 0.5
  end
end
</code></pre>
<pre><code>$ crystal sample.cr
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:57
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:57
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:58
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:58
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:59
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:36:59
# stop mysql server for some seconds
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:37:06
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:37:06
db.scalar(&quot;SELECT NOW()&quot;) # =&gt; 2016-12-16 16:37:07
</code></pre>
<a class="header" href="print.html#a指引" id="a指引"><h1>指引</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/guides/README.md">guides/README.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/4acc965da265244a9bef4a75f678e97e2bba63c0">commit 4acc965da265244a9bef4a75f678e97e2bba63c0</a></p>
</blockquote>
<p>阅读这些指引来优化 Crystal 。</p>
<a class="header" href="print.html#a性能" id="a性能"><h1>性能</h1></a>
<blockquote>
<p><a href="https://github.com/crystal-lang/crystal-book/blob/master/guides/performance.md">guides/performance.md</a></p>
<p><a href="https://github.com/crystal-lang/crystal-book/commit/1513574a9de427281f7d9a9d44af499796f721b1">commit 1513574a9de427281f7d9a9d44af499796f721b1</a></p>
</blockquote>
<p>遵从这些提示来让程序在运行速度和内存上获得更好的输出。</p>
<a class="header" href="print.html#a过早的优化" id="a过早的优化"><h2>过早的优化</h2></a>
<p>Donald Knuth 曾经说过：</p>
<blockquote>
<p>我们应该忘记小的效率，既是 97% 的时间：过早优化是万恶之源。然而我们不应该放弃那至关重要的 3% 的机会。</p>
</blockquote>
<p>但是，如果你正在编写程序，并且意识到编写相等的语义，更快的版本只涉及很小的更改，则不应该错过这个机会。</p>
<p>并始终确保分析程序以了解其瓶颈是什么。对于分析来说，在 Mac OSX 上可以使用 XCode 的 <a href="https://developer.apple.com/library/prerelease/content/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/Instrument-TimeProfiler.html">Instruments Time Profiler</a> 。在 Linux 上，任何可以分析 C/C++ 程序的程序，像 <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a> 或 <a href="http://valgrind.org/docs/manual/cl-manual.htm">Callgrind</a> ，应该有用。</p>
<p>确保始终通过使用 <code>--release</code> 标志编译并运行程序来对程序进行分析，这开启优化。</p>
<a class="header" href="print.html#a避免内存分配" id="a避免内存分配"><h2>避免内存分配</h2></a>
<p>可以在程序中进行的最好优化之一是避免额外的或无用的内存分配。在创建一个<strong>类</strong>的实例时会发生内存分配，这最终会分配堆内存。创建<strong>结构体</strong>的实例会使用栈内存，且不会招致性能惩罚。如果你不清楚栈内存和堆内存的区别，请务必<a href="https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap">阅读这个</a>。</p>
<p>分配堆内存很慢，并且它会给垃圾收集器（GC）带来更大的压力，因为它以后必须释放该内存。</p>
<p>这里有几种可以避免堆内存分配的方法。设计的标准库可以帮助你实现它。</p>
<a class="header" href="print.html#a在写-io-时不要创建中间字符串" id="a在写-io-时不要创建中间字符串"><h3>在写 IO 时不要创建中间字符串</h3></a>
<p>要将数字打印到标准输出，可以编写：</p>
<pre><code>puts 123
</code></pre>
<p>在很多编程语言中，会发生 <code>to_s</code> 调用，或相似的方法来将这个对象转换成其字符串表示，随后该字符串将会被写到标准输出。这是可以的，但有个缺陷：其在堆内存上创建一个中间字符串，只写这个字符串然后丢弃。这样做，调用了堆内存分配然后为 GC 增加了些工作。</p>
<p>在 Crystal 中 <code>puts</code> 会在对象上调用 <code>to_s(io)</code> ，将其传递给应该写入字符串表示的 IO。</p>
<p>所以，你永远不要这样做：</p>
<pre><code>puts 123.to_s
</code></pre>
<p>因为它创建一个中间字符串。总是将对象直接追加到 IO 上。</p>
<p>在编写自定义类型时，请务必确保重载 <code>to_s(io)</code>，而不是  <code>to_s</code> ，并避免在该方法中创建中间字符串。例如：</p>
<pre><code class="language-crystal">class MyClass
  # Good
  def to_s(io)
    # appends &quot;1, 2&quot; to IO without creating intermediate strings
    x = 1
    y = 2
    io &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y
  end

  # Bad
  def to_s(io)
    x = 1
    y = 2
    # using a string interpolation creates an intermediate string.
    # this should be avoided
    io &lt;&lt; &quot;#{x}, #{y}&quot;
  end
end
</code></pre>
<p>这种追加到 IO 而不是返回中间字符串的原则导致在性能上比处理中间字符串更好。你也应该在 API 定义中使用此策略。</p>
<p>比较下时间：</p>
<pre><code class="language-crystal"># io_benchmark.cr
require &quot;benchmark&quot;

io = IO::Memory.new

Benchmark.ips do |x|
  x.report(&quot;without to_s&quot;) do
    io &lt;&lt; 123
    io.clear
  end

  x.report(&quot;with to_s&quot;) do
    io &lt;&lt; 123.to_s
    io.clear
  end
end
</code></pre>
<p>输出：</p>
<pre><code>$ crystal run --release io_benchmark.cr
without to_s  77.11M ( 12.97ns) (± 1.05%)       fastest
   with to_s  18.15M ( 55.09ns) (± 7.99%)  4.25× slower
</code></pre>
<p>要记住，这不只是时间上的提升：内存用量也有所减少。</p>
<a class="header" href="print.html#a使用字符串插值而非串联" id="a使用字符串插值而非串联"><h3>使用字符串插值而非串联</h3></a>
<p>有时需要将字符串和其他值直接构建字符串组合。不应该只使用 <code>String#+(String)</code> 来连接这些字符串，而应该使用<a href="syntax_and_semantics/literals/string.html#interpolation">字符串插值</a>，它可以将表达式嵌入到字符串字面量中：<code>&quot;Hello, #{name}&quot;</code> 要比 <code>&quot;Hello, &quot; + name.to_s</code> 更好。</p>
<p>编译器转换插值字符串并将其追加到一个字符串 IO 上，以便其自动避免中间字符串。上面的例子可以转换为：<code>(StringBuilder.new &lt;&lt; &quot;Hello, &quot; &lt;&lt; name).to_s</code> 。</p>
<a class="header" href="print.html#a避免为字符串构建分配-io" id="a避免为字符串构建分配-io"><h3>避免为字符串构建分配 IO</h3></a>
<p>宁愿为构建字符串使用优化的专用 <code>String.build</code> ，而不要创建中间内存分配 <code>IO::Memory</code>。</p>
<pre><code class="language-crystal">require &quot;benchmark&quot;

Benchmark.ips do |bm|
  bm.report(&quot;String.build&quot;) do
    String.build do |io|
      99.times do
        io &lt;&lt; &quot;hello world&quot;
      end
    end
  end
  bm.report(&quot;IO::Memory&quot;) do
    io = IO::Memory.new
    99.times do
      io &lt;&lt; &quot;hello world&quot;
    end
    io.to_s
  end
end
</code></pre>
<p>输出：</p>
<pre><code>$ crystal run --release str_benchmark.cr
String.build 597.57k (  1.67µs) (± 5.52%)       fastest
  IO::Memory 423.82k (  2.36µs) (± 3.76%)  1.41× slower
</code></pre>
<a class="header" href="print.html#a避免反复创建临时对象" id="a避免反复创建临时对象"><h3>避免反复创建临时对象</h3></a>
<p>看下这个程序：</p>
<pre><code class="language-crystal">lines_with_language_reference = 0
while line = gets
  if [&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;].any? { |string| line.includes?(string) }
    lines_with_language_reference += 1
  end
end
puts &quot;Lines that mention crystal, ruby or java: #{lines_with_language_reference}&quot;
</code></pre>
<p>上面的程序可以运行但有很大的性能问题：每次迭代都会为 <code>[&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;]</code> 创建一个新的数组。记住：数组常量只是创建一个数组实例并向其添加一些值的语法糖，并且这在每次迭代时反复发生。</p>
<p>There are two ways to solve this:
有两种解决办法：</p>
<ol>
<li>使用元组。如果在上面的程序中使用 <code>{&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;}</code> ，其会以相同的方式运行，但因为元组不涉及堆内存，其会更快且消耗更少的内存，并给予编译器更多优化该程序的机会。</li>
</ol>
<pre><code class="language-crystal">lines_with_language_reference = 0
while line = gets
  if {&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;}.any? { |string| line.includes?(string) }
    lines_with_language_reference += 1
  end
end
puts &quot;Lines that mention crystal, ruby or java: #{lines_with_language_reference}&quot;
</code></pre>
<ol start="2">
<li>将数组定义为常量。</li>
</ol>
<pre><code class="language-crystal">LANGS = [&quot;crystal&quot;, &quot;ruby&quot;, &quot;java&quot;]

lines_with_language_reference = 0
while line = gets
  if LANGS.any? { |string| line.includes?(string) }
    lines_with_language_reference += 1
  end
end
puts &quot;Lines that mention crystal, ruby or java: #{lines_with_language_reference}&quot;
</code></pre>
<p>使用元组是首选的方式。</p>
<p>在循环中明确的数组常量是创建临时对象的方式之一，但这也可以通过方法调用来创建。例如 每次 <code>Hash#keys</code> 调用时将会返回一个新数组。除了这样做，可以使用 <code>Hash#each_key</code> 、 Hash#has_key?` 以及其他方法。</p>
<a class="header" href="print.html#a如果可能请使用结构体" id="a如果可能请使用结构体"><h3>如果可能请使用结构体</h3></a>
<p>如果为类型声明为一个<strong>结构体</strong>而不是<strong>类</strong>，那么创建该类型的实例将会使用堆内存，这要比堆内存更廉价，并且不会为 GC 增加压力。</p>
<p>也不要一直使用结构体。结构体是值传递的，所以将其传递给方法而方法修改了它，那么调用者将不会看到这些变化，所以这可能出错。最好的做法是只在可变对象上使用结构体，尤其它们都比较小时。</p>
<p>例如：</p>
<pre><code class="language-crystal"># class_vs_struct.cr
require &quot;benchmark&quot;

class PointClass
  getter x
  getter y

  def initialize(@x : Int32, @y : Int32)
  end
end

struct PointStruct
  getter x
  getter y

  def initialize(@x : Int32, @y : Int32)
  end
end

Benchmark.ips do |x|
  x.report(&quot;class&quot;) { PointClass.new(1, 2) }
  x.report(&quot;struct&quot;) { PointStruct.new(1, 2) }
end
</code></pre>
<p>输出：</p>
<pre><code>$ crystal run --release class_vs_struct.cr
 class  28.17M (± 2.86%) 15.29× slower
struct 430.82M (± 6.58%)       fastest
</code></pre>
<a class="header" href="print.html#a字符串迭代" id="a字符串迭代"><h2>字符串迭代</h2></a>
<p>Crystal 中的字符串一直以 UTF-8 编码。UTF-8 是一个变长编码：一个字符可能由几个字节表示，尽管字符在 ASCII 范围中总是由单个字节表示。因为这，用 <code>String#[]</code> 索引字符串并非 <code>O(1)</code> 操作，因为字节每次需要解码来找到给定位置的字符。Crystal 的 <code>String</code> 在这里有一种优化：如果知道字符串中所有的字符都是 ASCII，那么 <code>String#[]</code> 可以在 <code>O(1)</code> 内实现。然而通常这并不对。</p>
<p>由于这个原因，以这样的方法迭代字符串并不是最佳的，实际上是 <code>O(n^2)</code> 的复杂度：</p>
<pre><code class="language-crystal">string = ...
while i &lt; string.size
  char = string[i]
  # ...
end
</code></pre>
<p>上面的程序有第二个问题：计算字符串的 <code>大小</code> 也很慢，因为其并不是简单的字符串中的字节数（<code>bytesize</code>）。然而，一旦字符串的大小被计算出，它便被缓存了。</p>
<p>在这个案例中提升性能的方式是或使用迭代方法 (<code>each_char</code>，<code>each_byte</code>，<code>each_codepoint</code>) 之一，或使用更低级的 <code>Char::Reader</code> 结构体。例如，使用 <code>each_char</code> ：</p>
<pre><code class="language-crystal">string = ...
string.each_char do |char|
  # ...
end
</code></pre>
<a class="header" href="print.html#concurrency" id="concurrency"><h1>Concurrency</h1></a>
<a class="header" href="print.html#concurrency-vs-parallelism" id="concurrency-vs-parallelism"><h2>Concurrency vs. Parallelism</h2></a>
<p>The definitions of &quot;concurrency&quot; and &quot;parallelism&quot; sometimes get mixed up, but they are not the same.</p>
<p>A concurrent system is one that can be in charge of many tasks, although not necessarily it is executing them at the same time. You can think of yourself being in the kitchen cooking: you chop an onion, put it to fry, and while it's being fried you chop a tomato, but you are not doing all of those things at the same time: you distribute your time between those tasks. Parallelism would be to stir fry onions with one hand while with the other one you chop a tomato.</p>
<p>At the moment of this writing, Crystal has concurrency support but not parallelism: several tasks can be executed, and a bit of time will be spent on each of these, but two code paths are never executed at the same exact time.</p>
<p>A Crystal program executes in a single operating system thread, except the Garbage Collector (GC) which implements a concurrent mark-and-sweep (currently <a href="http://www.hboehm.info/gc/">Boehm GC</a>).</p>
<a class="header" href="print.html#fibers" id="fibers"><h3>Fibers</h3></a>
<p>To achieve concurrency, Crystal has fibers. A fiber is in a way similar to an operating system thread except that it's much more lightweight and its execution is managed internally by the process. So, a program will spawn multiple fibers and Crystal will make sure to execute them when the time is right.</p>
<a class="header" href="print.html#event-loop" id="event-loop"><h3>Event loop</h3></a>
<p>For everything I/O related there's an event loop. Some time-consuming operations are delegated to it, and while the event loop waits for that operation to finish the program can continue executing other fibers. A simple example of this is waiting for data to come through a socket.</p>
<a class="header" href="print.html#channels" id="channels"><h3>Channels</h3></a>
<p>Crystal has Channels inspired by <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a>. They allow communicating data between fibers without sharing memory and without having to worry about locks, semaphores or other special structures.</p>
<a class="header" href="print.html#execution-of-a-program" id="execution-of-a-program"><h2>Execution of a program</h2></a>
<p>When a program starts, it fires up a main fiber that will execute your top-level code. There, one can spawn many other fibers. The components of a program are:</p>
<ul>
<li>The Runtime Scheduler, in charge of executing all fibers when the time is right.</li>
<li>The Event Loop, which is just another fiber, being in charge of async tasks, like for example files, sockets, pipes, signals and timers (like doing a <code>sleep</code>).</li>
<li>Channels, to communicate data between fibers. The Runtime Scheduler will coordinate fibers and channels for their communication.</li>
<li>Garbage Collector: to clean up &quot;no longer used&quot; memory.</li>
</ul>
<a class="header" href="print.html#a-fiber" id="a-fiber"><h3>A Fiber</h3></a>
<p>A fiber is an execution unit that is more lightweight than a thread. It's a small object that has an associated <a href="https://en.wikipedia.org/wiki/Call_stack">stack</a> of 8MB, which is what is usually assigned to an operating system thread.</p>
<p>Fibers, unlike threads, are cooperative. Threads are pre-emptive: the operating system might interrupt a thread at any time and start executing another one. A fiber must explicitly tell the Runtime Scheduler to switch to another fiber. For example if there's I/O to be waited on, a fiber will tell the scheduler &quot;Look, I have to wait for this I/O to be available, you continue executing other fibers and come back to me when that I/O is ready&quot;.</p>
<p>The advantage of being cooperative is that a lot of the overhead of doing a context switch (switching between threads) is gone.</p>
<p>A Fiber is much more lightweight than a thread: even though it's assigned 8MB, it starts with a small stack of 4KB.</p>
<p>On a 64-bit machine it lets us spawn millions and millions of fibers. In a 32-bit machine we can only spawn 512 fibers, which is not a lot. But because 32-bit machines are starting to become obsolete, we'll bet on the future and focus more on 64-bit machines.</p>
<a class="header" href="print.html#the-runtime-scheduler" id="the-runtime-scheduler"><h3>The Runtime Scheduler</h3></a>
<p>The scheduler has a queue of:</p>
<ul>
<li>Fibers ready to be executed: for example when you spawn a fiber, it's ready to be executed.</li>
<li>The event loop: which is another fiber. When there are no other fibers ready to be executed, the event loop checks if there is any async operation that is ready, and then executes the fiber waiting for that operation. The event loop is currently implemented with <code>libevent</code>, which is an abstraction of other event mechanisms like <code>epoll</code> and <code>kqueue</code>.</li>
<li>Fibers that voluntarily asked to wait: this is done with <code>Fiber.yield</code>, which means &quot;I can continue executing, but I'll give you some time to execute other fibers if you want&quot;.</li>
</ul>
<a class="header" href="print.html#communicating-data" id="communicating-data"><h3>Communicating data</h3></a>
<p>Because at this moment there's only a single thread executing your code, accessing and modifying a class variable in different fibers will work just fine. However, once multiple threads (parallelism) is introduced in the language, it might break. That's why the recommended mechanism to communicate data is using channels and sending messages between them. Internally, a channel implements all the locking mechanisms to avoid data races, but from the outside you use them as communication primitives, so you (the user) don't have to use locks.</p>
<a class="header" href="print.html#sample-code" id="sample-code"><h2>Sample code</h2></a>
<a class="header" href="print.html#spawning-a-fiber" id="spawning-a-fiber"><h3>Spawning a fiber</h3></a>
<p>To spawn a fiber you use <code>spawn</code> with a block:</p>
<pre><code class="language-crystal">spawn do
  # ...
  socket.gets
  # ...
end

spawn do
  # ...
  sleep 5.seconds
  #  ...
end
</code></pre>
<p>Here we have two fibers: one reads from a socket and the other does a <code>sleep</code>. When the first fiber reaches the <code>socket.gets</code> line, it gets suspended, the Event Loop is told to continue executing this fiber when there's data in the socket, and the program continues with the second fiber. This fiber wants to sleep for 5 seconds, so the Event Loop is told to continue with this fiber in 5 seconds. If there aren't other fibers to execute, the Event Loop will wait until either of these events happen, without consuming CPU time.</p>
<p>The reason why <code>socket.gets</code> and <code>sleep</code> behave like this is because their implementations talk directly with the Runtime Scheduler and the Event Loop, there's nothing magical about it. In general, the standard library already takes care of doing all of this so you don't have to.</p>
<p>Note, however, that fibers don't get executed right away. For example:</p>
<pre><code class="language-crystal">spawn do
  loop do
    puts &quot;Hello!&quot;
  end
end
</code></pre>
<p>Running the above code will produce no output and exit immediately.</p>
<p>The reason for this is that a fiber is not executed as soon as it is spawned. So, the main fiber, the one that spawns the above fiber, finishes its execution and the program exits.</p>
<p>One way to solve it is to do a <code>sleep</code>:</p>
<pre><code class="language-crystal">spawn do
  loop do
    puts &quot;Hello!&quot;
  end
end

sleep 1.second
</code></pre>
<p>This program will now print &quot;Hello!&quot; for one second and then exit. This is because the <code>sleep</code> call will schedule the main fiber to be executed in a second, and then executes another &quot;ready to execute&quot; fiber, which in this case is the one above.</p>
<p>Another way is this:</p>
<pre><code class="language-crystal">spawn do
  loop do
    puts &quot;Hello!&quot;
  end
end

Fiber.yield
</code></pre>
<p>This time <code>Fiber.yield</code> will tell the scheduler to execute the other fiber. This will print &quot;Hello!&quot; until the standard output blocks (the system call will tell us we have to wait until the output is ready), and then execution continues with the main fiber and the program exits. Here the standard output <em>might</em> never block so the program will continue executing forever.</p>
<p>If we want to execute the spawned fiber for ever, we can use <code>sleep</code> without arguments:</p>
<pre><code class="language-crystal">spawn do
  loop do
    puts &quot;Hello!&quot;
  end
end

sleep
</code></pre>
<p>Of course the above program can be written without <code>spawn</code> at all, just with a loop. <code>sleep</code> is more useful when spawning more than one fiber.</p>
<a class="header" href="print.html#spawning-a-call" id="spawning-a-call"><h3>Spawning a call</h3></a>
<p>You can also spawn by passing a method call instead of a block. To understand why this is useful, let's look at this example:</p>
<pre><code class="language-crystal">i = 0
while i &lt; 10
  spawn do
    puts(i)
  end
  i += 1
end

Fiber.yield
</code></pre>
<p>The above program prints &quot;10&quot; ten times. The problem is that there's only one variable <code>i</code> that all spawned fibers refer to, and when <code>Fiber.yield</code> is executed its value is 10.</p>
<p>To solve this, we can do this:</p>
<pre><code class="language-crystal">i = 0
while i &lt; 10
  proc = -&gt;(x : Int32) do
    spawn do
      puts(x)
    end
  end
  proc.call(i)
  i += 1
end

Fiber.yield
</code></pre>
<p>Now it works because we are creating a <a href="http://crystal-lang.org/api/Proc.html">Proc</a> and we invoke it passing <code>i</code>, so the value gets copied and now the spawned fiber receives a copy.</p>
<p>To avoid all this boilerplate, the standard library provides a <code>spawn</code> macro that accepts a call expression and basically rewrites it to do the above. Using it, we end up with:</p>
<pre><code class="language-crystal">i = 0
while i &lt; 10
  spawn puts(i)
  i += 1
end

Fiber.yield
</code></pre>
<p>This is mostly useful with local variables that change at iterations. This doesn't happen with block arguments. For example, this works as expected:</p>
<pre><code class="language-crystal">10.times do |i|
  spawn do
    puts i
  end
end

Fiber.yield
</code></pre>
<a class="header" href="print.html#spawning-a-fiber-and-waiting-for-it-to-complete" id="spawning-a-fiber-and-waiting-for-it-to-complete"><h3>Spawning a fiber and waiting for it to complete</h3></a>
<p>We can use a channel for this:</p>
<pre><code class="language-crystal">channel = Channel(Nil).new

spawn do
  puts &quot;Before send&quot;
  channel.send(nil)
  puts &quot;After send&quot;
end

puts &quot;Before receive&quot;
channel.receive
puts &quot;After receive&quot;
</code></pre>
<p>This prints:</p>
<pre><code class="language-text">Before receive
Before send
After receive
</code></pre>
<p>First, the program spawns a fiber but doesn't execute it yet. When we invoke <code>channel.receive</code>, the main fiber blocks and execution continues with the spawned fiber. Then <code>channel.send(nil)</code> is invoked, and so execution continues at <code>channel.receive</code>, which was waiting for a value. Then the main fiber continues executing and finishes, so the program exits without giving the other fiber a chance to print &quot;After send&quot;.</p>
<p>In the above example we used <code>nil</code> just to communicate that the fiber ended. We can also use channels to communicate values between fibers:</p>
<pre><code class="language-crystal">channel = Channel(Int32).new

spawn do
  puts &quot;Before first send&quot;
  channel.send(1)
  puts &quot;Before second send&quot;
  channel.send(2)
end

puts &quot;Before first receive&quot;
value = channel.receive
puts value # =&gt; 1

puts &quot;Before second receive&quot;
value = channel.receive
puts value # =&gt; 2
</code></pre>
<p>Output:</p>
<pre><code class="language-text">Before first receive
Before first send
1
Before second receive
Before second send
2
</code></pre>
<p>Note that when the program executes a <code>receive</code>, that fiber blocks and execution continues with the other fiber. When <code>send</code> is executed, execution continues with the fiber that was waiting on that channel.</p>
<p>Here we are sending literal values, but the spawned fiber might compute this value by, for example, reading a file, or getting it from a socket. When this fiber will have to wait for I/O, other fibers will be able to continue executing code until I/O is ready, and finally when the value is ready and sent through the channel, the main fiber will receive it. For example:</p>
<pre><code class="language-crystal">require &quot;socket&quot;

channel = Channel(String).new

spawn do
  server = TCPServer.new(&quot;0.0.0.0&quot;, 8080)
  socket = server.accept
  while line = socket.gets
    channel.send(line)
  end
end

spawn do
  while line = gets
    channel.send(line)
  end
end

3.times do
  puts channel.receive
end
</code></pre>
<p>The above program spawns two fibers. The first one creates a TCPServer, accepts one connection and reads lines from it, sending them to the channel. There's a second fiber reading lines from standard input. The main fiber reads the first 3 messages sent to the channel, either from the socket or stdin, then the program exits. The <code>gets</code> calls will block the fibers and tell the Event Loop to continue from there if data comes.</p>
<p>Likewise, we can wait for multiple fibers to complete execution, and gather their values:</p>
<pre><code class="language-crystal">channel = Channel(Int32).new

10.times do |i|
  spawn do
    channel.send(i * 2)
  end
end

sum = 0
10.times do
  sum += channel.receive
end
puts sum # =&gt; 90
</code></pre>
<p>You can, of course, use <code>receive</code> inside a spawned fiber:</p>
<pre><code class="language-crystal">channel = Channel(Int32).new

spawn do
  puts &quot;Before send&quot;
  channel.send(1)
  puts &quot;After send&quot;
end

spawn do
  puts &quot;Before receive&quot;
  puts channel.receive
  puts &quot;After receive&quot;
end

puts &quot;Before yield&quot;
Fiber.yield
puts &quot;After yield&quot;
</code></pre>
<p>Output:</p>
<pre><code class="language-text">Before yield
Before send
Before receive
1
After receive
After send
After yield
</code></pre>
<p>Here <code>channel.send</code> is executed first, but since there's no one waiting for a value (yet), execution continues in other fibers. The second fiber is executed, there's a value on the channel, it's obtained, and execution continues, first with the first fiber, then with the main fiber, because <code>Fiber.yield</code> puts a fiber at the end of the execution queue.</p>
<a class="header" href="print.html#buffered-channels" id="buffered-channels"><h3>Buffered channels</h3></a>
<p>The above examples use unbuffered channels: when sending a value, if a fiber is waiting on that channel then execution continues on that fiber.</p>
<p>With a buffered channel, invoking <code>send</code> won't switch to another fiber unless the buffer is full:</p>
<pre><code class="language-crystal"># A buffered channel of capacity 2
channel = Channel(Int32).new(2)

spawn do
  puts &quot;Before send 1&quot;
  channel.send(1)
  puts &quot;Before send 2&quot;
  channel.send(2)
  puts &quot;Before send 3&quot;
  channel.send(3)
  puts &quot;After send&quot;
end

3.times do |i|
  puts channel.receive
end
</code></pre>
<p>Output:</p>
<pre><code>Before send 1
Before send 2
Before send 3
1
2
After send
3
</code></pre>
<p>Note that the first 2 sends are executed without switching to another fiber. However, in the third send the channel's buffer is full, so execution goes to the main fiber. Here the two values are received and the channel is depleted. At the third <code>receive</code> the main fiber blocks and execution goes to the other fiber, which sends more values, finishes, etc.</p>
<a class="header" href="print.html#a测试-crystal-代码" id="a测试-crystal-代码"><h1>测试 Crystal 代码</h1></a>
<p>Crystal comes with a fully-featured spec library in the <a href="https://crystal-lang.org/api/latest/Spec.html"><code>Spec</code> module</a>. It provides a structure for writing executable examples of how your code should behave.</p>
<p>Inspired by <a href="http://rspec.info/">Rspec</a>, it includes a domain specific language (DSL) that allows you to write examples in a way similar to plain english.</p>
<p>A basic spec looks something like this:</p>
<pre><code class="language-crystal">require &quot;spec&quot;

describe Array do
  describe &quot;#size&quot; do
    it &quot;correctly reports the number of elements in the Array&quot; do
      [1, 2, 3].size.should eq 3
    end
  end

  describe &quot;#empty?&quot; do
    it &quot;is true when no elements are in the array&quot; do
      ([] of Int32).empty?.should be_true
    end

    it &quot;is false if there are elements in the array&quot; do
      [1].empty?.should be_false
    end
  end
end
</code></pre>
<a class="header" href="print.html#anatomy-of-a-spec-file" id="anatomy-of-a-spec-file"><h2>Anatomy of a spec file</h2></a>
<p>To use the spec module and DSL, you need to add <code>require &quot;spec&quot;</code> to your spec files. Many projects use a custom <a href="print.html#spec-helper">spec helper</a> which organizes these includes.</p>
<p>Concrete test cases are defined in <code>it</code> blocks. An optional (but strongly recommended) descriptive string states it's purpose and a block contains the main logic performing the test.</p>
<p>Test cases that have been defined or outlined but are not yet expected to work can be defined using <code>pending</code> instead of <code>it</code>. They will not be run but show up in the spec report as pending.</p>
<p>An <code>it</code> block contains an example that should invoke the code to be tested and define what is expected of it. Each example can contain multiple expectations, but it should test only one specific behaviour.</p>
<p>When <code>spec</code> is included, every object has the instance methods <code>#should</code> and <code>#should_not</code>. These methods are invoked on the value being tested with an expectation as argument. If the expectation is met, code execution continues. Otherwise the example has <em>failed</em> and other code in this block will not be executed.</p>
<p>In test files, specs are structured by example groups which are defined by <code>describe</code> and <code>context</code> sections. Typically a top level <code>describe</code> defines the outer unit (such as a class) to be tested by the spec. Further <code>describe</code> sections can be nested within the outer unit to specify smaller units under test (such as individual methods).</p>
<p>For unit tests, it is recommended to follow the conventions for method names: Outer <code>describe</code> is the name of the class, inner <code>describe</code> targets methods. Instance methods are prefixed with <code>#</code>, class methods with <code>.</code>.</p>
<p>To establish certain contexts - think <em>empty array</em> versus <em>array with elements</em> - the <code>context</code> method may be used to communicate this to the reader. It has a different name, but behaves exactly like <code>describe</code>.</p>
<p><code>describe</code> and <code>context</code> take a description as argument (which should usually be a string) and a block containing the individual specs or nested groupings.</p>
<a class="header" href="print.html#expectations" id="expectations"><h2>Expectations</h2></a>
<p>Expectations define if the value being tested (<em>actual</em>) matches a certain value or specific criteria.</p>
<a class="header" href="print.html#equivalence-identity-and-type" id="equivalence-identity-and-type"><h3>Equivalence, Identity and Type</h3></a>
<p>There are methods to create expectations which test for equivalence (<code>eq</code>), identity (<code>be</code>), type (<code>be_a</code>), and nil (<code>be_nil</code>).
Note that the identity expectation uses <code>.same?</code> which tests if <a href="https://crystal-lang.org/api/latest/Reference.html#object_id%3AUInt64-instance-method"><code>#object_id</code></a> are identical. This is only true if the expected value points to <em>the same object</em> instead of <em>an equivalent one</em>. This is only possible for reference types and won't work for value types like structs or numbers.</p>
<pre><code class="language-crystal">actual.should eq(expected)    # passes if actual == expected
actual.should be(expected)    # passes if actual.same?(expected)
actual.should be_a(expected)  # passes if actual.is_a?(expected)
actual.should be_nil          # passes if actual.nil?
</code></pre>
<a class="header" href="print.html#truthiness" id="truthiness"><h3>Truthiness</h3></a>
<pre><code class="language-crystal">actual.should be_true         # passes if actual == true
actual.should be_false        # passes if actual == false
actual.should be_truthy       # passes if actual is truthy (neither nil nor false nor Pointer.null)
actual.should be_falsey       # passes if actual is falsey (nil, false or Pointer.null)
</code></pre>
<a class="header" href="print.html#comparisons" id="comparisons"><h3>Comparisons</h3></a>
<pre><code class="language-crystal">actual.should be &lt;  expected  # passes if actual &lt;  expected
actual.should be &lt;= expected  # passes if actual &lt;= expected
actual.should be &gt;  expected  # passes if actual &gt;  expected
actual.should be &gt;= expected  # passes if actual &gt;= expected
</code></pre>
<a class="header" href="print.html#other-matchers" id="other-matchers"><h3>Other matchers</h3></a>
<pre><code class="language-crystal">actual.should be_close(expected, delta) # passes if actual is within delta of expected:
                                        # (actual - expected).abs &lt;= delta
actual.should contain(expected)         # passes if actual.includes?(expected)
actual.should match(expected)           # passes if actual =~ expected
</code></pre>
<a class="header" href="print.html#expecting-errors" id="expecting-errors"><h3>Expecting errors</h3></a>
<p>These matchers run a block and pass if it raises a certain exception.</p>
<pre><code class="language-crystal">expect_raises(MyError) do
  # Passes if this block raises an exception of type MyError.
end

expect_raises(MyError, &quot;error message&quot;) do
  # Passes if this block raises an exception of type MyError
  # and the error message contains &quot;error message&quot;.
end

expect_raises(MyError, /error \w{7}/) do
  # Passes if this block raises an exception of type MyError
  # and the error message matches the regular expression.
end
</code></pre>
<p>They return the rescued exception so it can be used for further expectations, for example to verify specific properties of the exception.</p>
<a class="header" href="print.html#running-specs" id="running-specs"><h2>Running specs</h2></a>
<p>The Crystal compiler has a <code>spec</code> command with tools to constrain which examples get run and tailor the output. All specs of a project are compiled and executed through the command <code>crystal spec</code>.</p>
<p>By convention, specs live in the <code>spec/</code> directory of a project. Spec files must end with <code>_spec.cr</code> to be recognizable as such by the compiler command.</p>
<p>You can compile and run specs from folder trees, individual files or specific lines in a file.</p>
<pre><code class="language-bash"># Run  all specs in files matching spec/**/*_spec.cr
crystal spec

# Run all specs in files matching spec/my/test/**/*_spec.cr
crystal spec spec/my/test/

# Run all specs in spec/my/test/file_spec.cr
crystal spec spec/my/test/file_spec.cr

# Run the spec or group defined in line 14 of spec/my/test/file_spec.cr
crystal spec spec/my/test/file_spec.cr:14
</code></pre>
<p>If the specified line is the beginning of a <code>describe</code> or <code>context</code> section, all specs inside that group are run.</p>
<p>The default formatter outputs the file and line style command for failing specs which makes it easy to rerun just this individual spec.</p>
<a class="header" href="print.html#spec-helper" id="spec-helper"><h2>Spec helper</h2></a>
<p>Many projects use a custom spec helper file, usually named <code>spec/spec_helper.cr</code>.</p>
<p>This file is used to require <code>spec</code> and other includes like code from the project needed for every spec file. This is also a good place to define global helper methods that make writing specs easier and avoid code duplication.</p>
<pre><code class="language-crystal"># spec/spec_helper.cr
require &quot;spec&quot;
require &quot;../src/my_project.cr&quot;

def create_test_object(name)
  project = MyProject.new(option: false)
  object = project.create_object(name)
  object
end

# spec/my_project_spec.cr
require &quot;./spec_helper&quot;

describe &quot;MyProject::Object&quot; do
  it &quot;is created&quot; do
    object = create_test_object(name)
    object.should_not be_nil
  end
end
</code></pre>
<a class="header" href="print.html#a编写-shard" id="a编写-shard"><h1>编写 Shard</h1></a>
<p>如何编写以及发布 Shard 。</p>
<a class="header" href="print.html#a什么是-shard-" id="a什么是-shard-"><h2><em>什么是 Shard ？</em></h2></a>
<p>简单来说，Shard 是指可以被共享或被其他项目使用的 Crystal 代码包。</p>
<a class="header" href="print.html#a简介" id="a简介"><h2>简介</h2></a>
<p>本教程中，我们创建了一个名为 <em>palindrome-example</em> 的 Crystal 库。</p>
<blockquote>
<p>For those who don't know, a palindrome is a word which is spelled the same way forwards as it is backwards. e.g. racecar, mom, dad, kayak, madam</p>
</blockquote>
<a class="header" href="print.html#a要求" id="a要求"><h3>要求</h3></a>
<p>为了发布 Crystal Shard ，并渐渐理解教程，你需要下列各项：</p>
<ul>
<li>一个可运行的 <a href="../using_the_compiler/README.md">Crystal 编译器</a> 安装</li>
<li>一个可运行的 <a href="https://git-scm.com">Git</a> 安装</li>
<li>一个 <a href="https://github.com">GitHub</a> 账号</li>
</ul>
<a class="header" href="print.html#a创建项目" id="a创建项目"><h3>创建项目</h3></a>
<p>首先，以 <a href="../using_the_compiler/README.md">Crystal 编译器</a>的 <code>init lib</code> 命令来创建一个具有标准目录结构的 Crystal 库。</p>
<p>在终端中：<code>crystal init lib &lt;YOUR-SHARD-NAME&gt;</code></p>
<p>例如</p>
<pre><code class="language-bash"> $  crystal init lib palindrome-example
      create  palindrome-example/.gitignore
      create  palindrome-example/.editorconfig
      create  palindrome-example/LICENSE
      create  palindrome-example/README.md
      create  palindrome-example/.travis.yml
      create  palindrome-example/shard.yml
      create  palindrome-example/src/palindrome-example.cr
      create  palindrome-example/src/palindrome-example/version.cr
      create  palindrome-example/spec/spec_helper.cr
      create  palindrome-example/spec/palindrome-example_spec.cr
Initialized empty Git repository in /&lt;YOUR-DIRECTORY&gt;/.../palindrome-example/.git/
</code></pre>
<p>然后 <code>cd</code> 到目录下：</p>
<p>例如</p>
<pre><code class="language-bash">cd palindrome-example
</code></pre>
<p>然后使用 Git 的来 <code>添加</code> 和 <code>提交</code> 来追踪文件：</p>
<pre><code class="language-bash"> $  git add -A
 $  git commit -am &quot;First Commit&quot;
[master (root-commit) 77bad84] First Commit
 10 files changed, 102 insertions(+)
 create mode 100644 .editorconfig
 create mode 100644 .gitignore
 create mode 100644 .travis.yml
 create mode 100644 LICENSE
 create mode 100644 README.md
 create mode 100644 shard.yml
 create mode 100644 spec/palindrome-example_spec.cr
 create mode 100644 spec/spec_helper.cr
 create mode 100644 src/palindrome-example.cr
 create mode 100644 src/palindrome-example/version.cr
</code></pre>
<a class="header" href="print.html#a编写代码" id="a编写代码"><h3>编写代码</h3></a>
<p>代码由你来写，但你所写的代码影响到别人是否愿意使用你的库或者帮你维护它。</p>
<a class="header" href="print.html#a测试代码" id="a测试代码"><h4>测试代码</h4></a>
<ul>
<li>测试代码。对任何人，包括你来说，这是知道所写的库是否正常的唯一方式。</li>
<li>Crystal 有个<a href="https://crystal-lang.org/api/Spec.html">内置测试库</a>。使用它吧。</li>
</ul>
<a class="header" href="print.html#a文档" id="a文档"><h4>文档</h4></a>
<ul>
<li>使用注释来文档化你的代码。所有的代码，甚至私有方法。</li>
<li>Crystal 有个内置<a href="../conventions/documenting_code.md">文档生成器</a>。使用它吧。</li>
</ul>
<p>运行 <code>crystal docs</code> 来把代码和注释转换为可连接的 API 文档。在 <code>/docs/</code> 目录下用 web 浏览器打开文件以看看你的文档长什么样。</p>
<p>See below for instructions on hosting your compiler-generated docs on GitHub Pages.</p>
<p>Once your documentation is ready and available, add this documentation badge below the description in your README.md so users know that it exists.
(Be sure to replace <code>&lt;LINK-TO-YOUR-DOCUMENTATION&gt;</code> accordingly)</p>
<pre><code class="language-Markdown">[![Docs](https://img.shields.io/badge/docs-available-brightgreen.svg)](&lt;LINK-TO-YOUR-DOCUMENTATION&gt;) 
</code></pre>
<a class="header" href="print.html#a编写-readme" id="a编写-readme"><h3>编写 README</h3></a>
<p>A good README can make or break your project.
<a href="https://github.com/matiassingers/awesome-readme">Awesome README</a> is a nice curation of examples and resources on the topic.</p>
<p>Most importantly, your README should explain:</p>
<ol>
<li>What your library is</li>
<li>What it does</li>
<li>How to use it</li>
</ol>
<p>This explanation should include a few examples along with subheadings.</p>
<p>NOTE: Be sure to replace all instances of <code>[your-github-name]</code> in the Crystal-generated README template with your GitHub username.</p>
<a class="header" href="print.html#a代码风格-1" id="a代码风格-1"><h4>代码风格</h4></a>
<ul>
<li>It's fine to have your own style, but sticking to <a href="../conventions/coding_style.md">some core rubrics defined by the Crystal team</a> can help keep your code consistent, readable and usable for other developers.</li>
<li>Utilize Crystal's <a href="../conventions/documenting_code.md">built-in code formatter</a> to automatically format all <code>.cr</code> files in a directory.</li>
</ul>
<p>e.g.</p>
<pre><code>crystal tool format
</code></pre>
<p>To check if your code is formatted correctly, or to check if using the formatter wouldn't produce any changes, simply add <code>--check</code> to the end of this command.</p>
<p>e.g.</p>
<pre><code>crystal tool format --check
</code></pre>
<p>See the Travis CI section below to implement this in your build.</p>
<a class="header" href="print.html#a编写-shardyml" id="a编写-shardyml"><h3>编写 <code>shard.yml</code></h3></a>
<p><a href="https://github.com/crystal-lang/shards/blob/master/SPEC.md#names">The spec</a> is your rulebook. Follow it.</p>
<a class="header" href="print.html#a命名-1" id="a命名-1"><h4>命名</h4></a>
<p>Your <code>shard.yml</code>'s <code>name</code> property should be concise and descriptive.</p>
<ul>
<li>Search <a href="https://crystalshards.xyz/">crystalshards.xyz</a> to check if your name is already taken.</li>
</ul>
<p>e.g.</p>
<pre><code class="language-YAML">name: palindrome-example
</code></pre>
<a class="header" href="print.html#a描述" id="a描述"><h4>描述</h4></a>
<p>Add a <code>description</code> to your <code>shard.yml</code>.</p>
<p>A <code>description</code> is a single line description used to search for and find your shard.</p>
<p>A description should be:</p>
<ol>
<li>Informative</li>
<li>Discoverable</li>
</ol>
<a class="header" href="print.html#a优化" id="a优化"><h4>优化</h4></a>
<p>It's hard for anyone to use your project if they can't find it.
<a href="https://crystalshards.xyz/">crystalshards.xyz</a> is currently the go-to place for Crystal libraries, so that's what we'll optimize for.</p>
<p>There are people looking for the <em>exact</em> functionality of our library and the <em>general</em> functionality of our library.
e.g. Bob needs a palindrome library, but Felipe is just looking for libraries involving text and Susan is looking for libraries involving spelling.</p>
<p>Our <code>name</code> is already descriptive enough for Bob's search of &quot;palindrome&quot;. We don't need to repeat the <em>palindrome</em> keyword. Instead, we'll catch Susan's search for &quot;spelling&quot; and Felipe's search for &quot;text&quot;.</p>
<pre><code class="language-YAML">description: |
  A textual algorithm to tell if a word is spelled the same way forwards as it is backwards.
</code></pre>
<a class="header" href="print.html#github" id="github"><h3>GitHub</h3></a>
<ul>
<li>
<p>Create a repository with the same <code>name</code> and <code>description</code> as specified in your <code>shard.yml</code>.</p>
</li>
<li>
<p>Add and commit everything:</p>
</li>
</ul>
<pre><code class="language-bash">$ git add -A &amp;&amp; git commit -am &quot;shard complete&quot;
</code></pre>
<ul>
<li>Add the remote: (Be sure to replace <code>&lt;YOUR-GITHUB-USERNAME&gt;</code> and <code>&lt;YOUR-REPOSITORY-NAME&gt;</code> accordingly)</li>
</ul>
<p>NOTE: If you like, feel free to replace <code>public</code> with <code>origin</code>, or a remote name of your choosing.</p>
<pre><code class="language-bash">$ git remote add public https://github.com/&lt;YOUR-GITHUB-NAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;.git
</code></pre>
<ul>
<li>Push it:</li>
</ul>
<pre><code class="language-bash">$ git push public master
</code></pre>
<a class="header" href="print.html#github-发布" id="github-发布"><h4>GitHub 发布</h4></a>
<p>It's good practice to do GitHub Releases.</p>
<p>Add the following markdown build badge below the description in your README to inform users what the most current release is:
(Be sure to replace <code>&lt;YOUR-GITHUB-USERNAME&gt;</code> and <code>&lt;YOUR-REPOSITORY-NAME&gt;</code> accordingly)</p>
<pre><code class="language-Markdown">[![GitHub release](https://img.shields.io/github/release/&lt;YOUR-GITHUB-USERNAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;.svg)](https://github.com/&lt;YOUR-GITHUB-USERNAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;/releases)
</code></pre>
<p>Start by navigating to your repository's <em>releases</em> page.</p>
<ul>
<li>This can be found at <code>https://github.com/&lt;YOUR-GITHUB-NAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;/releases</code></li>
</ul>
<p>Click &quot;Create a new release&quot;.</p>
<p>According to <a href="https://github.com/crystal-lang/shards/blob/master/README.md">the Crystal Shards README</a>,</p>
<blockquote>
<p>When libraries are installed from Git repositories, the repository is expected to have version tags following a semver-like format, prefixed with a <code>v</code>. Examples: v1.2.3, v2.0.0-rc1 or v2017.04.1</p>
</blockquote>
<p>Accordingly, in the input that says <code>tag version</code>, type <code>v0.1.0</code>. Make sure this matches the <code>version</code> in <code>shard.yml</code>. Title it <code>v0.1.0</code> and write a short description for the release.</p>
<p>Click &quot;Publish release&quot; and you're done!</p>
<p>You'll now notice that the GitHub Release badge has updated in your README.</p>
<p>Follow <a href="http://semver.org/">Semantic Versioning</a> and create a new release every time your push new code to <code>master</code>.</p>
<a class="header" href="print.html#travis-ci-和-travisyml" id="travis-ci-和-travisyml"><h3>Travis CI 和 <code>.travis.yml</code></h3></a>
<p>If you haven't already, <a href="https://travis-ci.org/">sign up for Travis CI</a>.</p>
<p>Insert the following markdown build badge below the description in your README.md:
(be sure to replace <code>&lt;YOUR-GITHUB-USERNAME&gt;</code> and <code>&lt;YOUR-REPOSITORY-NAME&gt;</code> accordingly)</p>
<pre><code class="language-Markdown">[![Build Status](https://travis-ci.org/&lt;YOUR-GITHUB-USERNAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;.svg?branch=master)](https://travis-ci.org/&lt;YOUR-GITHUB-USERNAME&gt;/&lt;YOUR-REPOSITORY-NAME&gt;) 
</code></pre>
<p>Build badges are a simple way to tell people whether your Travis CI build passes.</p>
<p>Add the following lines to your <code>.travis.yml</code>:</p>
<pre><code class="language-YAML">script:
  - crystal spec
</code></pre>
<p>This tells Travis CI to run your tests.
Accordingly with the outcome of this command, Travis CI will return a <a href="https://docs.travis-ci.com/user/customizing-the-build/#Breaking-the-Build">build status</a> of &quot;passed&quot;, &quot;errored&quot;, &quot;failed&quot; or &quot;canceled&quot;.</p>
<p>If you want to verify that all your code has been formatted with <code>crystal tool format</code>, add a script for <code>crystal tool format --check</code>. If the code is not formatted correctly, this will <a href="https://docs.travis-ci.com/user/for-beginners/#Breaking-the-Build">break the build</a> just as failing tests would.</p>
<p>e.g.</p>
<pre><code class="language-YAML">script:
  - crystal spec
  - crystal tool format --check
</code></pre>
<p>Commit and push to GitHub.</p>
<p>Follow <a href="https://docs.travis-ci.com/user/getting-started/">these guidelines</a> to get your repo up &amp; running on Travis CI.</p>
<p>Once you're up and running, and the build is passing, the build badge will update in your README.</p>
<a class="header" href="print.html#hosting-your-docs-on-github-pages" id="hosting-your-docs-on-github-pages"><h4>Hosting your <code>docs</code> on GitHub-Pages</h4></a>
<p>Add the following <code>script</code> to your <code>.travis.yml</code>:</p>
<pre><code class="language-YAML">  - crystal docs
</code></pre>
<p>This tells Travis CI to generate your documentation.</p>
<p>Next, add the following lines to your <code>.travis.yml</code>.
(Be sure to replace all instances of <code>&lt;YOUR-GITHUB-REPOSITORY-NAME&gt;</code> accordingly)</p>
<pre><code class="language-YAML">deploy:
  provider: pages
  skip_cleanup: true
  github_token: $GITHUB_TOKEN
  project_name: &lt;YOUR-GITHUB-REPOSITORY-NAME&gt;
  on:
    branch: master
  local_dir: docs
</code></pre>
<p><a href="https://docs.travis-ci.com/user/environment-variables#Defining-Variables-in-Repository-Settings">Set the Environment Variable</a>, <code>GITHUB_TOKEN</code>, with your <a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/">personal access token</a>.</p>
<p>If you've been following along, your <code>.travis.yml</code> file should look something like this:</p>
<pre><code class="language-YAML">language: crystal
script:
  - crystal spec
  - crystal docs
deploy:
  provider: pages
  skip_cleanup: true
  github_token: $GITHUB_TOKEN
  project_name: &lt;YOUR-GITHUB-REPOSITORY-NAME&gt;
  on:
    branch: master
  local_dir: docs
</code></pre>
<p><a href="https://docs.travis-ci.com/user/deployment/pages/">点击此处</a> 以获取使用 Travis CI 发布到 GitHub-Pages 页面的官方文档。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            document.addEventListener('DOMContentLoaded', function() {
                window.print();
            })
        </script>
        

        

        
        <script src="searchindex.js" type="text/javascript" charset="utf-8"></script>
        
        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

    </body>
</html>
